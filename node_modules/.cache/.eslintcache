[{"/home/thomas/Dev/RouteOptimizationVisualizer/src/index.js":"1","/home/thomas/Dev/RouteOptimizationVisualizer/src/App.js":"2","/home/thomas/Dev/RouteOptimizationVisualizer/src/sketch.js":"3","/home/thomas/Dev/RouteOptimizationVisualizer/src/Node.js":"4","/home/thomas/Dev/RouteOptimizationVisualizer/src/Graph.js":"5","/home/thomas/Dev/RouteOptimizationVisualizer/src/Edge.js":"6","/home/thomas/Dev/RouteOptimizationVisualizer/src/Blossom.js":"7"},{"size":172,"mtime":1739998090156,"results":"8","hashOfConfig":"9"},{"size":7444,"mtime":1740057501468,"results":"10","hashOfConfig":"9"},{"size":35686,"mtime":1739998090156,"results":"11","hashOfConfig":"9"},{"size":122,"mtime":1739998090156,"results":"12","hashOfConfig":"9"},{"size":3578,"mtime":1739998090156,"results":"13","hashOfConfig":"9"},{"size":527,"mtime":1739998090156,"results":"14","hashOfConfig":"9"},{"size":22925,"mtime":1739998090156,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","suppressedMessages":"18","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"19"},"5gdpqp",{"filePath":"20","messages":"21","suppressedMessages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"23","messages":"24","suppressedMessages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":39,"fixableErrorCount":0,"fixableWarningCount":0,"source":"26","usedDeprecatedRules":"19"},{"filePath":"27","messages":"28","suppressedMessages":"29","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"19"},{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"33","usedDeprecatedRules":"19"},{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"37","usedDeprecatedRules":"19"},{"filePath":"38","messages":"39","suppressedMessages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"41","usedDeprecatedRules":"19"},"/home/thomas/Dev/RouteOptimizationVisualizer/src/index.js",[],[],[],"/home/thomas/Dev/RouteOptimizationVisualizer/src/App.js",[],[],"/home/thomas/Dev/RouteOptimizationVisualizer/src/sketch.js",["42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80"],[],"import {Graph} from './Graph.js';\nimport {Node} from './Node.js';\nimport {Edge} from './Edge.js';\nimport {Edmonds} from './Blossom.js'; \n\nlet WIDTH = window.innerWidth; //\"static variables\" like in java\nlet HEIGHT = window.innerHeight *3/ 5;\nlet speed = 5; \n\nlet startNode = new Node(WIDTH / 2, HEIGHT / 2, 0);\nlet count = 1; //count the nodes\nlet graph = new Graph(0);\nlet totalGraph = new Graph(0);\nlet startDefined = false;\nlet algo = \"Not Defined\";\nlet localSearch = \"Not defined\";\nlet isPlaying = true;\n// state is 0 if no path found yet\n// 1 if we already have a solution (that we might want to improve)\nlet state = 0;\nlet eulerCycle = [];\n\nconst sketch = (p) => {\n\n  let addingNodes = false;\n  let isRunning = false;\n  let clearingBoard = false;\n  //let algoFinished = false;\n  let setIsPlaying = p.setIsPlaying;\n\n  p.setup = () => {\n    p.createCanvas(WIDTH, HEIGHT);\n  };\n\n  p.windowResized = () => {\n    WIDTH = window.innerWidth;\n    HEIGHT = window.innerHeight *3/5;\n    p.resizeCanvas(WIDTH, HEIGHT);\n  }\n\n  p.draw = async () => {\n    p.background(220);\n    //draw the nodes\n    //mouse position and already added nodes white\n    p.fill(\"#fff\");\n    p.circle(p.mouseX, p.mouseY, 10);\n    if (startDefined) {\n      let nodes = graph.getNodes();\n      for (let node of nodes) {\n        if (node.color)\n          p.fill(node.color);\n        else \n          p.fill(\"#fff\");\n        p.circle(node.x, node.y, 10);\n      }\n      //draw edges \n      drawEdges(p);\n    }\n     //start node pink\n     p.fill(255, 0, 200);\n     p.circle(startNode.x, startNode.y, 10);\n\n    //if we did not find any solution yet, we will run a algorithm to find inital solution\n    if (state == 0) {\n      if (isRunning) {\n        console.log(\"Starting here\");\n\n        isRunning = false;\n        setIsPlaying(true);\n        isPlaying = true;\n        isRunning = false;\n        switch(algo) {\n          case 'Nearest Insertion':\n            await insertion(\"nearest\");\n            break;\n            case 'Farthest Insertion':\n              await insertion(\"farthest\");\n              break;\n            case 'Nearest Neighbor':\n              await nearestNeighbor(startNode, new Array(graph.V).fill(false), false);\n              break;\n            case 'Nearest Neighbor Look Ahead (made up)':\n              await nearestNeighborImproved();\n              break;\n            case 'Brute Force':\n              await bruteForce(startNode, new Array(graph.V).fill(false), 0);\n              break;\n            case 'Cluster naively':\n              await clusterNaively();\n              break;\n            case 'Christofides':\n              await christofides();\n              break;\n            default:\n              isRunning = false;\n        }\n        setIsPlaying(false);\n        isPlaying = false;\n        isRunning = false;\n        state = 1;\n      }\n    }\n    if (state == 1) {\n      if (isRunning) {\n        console.log(\"Starting here\");\n        isRunning = false;\n        setIsPlaying(true);\n        isPlaying = true;\n        isRunning = false;\n        switch (localSearch) {\n          case '2-opt':\n            await twoOpt();\n            break;\n          default:\n          case '3-opt':\n            await threeOpt();\n            break;\n          \n        }\n        setIsPlaying(false);\n        isPlaying = false;\n        isRunning = false;\n\n      }\n    }\n\n  };\n\n\n  function anyNodeHasNeighbors() {\n    return graph.E > 0;\n  }\n\n\n  function drawEdges(p) {\n    //displayNeihbors(startNode);\n    if (anyNodeHasNeighbors()) {\n      let edges = graph.getEdges();\n      for (let e of edges) {\n        if (e.color) {\n          p.stroke(e.color);\n        }\n        else \n          p.stroke('black');\n        let v1 = e.either();\n        let v2 = e.other(v1);\n        let x1 = v1.x;\n        let y1 = v1.y;\n        let x2 = v2.x;\n        let y2 = v2.y;\n        p.line(x1, y1, x2, y2);\n      }\n    }\n  }\n\n  // async function waitForIsPlaying() {\n  //   if (isPlaying)\n  //     return;\n  //   delay(1000);\n  //   await waitForIsPlaying();\n  // }\n\n  async function waitForIsPlaying() {\n    return new Promise(resolve => {\n      function checkIsPlaying() {\n        if (isPlaying) {\n          resolve();\n        } else {\n          setTimeout(checkIsPlaying, 300);\n        }\n      }\n      checkIsPlaying();\n    });\n  }\n  \n\n  function removeAllEdges() {\n    let tempGraph = new Graph(0);\n    for (let node of graph.getNodes())\n      tempGraph.addVertex(node);\n    graph = tempGraph;\n    totalGraph = new Graph(0);\n  }\n\n\n  \n  p.mouseClicked = async () => {\n    if (addingNodes) \n      addNodes(p);\n    //the algorithm updates the paths that p.draw() displays\n  };\n\n  /**\n   * Adding nodes to canvas\n   * @param {}\n   */\n  function addNodes(p) {\n    if (!startDefined) {\n      graph.addVertex(startNode);\n      startDefined = true;\n    }\n    p.loop();\n    //if Y is smaller than HEIGHT, the click was outside of canvas (probably on button) and the don't add\n    if (p.mouseY < HEIGHT && p.mouseY > 0) {\n      let node = new Node(p.mouseX, p.mouseY, count++);\n      graph.addVertex(node);\n    }\n  }\n\n    //this function \"sends\" data/additional parameters to our function. When ever the props change, the change is passed here\n    p.updateWithProps = function (newProps) {\n      if (newProps.removeEdges) {\n        removeAllEdges();\n        let nodes = graph.getNodes();\n        for (let node of nodes) {\n          node.color = '#fff';\n        }\n        state = 0;\n      }\n      setIsPlaying = newProps.setIsPlaying;\n      addingNodes = newProps.addingNodes;\n      isRunning = newProps.isRunning;\n      clearingBoard = newProps.clearinBoard;\n      isPlaying = newProps.isPlaying;\n      if (clearingBoard) {\n        startNode = new Node(WIDTH / 2, HEIGHT / 2, 0, []);\n        count = 1; //count the nodes\n        graph = new Graph(0);\n        startDefined = false;\n        totalGraph = new Graph(0);\n        state = 0;\n      }\n      if (!newProps.algo !== algo)\n        algo = newProps.algo;\n      if (!newProps.localSearch !== localSearch)\n        localSearch = newProps.localSearch;\n      if (!newProps.speed !== speed) \n        speed = newProps.speed;\n      if (speed == 0)\n        speed = 1;\n      //whenever a prop changes we start the loop again (it's only stopped after the path got displayed)\n      p.loop();\n    }\n/*\n    async function runAlgorithm() {\n      for (let i = 0; i < nodes.length; ++i) {\n        adj[i] = nodes[i];\n      }\n      adj[nodes.length] = nodes[0];\n    }\n*/\n\nasync function delay(time) {\n  await waitForIsPlaying();\n  return new Promise(resolve => setTimeout(resolve, time/speed));\n}\n    \n    \n    function displayNodes() {\n      graph.printGraph();\n    }\n\n    /**\n     * Mode has to be \"nearest\" or \"farthest\" and decides\n     * whether we run nearestInsertion or farthestInsertion.\n     * @param {string} mode \n     */\n    async function insertion(mode) {\n      //add the startNode\n      let toAdd = startNode;\n      var included = new Array(graph.V).fill(false);\n      included[toAdd.index] = true;\n\n      //add the first node\n      let node = null;\n      switch(mode) {\n        case \"nearest\":\n          node = findNode(startNode, included, \"closest\");\n          break;\n        case \"farthest\":\n          node = findNode(startNode, included, \"farthest\");\n          break;\n        default:\n\n      }\n      addEdge(startNode, node, euclidDistance(startNode, node));\n      included[node.index] = true;\n      await delay(1000);\n\n      //the second node is inserted slightly different than the remaining ones\n      let arr = null;\n      switch(mode) {\n        case \"nearest\":\n          arr = findClosestOrFarthestToIncluded(included, \"closest\");\n          break;\n        case \"farthest\":\n          arr = findClosestOrFarthestToIncluded(included, \"farthest\");\n          break;\n        default:\n      }\n      let root = arr[0];\n      toAdd = arr[1];\n      let followUp = arr[2];\n      addEdge(root, toAdd, euclidDistance(root, toAdd));\n      addEdge(followUp, toAdd, euclidDistance(followUp, toAdd));\n      included[toAdd.index] = true;\n      await delay(1000);\n\n      //we know how many nodes well have to add, so for loop\n      for (let i = 0; i< graph.V-3; ++i) {\n        await waitForIsPlaying();\n        let arr = null;\n        switch(mode) {\n          case \"nearest\":\n            arr = findClosestOrFarthestToIncluded(included, \"closest\");\n            break;\n          case \"farthest\":\n            arr = findClosestOrFarthestToIncluded(included, \"farthest\");\n            break;\n          default:\n\n        }\n        let root = arr[0];\n        let toAdd = arr[1];\n        let followUp = arr[2];\n        //remove edge between root and followUp\n        removeEdge(root, followUp);\n        //mark the three nodes\n        toAdd.color = \"#ae2a0d\";\n        root.color = \"#0f61e8\";\n        followUp.color = \"#0f61e8\";\n        await delay(1000);\n        //add edges\n        addEdge(root, toAdd, euclidDistance(root, toAdd));\n        await delay(400);\n        addEdge(toAdd, followUp, euclidDistance(toAdd, followUp)); \n        included[toAdd.index] = true;\n        await delay(1000);\n        toAdd.color = \"#fff\";\n        root.color = \"#fff\";\n        followUp.color = \"#fff\";\n      }\n      //algoFinished = true;\n    }\n\n    /**\n     * \n     * @param {boolean[]} included \n     * @param {string} mode \n     * @returns \n     */\n    function findClosestOrFarthestToIncluded(included, mode) {\n      if (mode !== \"closest\" && mode !== \"farthest\")\n        throw('Invalid Input. Mode is: ' + mode + ' but has to be \"closest\" or \"farthest\"');\n\n      let curMinOrMax = Number.MAX_VALUE; //min\n      if (mode == \"farthest\") {\n        curMinOrMax = Number.MIN_VALUE; //max\n      }\n      let root = null;\n      let closestToRoot = null;\n      \n      //iterating through all non - included nodes\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      for (let node of nonIncludedNodes) {\n        //and find closest distance to included \n        let [closestDist, potentialRoot] = findClosestNode(node, getIncludedNodes(included));\n        //if that cloeset dist is greate than curMax, than the node is considered to be farther from included\n        if (mode == \"closest\") {\n          if (closestDist < curMinOrMax) {\n            curMinOrMax = closestDist;\n            root = potentialRoot;\n            closestToRoot = node;\n          }\n        }\n        if (mode == \"farthest\") {\n          if (closestDist > curMinOrMax) {\n            curMinOrMax = closestDist;\n            root = potentialRoot;\n            closestToRoot = node;\n          }\n        }\n      }\n      let rootEdges = graph.AdjList.get(root);\n\n      let firstRootNeighbor = rootEdges[0].other(root);\n      if (rootEdges.length == 1)\n        return [root, closestToRoot, firstRootNeighbor];\n      let secondRootNeighbor =  rootEdges[1].other(root);\n      let newDist1 = euclidDistance(closestToRoot, firstRootNeighbor);\n      let newDist2 = euclidDistance(closestToRoot, secondRootNeighbor);\n      let oldDist1 = euclidDistance(root, firstRootNeighbor);\n      let oldDist2 = euclidDistance(root, secondRootNeighbor);\n\n      if (newDist1 - oldDist1 < newDist2 -oldDist2)\n        return [root, closestToRoot, firstRootNeighbor];\n      return [root, closestToRoot, secondRootNeighbor];\n    }\n\n    /**\n     * \n     * @param {Node} node \n     * @param {Node} nodes \n     * @returns [closestDist, closestNode]\n     */\n    function findClosestNode(node, nodes) {\n      let closestNode = null;\n      let closestDist = Number.MAX_VALUE;\n      for (let v of nodes) {\n        let dist = euclidDistance(node, v);\n        if (dist < closestDist) {\n          closestDist = dist;\n          closestNode = v;\n        }\n      }\n      return [closestDist, closestNode];\n    }\n\n    function removeEdge(node1, node2) {\n      graph.removeEdge(node1, node2);\n    }\n\n    /**\n     * Adds an edge between the node node1 and node2 that have to exist in the graph\n     * @param {Node} node1 \n     * @param {Node} node2\n     */\n    function addEdge (node1, node2, weight) {\n      if (node1.index == node2.index)\n        throw('nodes cannot be the same');\n      graph.addEdge(node1, node2, weight);\n    }\n    \n    /**\n     * This function runs nearestNeigbor on the global graph, starting from\n     * curNode, only visiting non-included nodes (as given by the included array).\n     * The boolean value timeOnlyFromCurNode specifies whether the function returns the\n     * total travel time from startNode to startNode, or only from curNode to startNode.\n     * @param {Node} curNode \n     * @param {boolean[]} included \n     * @param {boolean} timeOnlyFromCurNode \n     * @returns \n     */\n    async function nearestNeighbor(curNode, included, timeOnlyFromCurNode) {\n      if (timeOnlyFromCurNode == undefined)\n        timeOnlyFromCurNode = false;\n      let time = 0;\n      //algoFinished = false;\n      included[curNode.index] = true;\n      //adj.push(curNode);\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      for (let i = 0; i < nonIncludedNodes.length; ++i) {\n        await waitForIsPlaying();\n        let node = findNode(curNode, included, \"closest\");\n        //add an edge between node and curNode\n        let weight = euclidDistance(node, curNode);\n        time += weight;\n        addEdge(node, curNode, weight);\n\n        curNode = node;\n        included[curNode.index] = true;\n\n        //adj.push(curNode);\n        await delay(300);\n      }\n      let weight = euclidDistance(curNode, startNode);\n      time += weight;\n      addEdge(curNode, startNode, weight);\n      await delay(300);\n      if (timeOnlyFromCurNode)\n        return time;\n      return await calculateTravelTime();\n      //algoFinished = true;\n    }\n\n    \n    async function calculateTravelTime(start) {\n      let time = 0;\n      let V = graph.V;\n      let included = new Array(V).fill(false);\n      included[startNode.index] = true;\n      let curNode = startNode;\n      //adding all nodes\n      for (let i = 0; i<graph.V-1; ++i) {\n        let edgesToCurNode = graph.AdjList.get(curNode);\n        for (let edge of edgesToCurNode) {\n          let neighbor = edge.other(curNode);\n          if (!included[neighbor.index]) {\n            time += edge.weight;\n            included[neighbor.index] = true;\n            curNode = neighbor;\n            break;\n          }\n        }\n      }\n      let lastEdge = graph.findEdge(curNode, startNode);\n      time += lastEdge.weight;\n      return time;\n    }\n\n    function getNonIncludedNodes(included) {\n      let out = [];\n      for (let v of graph.getNodes()) {\n        if (!included[v.index])\n          out.push(v);\n      }\n      return out;\n    }\n\n    function getIncludedNodes(included) {\n      let out = [];\n      for (let v of graph.getNodes()) {\n        if (included[v.index])\n          out.push(v);\n      }\n      return out;\n    }\n\n    /**\n     * \n     * @param {Node} curNode \n     * @param {boolean[]} included \n     * @param {double} time \n     * @returns \n     */\n    async function bruteForce(curNode, included, time) {\n      included[curNode.index] = true;\n      let neighbors = getNonIncludedNodes(included);\n      if (neighbors.length == 0) {\n        let weight = euclidDistance(startNode, curNode);\n        addEdge(startNode, curNode, weight);\n        return time + weight;\n      }\n      let minTime = Number.MAX_VALUE;\n      let bestNeighbor = null;\n      for (let neighbor of neighbors) {\n        await waitForIsPlaying();\n        let includedCopy = JSON.parse(JSON.stringify(included));\n        let tempGraph = copyGraph(graph);\n        addEdge(curNode, neighbor, euclidDistance(curNode, neighbor));\n        await delay(300);\n        let finishTime = await bruteForce(neighbor, includedCopy, time + euclidDistance(curNode, neighbor));\n        if (finishTime < minTime) {\n          minTime = finishTime;\n          bestNeighbor = neighbor;\n        }\n        graph = copyGraph(tempGraph);\n        await delay(300);\n      }\n      addEdge(curNode, bestNeighbor, euclidDistance(curNode, bestNeighbor));\n      await delay(400);\n      return bruteForce(bestNeighbor, included, time + euclidDistance(curNode, bestNeighbor));\n    }\n\n    async function nearestNeighborImproved() {\n      let curNode = startNode;\n      let included = new Array(graph.V).fill(false);\n      included[curNode.index] = true;\n      //in every iteration add one node\n      for (let i = 0; i<graph.V -1; ++i) {\n        let min = Number.MAX_VALUE;\n        let potentialNextNode = null;\n        let nonIncludedNodes = getNonIncludedNodes(included);\n        //iterate through all non-included nodes\n        for (let v of nonIncludedNodes) {\n          await waitForIsPlaying();\n\n          let tempGraph = copyGraph(graph);\n          let includedCopy = JSON.parse(JSON.stringify(included));\n          addEdge(curNode, v, euclidDistance(curNode, v));\n          let time = await nearestNeighbor(v, includedCopy, true);\n          time += euclidDistance(curNode, v);\n          delay(300);\n          if (time < min) {\n            potentialNextNode = v;\n            min = time;\n          }      \n          graph = copyGraph(tempGraph);\n        }\n        \n        addEdge(curNode, potentialNextNode, euclidDistance(curNode, potentialNextNode));\n        curNode = potentialNextNode;\n        included[curNode.index] = true;\n        await delay(300);\n      }\n      addEdge(curNode, startNode, euclidDistance(curNode, startNode));\n    }\n\n    function copyGraph(g) {\n      let newGraph = new Graph(0);\n      for (let node of g.getNodes()){\n        newGraph.addVertex(node);\n      }\n      for (let edge of g.getEdges()) {\n        newGraph.addEdgeFromEdge(edge);\n      }\n      return newGraph;\n    }\n\n    /**\n     * This method finds the closest or farthets Node to curNode, \n     * that is not yet inclueded (true in the included array). The \n     * mode decides if we find closest or farthets and has to be\n     * \"closest\" or \"farthsest\".\n     * @param {*} curNode \n     * @param {*} included \n     * @param {string} mode\n     * @returns \n     */\n    function findNode(curNode, included, mode) {\n      if (mode !== \"closest\" && mode !== \"farthest\")\n        throw('Invalid Input. Mode is: ' + mode + ' but has to be \"closest\" or \"farthest\"');\n      let minOrMax = Number.MAX_VALUE; //min\n      if (mode == \"farthest\")\n        minOrMax = Number.MIN_VALUE; //max\n      let curClosestOrFarthest = null;\n      for (let node of graph.getNodes()) {\n        if (included[node.index])\n          continue;\n        let dist = euclidDistance(curNode, node);\n        //let dist = graph.findEdge(curNode, node).weight;\n        if (mode == \"closest\") {\n          if (dist < minOrMax) {\n            minOrMax = dist;\n            curClosestOrFarthest = node;\n          }\n        }\n        else {\n          if (dist > minOrMax) {\n            minOrMax = dist;\n            curClosestOrFarthest = node;\n          }\n        }\n      }\n      return curClosestOrFarthest;\n    }\n\n    /**\n     * \n     * @param {Node} node1 \n     * @param {Node} node2 \n     * @returns \n     */\n    function euclidDistance(node1, node2) {\n      if (!node1 || !node2) {\n        throw('a node for dist does not exists');\n        return\n      }\n      let result = (node1.x - node2.x) * (node1.x - node2.x) + (node1.y - node2.y) * (node1.y - node2.y);\n      return Math.sqrt(result);\n    }\n\n    async function christofides() {\n      await computeMST();\n\n\n      let nodesWithOddDegree = getNodesWithOddDegree(graph);  \n\n      for (var node of nodesWithOddDegree) {\n        node.color = \"#ae2a0d\";\n      }\n      // await delay(15000);\n      await findPerfectMatchingMinWeight(nodesWithOddDegree);\n      for (var node of nodesWithOddDegree) {\n        node.color = \"#fff\";\n      }\n      await findEulerianCycle();\n    \n      // for (node of eulerCycle) {\n      //   console.log(node.index+  \"-\");\n      // }\n      let included = new Array(graph.V).fill(false);\n      var curNode = eulerCycle.pop();\n      var temp = curNode;\n      // we have to go back to this one in the end\n      var first = curNode;\n      included[curNode.index] = true;\n      while (eulerCycle.length > 0) {\n        await waitForIsPlaying();\n        curNode = eulerCycle.pop();\n        if (!included[curNode.index]) {\n          included[curNode.index] = true;\n          addEdge(temp, curNode, euclidDistance(temp, curNode));\n          temp = curNode;\n        }\n      }\n\n      addEdge(temp, first, euclidDistance(curNode, first));\n      // let edge = new Edge(nodesWithOddDegree[0], nodesWithOddDegree[1], euclidDistance(nodesWithOddDegree[0], nodesWithOddDegree[1]));\n      // //console.log('there are nodes with odd degree: ' + nodesWithOddDegree.length);\n      // edge.color = 255;\n      // graph.addEdgeFromEdge(edge);\n\n      for (var node of nodesWithOddDegree) {\n        node.color = \"#fff\";\n      }\n      \n    }\n\n    async function findEulerianCycle() {\n      await waitForIsPlaying();\n      // Find a vertex with odd degree\n      let v = graph.getNodes()[0];\n      for (var node of graph.getNodes()) {\n        if (graph.getNeighbors(node).length % 2== 1) {\n          v = node;\n          break;\n        }\n      }\n      // Print tour starting from oddv\n      await printEulerUtil(v);\n    \n    }\n\n    async function printEulerUtil(v) {\n      await waitForIsPlaying();\n      eulerCycle.push(v);\n\n      //Print Euler tour starting from vertex u\n    \n      // Recur for all the vertices adjacent to\n      // this vertex\n      for (let node of graph.getNeighbors(v)) {\n        await delay(500);\n        // If edge u-v is not removed and it's a\n        // valid next edge\n        if (await isValidNextEdge(v, node)) {\n          graph.removeEdge(v, node);\n          await printEulerUtil(node);\n          break;\n        }\n      }\n    }\n\n\n    // The function to check if edge u-v can be considered\n    // as next edge in Euler Tout\n    async function isValidNextEdge(u, v) {\n      // The edge u-v is valid in one of the following\n      // two cases:\n      // 1) If v is the only adjacent vertex of u\n      let count = graph.getNeighbors(u).length; \n      if (count == 1) \n        return true;\n\n      // 2) If there are multiple adjacents, then u-v\n      //    is not a bridge\n      // Do following steps to check if u-v is a bridge\n      \n      // 2.a) count of vertices reachable from u\n      let visited = new Array(graph.V);\n      visited.fill(false);\n      let count1 = await DFSCount(u, visited);\n      \n      // 2.b) Remove edge (u, v) and after removing\n      // the edge, count vertices reachable from u\n      graph.removeEdge(u, v);\n      visited.fill(false);\n      let count2 = await DFSCount(u, visited);\n\n      // 2.c) Add the edge back to the graph\n      graph.addEdge(u, v, euclidDistance(u, v));\n      // 2.d) If count1 is greater, then edge (u, v)\n      // is a bridge\n      return count1 > count2 ? false : true;\n    }\n\n\n    async function DFSCount(v, visited) {\n      // Mark the current node as visited\n      visited[v.index] = true;\n      let count = 1;\n      \n      // Recur for all vertices adjacent to this vertex\n      \n      for (let node of graph.getNeighbors(v)) {\n        if (!visited[node.index]) \n          count += await DFSCount(node, visited);\n      }\n      return count;\n      let nodesWithOddDegree = getNodesWithOddDegree(graph);  \n      await findPerfectMatchingMinWeight();\n      let edge = new Edge(nodesWithOddDegree[0], nodesWithOddDegree[1], euclidDistance(nodesWithOddDegree[0], nodesWithOddDegree[1]));\n      //console.log('there are nodes with odd degree: ' + nodesWithOddDegree.length);\n      edge.color = 255;\n      graph.addEdgeFromEdge(edge);\n      //min-cost-max matching is harder than I thought...\n      \n    }\n\n    /**\n     * \n     * @param {Node} {even number of nodes} \n     */\n    async function findPerfectMatchingMinWeight(nodes) {\n      var edmondsEdges = [];\n      for (var i = 0; i< nodes.length-1; ++i) {\n        for (var j = i+1; j < nodes.length; ++j) {\n          await waitForIsPlaying();\n          var v = nodes[i];\n          var w = nodes[j];\n          var weight = euclidDistance(v, w);\n          edmondsEdges.push([v.index, w.index, - weight])\n        }\n      }\n      var edmonds = new Edmonds(edmondsEdges);\n\n      var result = edmonds.maxWeightMatching();\n      \n\n      for (var i = 0; i < result.length; ++i) {\n        var indexV = i;\n        var indexW = result[i];\n        var v = graph.getNodes().find(node => node.index === indexV);\n        var w = graph.getNodes().find(node => node.index === indexW);\n        if (indexV < indexW) {\n          addEdge(v, w, euclidDistance(v, w));\n        }\n      }\n    } \n\n\n    function getNodesWithOddDegree(g) {\n      let out = [];\n      for (let node of g.getNodes()) {\n        if (g.getNeighbors(node).length % 2 == 1){\n          out.push(node);\n        }\n      }\n      return out;\n    }\n\n    /**\n     * Computes MST from the global variable totalGraph, that we also initialize here\n     */\n    async function computeMST() {\n      //first fill total graph if not already done\n      fillTotalGraph();\n      let distTo = new Array(graph.V).fill(Number.MAX_VALUE);\n      let included = new Array(graph.V).fill(false);\n      distTo[startNode.index] = 0;\n      included[startNode.index] = true;\n      updateDistances(startNode, distTo);\n      //adding V nodes to MST\n      for (let i = 0; i< graph.V-1; ++i) {\n        await waitForIsPlaying();\n        let node = shortestAddableNodeToIncluded(distTo, included);\n        let [weight, root] = findClosestNode(node, getIncludedNodes(included));\n        addEdge(root, node, weight);\n        included[node.index] = true;\n        updateDistances(node, distTo);\n        graph.printGraph();\n        await delay(300);\n      }\n    }\n\n    function updateDistances(node, distTo) {\n      let neighbors = totalGraph.getNeighbors(node);\n      neighbors.forEach(v => {\n        distTo[v.index] = totalGraph.findEdge(v, node).weight;\n      });\n    }\n\n    /**\n     * This function returns a node and the edge connecting this node\n     * with one that is included such that the weight is minimal.\n     * @param {double[]} distTo \n     * @param {boolean[]} included \n     */\n    function shortestAddableNodeToIncluded(distTo, included) {\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      let closestDist = Number.MAX_VALUE;\n      let closestNode = null;\n      for (let node of nonIncludedNodes) {\n        if (distTo[node.index] < closestDist) {\n          closestDist = distTo[node.index];\n          closestNode = node;\n        }\n      }\n      return closestNode;\n    }\n\n    /**\n     * Creates a total graph (edges between all nodes)\n     */\n    function fillTotalGraph() {\n      if (totalGraph.V == 0) {\n        let nodes = graph.getNodes();\n        let allNodesAdded = false;\n        for (let i = 0; i < nodes.length; ++i) {\n          if (!allNodesAdded)\n            totalGraph.addVertex(nodes[i]);\n          for (let j = i+1; j< nodes.length; ++j) {\n            if (!allNodesAdded) \n              totalGraph.addVertex(nodes[j]);\n            let weight = euclidDistance(nodes[i], nodes[j]);\n            let edge = new Edge(nodes[i], nodes[j], weight);\n            totalGraph.addEdgeFromEdge(edge);\n          }\n          if (!allNodesAdded) \n            allNodesAdded = true;\n        }\n      }\n    }\n\n    function getPath() {\n      let path = [];\n      let visited = new Array(graph.V).fill(false);\n      let cur = startNode;\n      for (var i = 0; i < graph.V; ++i) {\n        path.push(cur);\n        visited[cur.index] = true;\n        // get both neighbors\n        var neighbors = graph.getNeighbors(cur);\n        cur = visited[neighbors[0].index] ? neighbors[1] : neighbors[0]; \n      }\n      path.push(startNode);\n      // for (let node of path) {\n      //   console.log(node.index + \"-\");\n      // }\n      return path;\n    }\n\n    function getLength(path) {\n      let length = 0;\n      let n = path.length;\n      for (let i = 0; i < n-1; ++i) {\n        length += euclidDistance(path[i], path[i+1]);\n      }\n      return length;\n    }\n\n    async function do2Opt(path, i, j) {\n      path[i].color = \"#0f61e8\";\n      path[i+1].color = \"#0f61e8\";\n      path[j].color = \"#0f61e8\";\n      path[j+1].color = \"#0f61e8\";\n\n\n      // find out why not defined sometimes!\n      let oldEdge1 = graph.findEdge(path[i], path[i+1]);\n      let oldEdge2 = graph.findEdge(path[j], path[j+1]);\n      oldEdge1.color = \"#0f61e8\";\n      oldEdge2.color = \"#0f61e8\";\n      await waitForIsPlaying();\n\n      await delay(2000);\n      let newEdge1 = new Edge(path[i], path[j], euclidDistance(path[i], path[j]));\n      newEdge1.color = \"#ae2a0d\";\n      let newEdge2 = new Edge(path[i+1], path[j+1], euclidDistance(path[i+1], path[j+1]));\n      newEdge2.color = \"#ae2a0d\";\n      await waitForIsPlaying();\n\n      await delay(2000);\n      graph.addEdgeFromEdge(newEdge1);\n      graph.addEdgeFromEdge(newEdge2);\n      await waitForIsPlaying();\n\n      await delay(2000);\n      removeEdge(path[i], path[i+1]);\n      removeEdge(path[j], path[j+1]);\n      await waitForIsPlaying();\n\n      await delay(2000);\n      newEdge1.color = \"#000000\";\n      newEdge2.color = \"#000000\";\n\n\n      path[i].color = \"#fff\";\n      path[i+1].color = \"#fff\";\n      path[j].color = \"#fff\";\n      path[j+1].color = \"#fff\";\n\n      path[i].color = \"#fff\";\n      path[j+1].color = \"#fff\";\n      path[j].color = \"#fff\";\n      path[i+1].color = \"#fff\";\n\n\n    }\n\n\n    async function twoOpt() {\n      let foundImprovement = true;\n      let path = getPath();\n      let n = path.length;\n      while (foundImprovement) {\n        foundImprovement = false;\n        for (let i = 0; i < n - 2; i++) {\n          for (let j = i + 1; j < n-1; j++) {\n            await waitForIsPlaying();\n            // first subtract new lengths\n            var gain = -euclidDistance(path[i], path[j]);\n            gain -= euclidDistance(path[i+1], path[j+1]);\n            // then add old lengths\n            gain += euclidDistance(path[i], path[i+1]);\n            gain += euclidDistance(path[j], path[j+1]);\n            // If old length is greater than new length\n            if (gain > 1e-4) {\n              await do2Opt(path, i, j);\n              // curLength -= gain;\n              foundImprovement = true;\n              path = getPath();\n            }\n            gain = 0;\n          }\n        }\n      }\n    }\n\n    async function threeOpt() {\n      let foundImprovement = true;\n      let path = getPath();\n      let n = path.length;\n      while (foundImprovement) {\n        foundImprovement = false;\n        for (let i = 0; i < n - 3; ++i) {\n          for (let j = i + 1; j < n-2; ++j) {\n            for (let k = j+1; k < n-1; ++k) {\n              await waitForIsPlaying();\n\n              // first subtract new lengths\n              var gain = await gainOfBest3OptWiring(path, i, j, k);\n              // If old length is greater than new length\n              if (gain > 1e-4) {\n                // curLength -= gain;\n                foundImprovement = true;\n                path = getPath();\n              }\n              gain = 0;\n            }\n          }\n        }\n      }\n    }\n\n    async function gainOfBest3OptWiring(path, i, j, k) {\n      // (a,b) are one edge, (c,d) and (e,f)\n      let a = path[i];\n      let b = path[i+1];\n      let c  = path[j];\n      let d = path[j+1];\n      let e = path[k];\n      let f = path[k+1];\n\n      // this has good picture for all permutations: http://tsp-basics.blogspot.com/2017/03/3-opt-move.html \n      // a going to b\n      let w0 = [a, b, c, d, e, f]; //that is original wiring\n      let w1 = [a, b, c, e, d, f];\n      // a going to c\n      let w2 = [a, c, b, d, e, f];\n      let w3 = [a, c, b, e, d, f];\n      // a going to d\n      let w4 = [a, d, e, b, c, f];\n      let w5 = [a, d, e, c, b, f];\n      // a going to e\n      let w6 = [a, e, d, b, c, f];\n      let w7 = [a, e, d, c, b, f];\n      let alternativeOptions = [w1, w2, w3, w4, w5, w6, w7];\n      let shortestWiring = w0;\n      let originalLength = length3OptWiring(w0);\n      let shortestLength = originalLength;\n      for (let option of alternativeOptions) {\n        await waitForIsPlaying();\n        let length = length3OptWiring(option);\n        if (shortestLength > length) {\n          shortestLength = length;\n          shortestWiring = option;\n        }\n      }\n\n      if (originalLength > shortestLength) { \n        a.color = \"#0f61e8\";\n        b.color = \"#0f61e8\";\n        c.color = \"#0f61e8\";\n        d.color = \"#0f61e8\";\n        e.color = \"#0f61e8\";\n        f.color = \"#0f61e8\";\n        let oldEdge1 = graph.findEdge(a, b);\n        oldEdge1.color = \"#0f61e8\";\n        let oldEdge2 = graph.findEdge(c, d);\n        oldEdge2.color = \"#0f61e8\";\n        let oldEdge3 = graph.findEdge(e, f);\n        oldEdge3.color = \"#0f61e8\";\n        await delay(2000);\n        //color new edges and add them\n        let newEdge1 =new Edge(shortestWiring[0], shortestWiring[1], euclidDistance(shortestWiring[0], shortestWiring[1]));\n        let newEdge2 = new Edge(shortestWiring[2], shortestWiring[3], euclidDistance(shortestWiring[2], shortestWiring[3]));\n        let newEdge3 = new Edge(shortestWiring[4], shortestWiring[5], euclidDistance(shortestWiring[4], shortestWiring[5]));\n        newEdge1.color = \"#ae2a0d\";\n        newEdge2.color = \"#ae2a0d\";\n        newEdge3.color = \"#ae2a0d\";\n        graph.addEdgeFromEdge(newEdge1);\n        graph.addEdgeFromEdge(newEdge2);\n        graph.addEdgeFromEdge(newEdge3);\n        await delay(2000);\n        removeEdge(a, b);\n        removeEdge(c, d);\n        removeEdge(e, f);\n        await delay(1000);\n        newEdge1.color = \"#000000\";\n        newEdge2.color = \"#000000\";\n        newEdge3.color = \"#000000\";\n        a.color = \"#fff\";\n        b.color = \"#fff\";\n        c.color = \"#fff\";\n        d.color = \"#fff\";\n        e.color = \"#fff\";\n        f.color = \"#fff\";\n\n      }\n      \n      return originalLength - shortestLength;\n\n    }\n\n    function length3OptWiring(wiring) {\n      let length = 0;\n      for (let i = 0; i < 6; i+=2) {\n        length += euclidDistance(wiring[i], wiring[i+1]);\n      }\n      return length;\n    }\n\n    /**\n     * \n     * @param {number of clusters} k \n     */\n    async function clusterNaively(k) {\n      fillTotalGraph();\n      let nodesPerCluster = totalGraph.V/k;\n      let edges = totalGraph.getEdges();\n      edges.sort((e1, e2) => (e1.weight >= e2.weight) ? 1 : -1);\n      //add small edges to cluster, if it doesn't exceed its size (size is naively n/k)\n      for (let e of edges) {\n        await delay(1000);    \n        let v1 = e.either();\n        let v2 = e.other(v1);  \n        //case 1, both nodes not included\n        if (!v1.root && !v2.root) {\n          v2.root = v1;\n          v1.isRoot = true;\n          v1.children = 1;\n          addEdge(v1, v2, e.weight);\n          continue;\n        }\n        if (v1.isRoot && !v2.root || v1.root && !v2.root) {\n            if (v1.isRoot) {\n              if (v1.children + 1 < nodesPerCluster) {\n                v2.root = v1;\n                v1.children++;\n              }\n            }\n            else {\n              v2.root = v1.root; \n              v1.root.children++;\n            }\n            addEdge(v1, v2, e.weight);\n            continue;\n          }\n        if (v2.isRoot && !v1.root || v2.root && !v1.root) {\n          if (v2.root.children + 1 < nodesPerCluster) {\n            v1.root = v2.root;\n            v2.root.children++;\n            addEdge(v1, v2, e.weight);\n          }\n          continue;\n        }\n        if (v1.root && v2.root) {\n          if (v1.root.children + 1 + v2.root + 1 < nodesPerCluster) {\n            let temp = v1.root.children + 1;\n            v1.root = v2.root;\n            v2.root.children += temp;\n            addEdge(v1, v2, e.weight);\n          }\n          continue;\n        }\n      }\n\n    }\n\n    \n\n}\n\nexport default sketch;","/home/thomas/Dev/RouteOptimizationVisualizer/src/Node.js",[],[],"/home/thomas/Dev/RouteOptimizationVisualizer/src/Graph.js",["81","82","83","84","85","86","87","88","89","90"],[],"import {Edge} from './Edge.js'; \n// import {Node} from './Node.js'; \n\nexport class Graph {\n    constructor(V) {\n        this.V = V;\n        this.E = 0;\n        this.AdjList = new Map();\n    }\n\n    /**\n     * \n     * @param {Node} v \n     */\n    addVertex(v) {\n        this.AdjList.set(v, []);\n        this.V++;\n    }\n\n    /**\n     * \n     * @param {Node} v \n     * @param {Node} w \n     * @param {double} weight\n     */\n    addEdge(v, w, weight) {\n        if (weight == undefined)\n            throw 'weight is undefined';\n        let e = new Edge(v, w, weight); \n        this.AdjList.get(v).push(e);\n        this.AdjList.get(w).push(e);\n        this.E++;\n    }\n\n    addEdgeFromEdge(edge) {\n        let v = edge.either();\n        let w = edge.other(v);\n        this.AdjList.get(v).push(edge);\n        this.AdjList.get(w).push(edge);\n        this.E++;\n    }\n\n    /**\n     * @returns {Edge[]} edges\n     */\n    getEdges() {\n        let edgeList = [];\n        let nodes = this.AdjList.keys();\n        // iterate over the vertices\n        for (let node of nodes) {\n            //get all edges that contain that vertex\n            let edges = this.AdjList.get(node);\n            //iterate over all these edges\n            for (let e of edges) {\n                if (node.index < e.other(node).index)\n                    edgeList.push(e);\n            }\n        }\n        return edgeList;\n    }\n\n    removeAllEdges() {\n        let newMap = new Map();\n        for (let node of this.AdjList) {\n            newMap.set(node, []);\n        }\n        this.AdjList = newMap;\n        this.E = 0;\n    }\n\n    removeEdge(v1, v2) {\n        let e = this.findEdge(v1, v2);\n        this.AdjList.get(v1).splice(this.AdjList.get(v1).indexOf(e), 1);\n        this.AdjList.get(v2).splice(this.AdjList.get(v2).indexOf(e), 1);\n    }\n\n    /**\n     * \n     * @param {Node} v1 \n     * @param {Node} v2 \n     * @returns \n     */\n    findEdge(v1, v2) {\n        let edges = this.getEdges();\n        for (let e of edges) {\n            let node1 = e.either();\n            let node2 = e.other(node1);\n            if (node1.index == v1.index && node2.index == v2.index || node2.index == v1.index && node1.index == v2.index)\n                return e; \n        }\n    }\n\n    getNeighbors(node) {\n        let out = [];\n        for (let edge of this.AdjList.get(node)) {\n            out.push(edge.other(node));\n        }\n        return out;\n    }\n\n    /**\n     * \n     * @returns {Node[]} nodes \n     */\n    getNodes() {\n        let nodes = [];\n        for (let node of this.AdjList.keys()) {\n            nodes.push(node);\n        }\n        return nodes;\n    }\n\n    printGraph() {\n        // get all the vertices\n        var get_keys = this.AdjList.keys();\n \n        // iterate over the vertices\n        for (let node of get_keys) {\n            let str = node.index  + \": \";\n            //get all edges that contain that vertex\n            let edges = this.AdjList.get(node);\n            //iterate over all these edges\n            for (let e of edges) {\n                str += e.other(node).index + \" (w: \" + e.weight + \")  \";\n            }\n            console.log(str);\n        }\n    }\n}\n\n// // Using the above implemented graph class\n// var g = new Graph(6);\n// var vertices = [ new Node(1,1,1), new Node(2,2,2), new Node(3,3,3) ];\n \n// // adding vertices\n// for (var i = 0; i < vertices.length; i++) {\n//     g.addVertex(vertices[i]);\n// }\n \n// // adding edges\n// g.addEdge(vertices[0], vertices[1], 2);\n// g.addEdge(vertices[0], vertices[2], 3);\n \n// // prints all vertex and\n// // its adjacency list\n// g.printGraph();\n\n","/home/thomas/Dev/RouteOptimizationVisualizer/src/Edge.js",["91"],[],"// import {Node} from './Node.js'; \n\n\nexport class Edge {\n    /**\n     * \n     * @param {Node} v \n     * @param {Node} w \n     * @param {double} weight \n     */\n    constructor(v, w, weight) {\n      this.v = v;\n      this.w = w;\n      this.weight = weight;\n    }\n\n    either() {\n        return this.v;\n    }\n\n    other(node) {\n        if (node.index == this.v.index)\n            return this.w;\n        return this.v;\n    }\n\n    toString() {\n        return this.v.index + \"-\" + this.w.index + \" (\" + this.weight + \")\";\n    }\n  }","/home/thomas/Dev/RouteOptimizationVisualizer/src/Blossom.js",["92","93","94"],[],"export class Edmonds {\n\n    constructor(edges) {\n        this.edges = edges;\n        this.nEdge = edges.length;\n        this.nVertexInit();\n        this.maxWeightInit();\n        this.endpointInit();\n        this.neighbendInit();\n        this.mate = this.filledArray(this.nVertex, -1);\n        this.label = this.filledArray(2 * this.nVertex, 0); //remove?\n        this.labelEnd = this.filledArray(2 * this.nVertex, -1);\n        this.inBlossomInit();\n        this.blossomParent = this.filledArray(2 * this.nVertex, -1);\n        this.blossomChilds = this.initArrArr(2 * this.nVertex);\n        this.blossomBaseInit();\n        this.blossomEndPs = this.initArrArr(2 * this.nVertex);\n        this.bestEdge = this.filledArray(2 * this.nVertex, -1); //remove?\n        this.blossomBestEdges = this.initArrArr(2 * this.nVertex); //remove?\n        this.unusedBlossomsInit();\n        this.dualVarInit();\n        this.allowEdge = this.filledArray(this.nEdge, false); //remove?\n        this.queue = []; //remove?\n      }\n\n    \n     maxWeightMatching = function () {\n        for (var t = 0; t < this.nVertex; t++) {\n        //console.log('DEBUG: STAGE ' + t);\n        this.label = this.filledArray(2 * this.nVertex, 0);\n        this.bestEdge = this.filledArray(2 * this.nVertex, -1);\n        this.blossomBestEdges = this.initArrArr(2 * this.nVertex);\n        this.allowEdge = this.filledArray(this.nEdge, false);\n        this.queue = [];\n        for (var v = 0; v < this.nVertex; v++) {\n            if (this.mate[v] === -1 && this.label[this.inBlossom[v]] === 0) {\n            this.assignLabel(v, 1, -1);\n            }\n        }\n        var augmented = false;\n        while (true) {\n            //console.log('DEBUG: SUBSTAGE');\n            while (this.queue.length > 0 && !augmented) {\n            v = this.queue.pop();\n            //console.log('DEBUG: POP ', 'v=' + v);\n            //console.assert(this.label[this.inBlossom[v]] == 1);\n            for (var ii = 0; ii < this.neighbend[v].length; ii++) {\n                var p = this.neighbend[v][ii];\n                var k = ~~(p / 2);\n                var w = this.endpoint[p];\n                if (this.inBlossom[v] === this.inBlossom[w]) continue;\n                if (!this.allowEdge[k]) {\n                var kSlack = this.slack(k);\n                if (kSlack <= 0) {\n                    this.allowEdge[k] = true;\n                }\n                }\n                if (this.allowEdge[k]) {\n                if (this.label[this.inBlossom[w]] === 0) {\n                    this.assignLabel(w, 2, p ^ 1);\n                } else if (this.label[this.inBlossom[w]] === 1) {\n                    var base = this.scanBlossom(v, w);\n                    if (base >= 0) {\n                    this.addBlossom(base, k);\n                    } else {\n                    this.augmentMatching(k);\n                    augmented = true;\n                    break;\n                    }\n                } else if (this.label[w] === 0) {\n                    //console.assert(this.label[this.inBlossom[w]] === 2);\n                    this.label[w] = 2;\n                    this.labelEnd[w] = p ^ 1;\n                }\n                } else if (this.label[this.inBlossom[w]] === 1) {\n                var b = this.inBlossom[v];\n                if (this.bestEdge[b] === -1 || kSlack < this.slack(this.bestEdge[b])) {\n                    this.bestEdge[b] = k;\n                }\n                } else if (this.label[w] === 0) {\n                if (this.bestEdge[w] === -1 || kSlack < this.slack(this.bestEdge[w])) {\n                    this.bestEdge[w] = k;\n                }\n                }\n            }\n            }\n            if (augmented) break;\n            var deltaType = -1;\n            var delta = [];\n            var deltaEdge = [];\n            var deltaBlossom = [];\n            for (v = 0; v < this.nVertex; v++) {\n            if (this.label[this.inBlossom[v]] === 0 && this.bestEdge[v] !== -1) {\n                var d = this.slack(this.bestEdge[v]);\n                if (deltaType === -1 || d < delta) {\n                delta = d;\n                deltaType = 2;\n                deltaEdge = this.bestEdge[v];\n                }\n            }\n            }\n            for (b = 0; b < 2 * this.nVertex; b++) {\n            if (this.blossomParent[b] === -1 && this.label[b] === 1 && this.bestEdge[b] !== -1) {\n                kSlack = this.slack(this.bestEdge[b]);\n                ////console.assert((kSlack % 2) == 0);\n                d = kSlack / 2;\n                if (deltaType === -1 || d < delta) {\n                delta = d;\n                deltaType = 3;\n                deltaEdge = this.bestEdge[b];\n                }\n            }\n            }\n            for (b = this.nVertex; b < this.nVertex * 2; b++) {\n            if (this.blossomBase[b] >= 0 && this.blossomParent[b] === -1 && this.label[b] === 2 && (deltaType === -1 || this.dualVar[b] < delta)) {\n                delta = this.dualVar[b];\n                deltaType = 4;\n                deltaBlossom = b;\n            }\n            }\n            if (deltaType === -1) {\n            deltaType = 1;\n            delta = Math.max(0, this.getMin(this.dualVar, 0, this.nVertex - 1));\n            }\n            for (v = 0; v < this.nVertex; v++) {\n            var curLabel = this.label[this.inBlossom[v]];\n            if (curLabel === 1) {\n                this.dualVar[v] -= delta;\n            } else if (curLabel === 2) {\n                this.dualVar[v] += delta;\n            }\n            }\n            for (b = this.nVertex; b < this.nVertex * 2; b++) {\n            if (this.blossomBase[b] >= 0 && this.blossomParent[b] === -1) {\n                if (this.label[b] === 1) {\n                this.dualVar[b] += delta;\n                } else if (this.label[b] === 2) {\n                this.dualVar[b] -= delta;\n                }\n            }\n            }\n            //console.log('DEBUG: deltaType', deltaType, ' delta: ', delta);\n            if (deltaType === 1) {\n            break;\n            } else if (deltaType === 2) {\n            this.allowEdge[deltaEdge] = true;\n            var i = this.edges[deltaEdge][0];\n            var j = this.edges[deltaEdge][1];\n            var wt = this.edges[deltaEdge][2];\n            if (this.label[this.inBlossom[i]] === 0) {\n                i = i ^ j;\n                j = j ^ i;\n                i = i ^ j;\n            }\n            //console.assert(this.label[this.inBlossom[i]] == 1);\n            this.queue.push(i);\n            } else if (deltaType === 3) {\n            this.allowEdge[deltaEdge] = true;\n            i = this.edges[deltaEdge][0];\n            j = this.edges[deltaEdge][1];\n            wt = this.edges[deltaEdge][2];\n            //console.assert(this.label[this.inBlossom[i]] == 1);\n            this.queue.push(i);\n            } else if (deltaType === 4) {\n            this.expandBlossom(deltaBlossom, false);\n            }\n        }\n        if (!augmented) break;\n        for (b = this.nVertex; b < this.nVertex * 2; b++) {\n            if (this.blossomParent[b] === -1 && this.blossomBase[b] >= 0 && this.label[b] === 1 && this.dualVar[b] === 0) {\n            this.expandBlossom(b, true);\n            }\n        }\n        }\n        for (v = 0; v < this.nVertex; v++) {\n        if (this.mate[v] >= 0) {\n            this.mate[v] = this.endpoint[this.mate[v]];\n        }\n        }\n        for (v = 0; v < this.nVertex; v++) {\n        //console.assert(this.mate[v] == -1 || this.mate[this.mate[v]] == v);\n        }\n        return this.mate;\n    };\n    \n    slack = function (k) {\n        var i = this.edges[k][0];\n        var j = this.edges[k][1];\n        var wt = this.edges[k][2];\n        return this.dualVar[i] + this.dualVar[j] - 2 * wt;\n    };\n    \n    blossomLeaves = function (b) {\n        if (b < this.nVertex) {\n        return [b];\n        }\n        var leaves = [];\n        var childList = this.blossomChilds[b];\n        for (var t = 0; t < childList.length; t++) {\n        if (childList[t] <= this.nVertex) {\n            leaves.push(childList[t]);\n        } else {\n            var leafList = this.blossomLeaves(childList[t]);\n            for (var v = 0; v < leafList.length; v++) {\n            leaves.push(leafList[v]);\n            }\n        }\n        }\n        return leaves;\n    };\n    \n    assignLabel = function (w, t, p) {\n        //console.log('DEBUG: assignLabel(' + w + ',' + t + ',' + p + '}');\n        var b = this.inBlossom[w];\n        //console.assert(this.label[w] === 0 && this.label[b] === 0);\n        this.label[w] = this.label[b] = t;\n        this.labelEnd[w] = this.labelEnd[b] = p;\n        this.bestEdge[w] = this.bestEdge[b] = -1;\n        if (t === 1) {\n        this.queue.push.apply(this.queue, this.blossomLeaves(b));\n        //console.log('DEBUG: PUSH ' + this.blossomLeaves(b).toString());\n        } else if (t === 2) {\n        var base = this.blossomBase[b];\n        //console.assert(this.mate[base] >= 0);\n        this.assignLabel(this.endpoint[this.mate[base]], 1, this.mate[base] ^ 1);\n        }\n    };\n    \n    scanBlossom = function (v, w) {\n        //console.log('DEBUG: scanBlossom(' + v + ',' + w + ')');\n        var path = [];\n        var base = -1;\n        while (v !== -1 || w !== -1) {\n        var b = this.inBlossom[v];\n        if ((this.label[b] & 4)) {\n            base = this.blossomBase[b];\n            break;\n        }\n        //console.assert(this.label[b] === 1);\n        path.push(b);\n        this.label[b] = 5;\n        //console.assert(this.labelEnd[b] === this.mate[this.blossomBase[b]]);\n        if (this.labelEnd[b] === -1) {\n            v = -1;\n        } else {\n            v = this.endpoint[this.labelEnd[b]];\n            b = this.inBlossom[v];\n            //console.assert(this.label[b] === 2);\n            //console.assert(this.labelEnd[b] >= 0);\n            v = this.endpoint[this.labelEnd[b]];\n        }\n        if (w !== -1) {\n            v = v ^ w;\n            w = w ^ v;\n            v = v ^ w;\n        }\n        }\n        for (var ii = 0; ii < path.length; ii++) {\n        b = path[ii];\n        this.label[b] = 1;\n        }\n        return base;\n    };\n    \n    addBlossom = function (base, k) {\n        var v = this.edges[k][0];\n        var w = this.edges[k][1];\n        var wt = this.edges[k][2];\n        var bb = this.inBlossom[base];\n        var bv = this.inBlossom[v];\n        var bw = this.inBlossom[w];\n        var b = this.unusedBlossoms.pop();\n        //console.log('DEBUG: addBlossom(' + base + ',' + k + ')' + ' (v=' + v + ' w=' + w + ')' + ' -> ' + b);\n        this.blossomBase[b] = base;\n        this.blossomParent[b] = -1;\n        this.blossomParent[bb] = b;\n        var path = this.blossomChilds[b] = [];\n        var endPs = this.blossomEndPs[b] = [];\n        while (bv !== bb) {\n        this.blossomParent[bv] = b;\n        path.push(bv);\n        endPs.push(this.labelEnd[bv]);\n        //console.assert(this.label[bv] === 2 || (this.label[bv] === 1 && this.labelEnd[bv] === this.mate[this.blossomBase[bv]]));\n        //console.assert(this.labelEnd[bv] >= 0);\n        v = this.endpoint[this.labelEnd[bv]];\n        bv = this.inBlossom[v];\n        }\n        path.push(bb);\n        path.reverse();\n        endPs.reverse();\n        endPs.push((2 * k));\n        while (bw !== bb) {\n        this.blossomParent[bw] = b;\n        path.push(bw);\n        endPs.push(this.labelEnd[bw] ^ 1);\n        //console.assert(this.label[bw] === 2 || (this.label[bw] === 1 && this.labelEnd[bw] === this.mate[this.blossomBase[bw]]));\n        //console.assert(this.labelEnd[bw] >= 0);\n        w = this.endpoint[this.labelEnd[bw]];\n        bw = this.inBlossom[w];\n        }\n        //console.assert(this.label[bb] === 1);\n        this.label[b] = 1;\n        this.labelEnd[b] = this.labelEnd[bb];\n        this.dualVar[b] = 0;\n        var leaves = this.blossomLeaves(b);\n        for (var ii = 0; ii < leaves.length; ii++) {\n        v = leaves[ii];\n        if (this.label[this.inBlossom[v]] === 2) {\n            this.queue.push(v);\n        }\n        this.inBlossom[v] = b;\n        }\n        var bestEdgeTo = this.filledArray(2 * this.nVertex, -1);\n        for (ii = 0; ii < path.length; ii++) {\n        bv = path[ii];\n        if (this.blossomBestEdges[bv].length === 0) {\n            var nbLists = [];\n            leaves = this.blossomLeaves(bv);\n            for (var x = 0; x < leaves.length; x++) {\n            v = leaves[x];\n            nbLists[x] = [];\n            for (var y = 0; y < this.neighbend[v].length; y++) {\n                var p = this.neighbend[v][y];\n                nbLists[x].push(~~(p / 2));\n            }\n            }\n        } else {\n            nbLists = [this.blossomBestEdges[bv]];\n        }\n        //console.log('DEBUG: nbLists ' + nbLists.toString());\n        for (x = 0; x < nbLists.length; x++) {\n            var nbList = nbLists[x];\n            for (y = 0; y < nbList.length; y++) {\n            k = nbList[y];\n            var i = this.edges[k][0];\n            var j = this.edges[k][1];\n            wt = this.edges[k][2];\n            if (this.inBlossom[j] === b) {\n                i = i ^ j;\n                j = j ^ i;\n                i = i ^ j;\n            }\n            var bj = this.inBlossom[j];\n            if (bj !== b && this.label[bj] === 1 && (bestEdgeTo[bj] === -1 || this.slack(k) < this.slack(bestEdgeTo[bj]))) {\n                bestEdgeTo[bj] = k;\n            }\n            }\n        }\n        this.blossomBestEdges[bv] = [];\n        this.bestEdge[bv] = -1;\n        }\n        var be = [];\n        for (ii = 0; ii < bestEdgeTo.length; ii++) {\n        k = bestEdgeTo[ii];\n        if (k !== -1) {\n            be.push(k);\n        }\n        }\n        this.blossomBestEdges[b] = be;\n        //console.log('DEBUG: blossomBestEdges[' + b + ']= ' + this.blossomBestEdges[b].toString());\n        this.bestEdge[b] = -1;\n        for (ii = 0; ii < this.blossomBestEdges[b].length; ii++) {\n        k = this.blossomBestEdges[b][ii];\n        if (this.bestEdge[b] === -1 || this.slack(k) < this.slack(this.bestEdge[b])) {\n            this.bestEdge[b] = k;\n        }\n        }\n        //console.log('DEBUG: blossomChilds[' + b + ']= ' + this.blossomChilds[b].toString());\n    };\n    \n    expandBlossom = function (b, endStage) {\n        //console.log('DEBUG: expandBlossom(' + b + ',' + endStage + ') ' + this.blossomChilds[b].toString());\n        for (var ii = 0; ii < this.blossomChilds[b].length; ii++) {\n        var s = this.blossomChilds[b][ii];\n        this.blossomParent[s] = -1;\n        if (s < this.nVertex) {\n            this.inBlossom[s] = s;\n        } else if (endStage && this.dualVar[s] === 0) {\n            this.expandBlossom(s, endStage);\n        } else {\n            var leaves = this.blossomLeaves(s);\n            for (var jj = 0; jj < leaves.length; jj++) {\n            var v = leaves[jj];\n            this.inBlossom[v] = s;\n            }\n        }\n        }\n        if (!endStage && this.label[b] === 2) {\n        //console.assert(this.labelEnd[b] >= 0);\n        var entryChild = this.inBlossom[this.endpoint[this.labelEnd[b] ^ 1]];\n        var j = this.blossomChilds[b].indexOf(entryChild);\n        if ((j & 1)) {\n            j -= this.blossomChilds[b].length;\n            var jStep = 1;\n            var endpTrick = 0;\n        } else {\n            jStep = -1;\n            endpTrick = 1;\n        }\n        var p = this.labelEnd[b];\n        while (j !== 0) {\n            this.label[this.endpoint[p ^ 1]] = 0;\n            this.label[this.endpoint[this.indexW(this.blossomEndPs[b], j - endpTrick) ^ endpTrick ^ 1]] = 0;\n            this.assignLabel(this.endpoint[p ^ 1], 2, p);\n            this.allowEdge[~~(this.indexW(this.blossomEndPs[b], j - endpTrick) / 2)] = true;\n            j += jStep;\n            p = this.indexW(this.blossomEndPs[b], j - endpTrick) ^ endpTrick;\n            this.allowEdge[~~(p / 2)] = true;\n            j += jStep;\n        }\n        var bv = this.indexW(this.blossomChilds[b], j);\n        this.label[this.endpoint[p ^ 1]] = this.label[bv] = 2;\n    \n        this.labelEnd[this.endpoint[p ^ 1]] = this.labelEnd[bv] = p;\n        this.bestEdge[bv] = -1;\n        j += jStep;\n        while (this.indexW(this.blossomChilds[b], j) !== entryChild) {\n            bv = this.indexW(this.blossomChilds[b], j);\n            if (this.label[bv] === 1) {\n            j += jStep;\n            continue;\n            }\n            leaves = this.blossomLeaves(bv);\n            for (ii = 0; ii < leaves.length; ii++) {\n            v = leaves[ii];\n            if (this.label[v] !== 0) break;\n            }\n            if (this.label[v] !== 0) {\n            //console.assert(this.label[v] === 2);\n            //console.assert(this.inBlossom[v] === bv);\n            this.label[v] = 0;\n            this.label[this.endpoint[this.mate[this.blossomBase[bv]]]] = 0;\n            this.assignLabel(v, 2, this.labelEnd[v]);\n            }\n            j += jStep;\n        }\n        }\n        this.label[b] = this.labelEnd[b] = -1;\n        this.blossomEndPs[b] = this.blossomChilds[b] = [];\n        this.blossomBase[b] = -1;\n        this.blossomBestEdges[b] = [];\n        this.bestEdge[b] = -1;\n        this.unusedBlossoms.push(b);\n    };\n    \n    augmentBlossom = function (b, v) {\n        //console.log('DEBUG: augmentBlossom(' + b + ',' + v + ')');\n        var i, j;\n        var t = v;\n        while (this.blossomParent[t] !== b) {\n        t = this.blossomParent[t];\n        }\n        if (t > this.nVertex) {\n        this.augmentBlossom(t, v);\n        }\n        i = j = this.blossomChilds[b].indexOf(t);\n        if ((i & 1)) {\n        j -= this.blossomChilds[b].length;\n        var jStep = 1;\n        var endpTrick = 0;\n        } else {\n        jStep = -1;\n        endpTrick = 1;\n        }\n        while (j !== 0) {\n        j += jStep;\n        t = this.indexW(this.blossomChilds[b], j);\n        var p = this.indexW(this.blossomEndPs[b], j - endpTrick) ^ endpTrick;\n        if (t >= this.nVertex) {\n            this.augmentBlossom(t, this.endpoint[p]);\n        }\n        j += jStep;\n        t = this.indexW(this.blossomChilds[b], j);\n        if (t >= this.nVertex) {\n            this.augmentBlossom(t, this.endpoint[p ^ 1]);\n        }\n        this.mate[this.endpoint[p]] = p ^ 1;\n        this.mate[this.endpoint[p ^ 1]] = p;\n        }\n        //console.log('DEBUG: PAIR ' + this.endpoint[p] + ' ' + this.endpoint[p^1] + '(k=' + ~~(p/2) + ')');\n        this.blossomChilds[b] = this.blossomChilds[b].slice(i).concat(this.blossomChilds[b].slice(0, i));\n        this.blossomEndPs[b] = this.blossomEndPs[b].slice(i).concat(this.blossomEndPs[b].slice(0, i));\n        this.blossomBase[b] = this.blossomBase[this.blossomChilds[b][0]];\n        //console.assert(this.blossomBase[b] === v);\n    };\n    \n    augmentMatching = function (k) {\n        var v = this.edges[k][0];\n        var w = this.edges[k][1];\n        //console.log('DEBUG: augmentMatching(' + k + ')' + ' (v=' + v + ' ' + 'w=' + w);\n        //console.log('DEBUG: PAIR ' + v + ' ' + w + '(k=' + k + ')');\n        for (var ii = 0; ii < 2; ii++) {\n        if (ii === 0) {\n            var s = v;\n            var p = 2 * k + 1;\n        } else {\n            s = w;\n            p = 2 * k;\n        }\n        while (true) {\n            var bs = this.inBlossom[s];\n            //console.assert(this.label[bs] === 1);\n            //console.assert(this.labelEnd[bs] === this.mate[this.blossomBase[bs]]);\n            if (bs >= this.nVertex) {\n            this.augmentBlossom(bs, s);\n            }\n            this.mate[s] = p;\n            if (this.labelEnd[bs] === -1) break;\n            var t = this.endpoint[this.labelEnd[bs]];\n            var bt = this.inBlossom[t];\n            //console.assert(this.label[bt] === 2);\n            //console.assert(this.labelEnd[bt] >= 0);\n            s = this.endpoint[this.labelEnd[bt]];\n            var j = this.endpoint[this.labelEnd[bt] ^ 1];\n            //console.assert(this.blossomBase[bt] === t);\n            if (bt >= this.nVertex) {\n            this.augmentBlossom(bt, j);\n            }\n            this.mate[j] = this.labelEnd[bt];\n            p = this.labelEnd[bt] ^ 1;\n            //console.log('DEBUG: PAIR ' + s + ' ' + t + '(k=' + ~~(p/2) + ')');\n    \n    \n        }\n        }\n    };\n    \n    \n    blossomBaseInit () {\n        var base = [];\n        for (var i = 0; i < this.nVertex; i++) {\n        base[i] = i;\n        }\n        var negs = this.filledArray(this.nVertex, -1);\n        this.blossomBase = base.concat(negs);\n    };\n    dualVarInit () {\n        var mw = this.filledArray(this.nVertex, this.maxWeight);\n        var zeros = this.filledArray(this.nVertex, 0);\n        this.dualVar = mw.concat(zeros);\n    };\n    unusedBlossomsInit  () {\n        var i, unusedBlossoms = [];\n        for (i = this.nVertex; i < 2 * this.nVertex; i++) {\n        unusedBlossoms.push(i);\n        }\n        this.unusedBlossoms = unusedBlossoms;\n    };\n    inBlossomInit () {\n        var i, inBlossom = [];\n        for (i = 0; i < this.nVertex; i++) {\n        inBlossom[i] = i;\n        }\n        this.inBlossom = inBlossom;\n    };\n    neighbendInit() {\n        var k, i, j;\n        var neighbend = this.initArrArr(this.nVertex);\n        for (k = 0; k < this.nEdge; k++) {\n        i = this.edges[k][0];\n        j = this.edges[k][1];\n        neighbend[i].push(2 * k + 1);\n        neighbend[j].push(2 * k);\n        }\n        this.neighbend = neighbend;\n    };\n    endpointInit() {\n        var p;\n        var endpoint = [];\n        for (p = 0; p < 2 * this.nEdge; p++) {\n        endpoint[p] = this.edges[~~(p / 2)][p % 2];\n        }\n        this.endpoint = endpoint;\n    };\n    nVertexInit () {\n        var nVertex = 0;\n        for (var k = 0; k < this.nEdge; k++) {\n        var i = this.edges[k][0];\n        var j = this.edges[k][1];\n        if (i >= nVertex) nVertex = i + 1;\n        if (j >= nVertex) nVertex = j + 1;\n        }\n        this.nVertex = nVertex;\n    };\n    maxWeightInit() {\n        var maxWeight = 0;\n        for (var k = 0; k < this.nEdge; k++) {\n        var weight = this.edges[k][2];\n        if (weight > maxWeight) {\n            maxWeight = weight;\n        }\n        }\n        this.maxWeight = maxWeight;\n    };\n    \n    //HELPERS//\n    filledArray(len, fill) {\n        var i, newArray = [];\n        for (i = 0; i < len; i++) {\n        newArray[i] = fill;\n        }\n        return newArray;\n    }\n    \n    initArrArr(len) {\n        var arr = [];\n        for (var i = 0; i < len; i++) {\n        arr[i] = [];\n        }\n        return arr;\n    }\n    \n    getMin(arr, start, end) {\n        var min = Infinity;\n        for (var i = start; i <= end; i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n        }\n        }\n        return min;\n    }\n    \n    indexW(arr, idx) {\n        //if idx is negative, go from the back\n        return idx < 0 ? arr[arr.length + idx] : arr[idx];\n    }\n}\n\n  var data = [\n    [0, 1, -6],\n    [0, 2, -10],\n    [1, 2, -5],\n    [2, 3, -7],\n    [1, 3, -2]\n  ];\n\n// var edmonds = new Edmonds(data);\n\n// var result = edmonds.maxWeightMatching();\n\n// console.log(result)",{"ruleId":"95","severity":1,"message":"96","line":64,"column":15,"nodeType":"97","messageId":"98","endLine":64,"endColumn":17},{"ruleId":"95","severity":1,"message":"96","line":103,"column":15,"nodeType":"97","messageId":"98","endLine":103,"endColumn":17},{"ruleId":"95","severity":1,"message":"96","line":239,"column":17,"nodeType":"97","messageId":"98","endLine":239,"endColumn":19},{"ruleId":"99","severity":1,"message":"100","line":259,"column":14,"nodeType":"101","messageId":"102","endLine":259,"endColumn":26},{"ruleId":"103","severity":1,"message":"104","line":354,"column":9,"nodeType":"105","messageId":"106","endLine":354,"endColumn":93},{"ruleId":"95","severity":1,"message":"96","line":357,"column":16,"nodeType":"97","messageId":"98","endLine":357,"endColumn":18},{"ruleId":"95","severity":1,"message":"96","line":369,"column":18,"nodeType":"97","messageId":"98","endLine":369,"endColumn":20},{"ruleId":"95","severity":1,"message":"96","line":376,"column":18,"nodeType":"97","messageId":"98","endLine":376,"endColumn":20},{"ruleId":"95","severity":1,"message":"96","line":387,"column":28,"nodeType":"97","messageId":"98","endLine":387,"endColumn":30},{"ruleId":"95","severity":1,"message":"96","line":429,"column":23,"nodeType":"97","messageId":"98","endLine":429,"endColumn":25},{"ruleId":"103","severity":1,"message":"104","line":430,"column":9,"nodeType":"105","messageId":"106","endLine":430,"endColumn":43},{"ruleId":"95","severity":1,"message":"96","line":445,"column":31,"nodeType":"97","messageId":"98","endLine":445,"endColumn":33},{"ruleId":"95","severity":1,"message":"96","line":529,"column":28,"nodeType":"97","messageId":"98","endLine":529,"endColumn":30},{"ruleId":"103","severity":1,"message":"104","line":612,"column":9,"nodeType":"105","messageId":"106","endLine":612,"endColumn":93},{"ruleId":"95","severity":1,"message":"96","line":614,"column":16,"nodeType":"97","messageId":"98","endLine":614,"endColumn":18},{"ruleId":"95","severity":1,"message":"96","line":622,"column":18,"nodeType":"97","messageId":"98","endLine":622,"endColumn":20},{"ruleId":"103","severity":1,"message":"104","line":646,"column":9,"nodeType":"105","messageId":"106","endLine":646,"endColumn":50},{"ruleId":"107","severity":1,"message":"108","line":647,"column":9,"nodeType":"109","messageId":"110","endLine":647,"endColumn":15},{"ruleId":"111","severity":1,"message":"112","line":664,"column":16,"nodeType":"101","messageId":"113","endLine":664,"endColumn":20},{"ruleId":"111","severity":1,"message":"112","line":694,"column":16,"nodeType":"101","messageId":"113","endLine":694,"endColumn":20},{"ruleId":"95","severity":1,"message":"96","line":705,"column":48,"nodeType":"97","messageId":"98","endLine":705,"endColumn":50},{"ruleId":"95","severity":1,"message":"96","line":743,"column":17,"nodeType":"97","messageId":"98","endLine":743,"endColumn":19},{"ruleId":"107","severity":1,"message":"108","line":781,"column":7,"nodeType":"114","messageId":"110","endLine":786,"endColumn":35},{"ruleId":"111","severity":1,"message":"115","line":811,"column":16,"nodeType":"101","messageId":"113","endLine":811,"endColumn":17},{"ruleId":"111","severity":1,"message":"116","line":814,"column":13,"nodeType":"101","messageId":"113","endLine":814,"endColumn":14},{"ruleId":"117","severity":1,"message":"118","line":814,"column":39,"nodeType":"119","messageId":"120","endLine":814,"endColumn":68},{"ruleId":"111","severity":1,"message":"121","line":815,"column":13,"nodeType":"101","messageId":"113","endLine":815,"endColumn":14},{"ruleId":"117","severity":1,"message":"122","line":815,"column":39,"nodeType":"119","messageId":"120","endLine":815,"endColumn":68},{"ruleId":"95","severity":1,"message":"96","line":826,"column":45,"nodeType":"97","messageId":"98","endLine":826,"endColumn":47},{"ruleId":"95","severity":1,"message":"96","line":887,"column":24,"nodeType":"97","messageId":"98","endLine":887,"endColumn":26},{"ruleId":"99","severity":1,"message":"123","line":924,"column":14,"nodeType":"101","messageId":"102","endLine":924,"endColumn":23},{"ruleId":"124","severity":1,"message":"125","line":1147,"column":23,"nodeType":"126","messageId":"127","endLine":1147,"endColumn":25},{"ruleId":"124","severity":1,"message":"125","line":1147,"column":35,"nodeType":"126","messageId":"127","endLine":1147,"endColumn":37},{"ruleId":"124","severity":1,"message":"128","line":1147,"column":35,"nodeType":"126","messageId":"127","endLine":1147,"endColumn":37},{"ruleId":"124","severity":1,"message":"128","line":1147,"column":46,"nodeType":"126","messageId":"127","endLine":1147,"endColumn":48},{"ruleId":"124","severity":1,"message":"125","line":1161,"column":23,"nodeType":"126","messageId":"127","endLine":1161,"endColumn":25},{"ruleId":"124","severity":1,"message":"125","line":1161,"column":35,"nodeType":"126","messageId":"127","endLine":1161,"endColumn":37},{"ruleId":"124","severity":1,"message":"128","line":1161,"column":35,"nodeType":"126","messageId":"127","endLine":1161,"endColumn":37},{"ruleId":"124","severity":1,"message":"128","line":1161,"column":46,"nodeType":"126","messageId":"127","endLine":1161,"endColumn":48},{"ruleId":"95","severity":1,"message":"96","line":27,"column":20,"nodeType":"97","messageId":"98","endLine":27,"endColumn":22},{"ruleId":"103","severity":1,"message":"104","line":28,"column":13,"nodeType":"105","messageId":"106","endLine":28,"endColumn":41},{"ruleId":"95","severity":1,"message":"96","line":88,"column":29,"nodeType":"97","messageId":"98","endLine":88,"endColumn":31},{"ruleId":"124","severity":1,"message":"125","line":88,"column":41,"nodeType":"126","messageId":"127","endLine":88,"endColumn":43},{"ruleId":"95","severity":1,"message":"96","line":88,"column":56,"nodeType":"97","messageId":"98","endLine":88,"endColumn":58},{"ruleId":"124","severity":1,"message":"125","line":88,"column":68,"nodeType":"126","messageId":"127","endLine":88,"endColumn":70},{"ruleId":"124","severity":1,"message":"128","line":88,"column":68,"nodeType":"126","messageId":"127","endLine":88,"endColumn":70},{"ruleId":"95","severity":1,"message":"96","line":88,"column":83,"nodeType":"97","messageId":"98","endLine":88,"endColumn":85},{"ruleId":"124","severity":1,"message":"128","line":88,"column":95,"nodeType":"126","messageId":"127","endLine":88,"endColumn":97},{"ruleId":"95","severity":1,"message":"96","line":88,"column":110,"nodeType":"97","messageId":"98","endLine":88,"endColumn":112},{"ruleId":"95","severity":1,"message":"96","line":22,"column":24,"nodeType":"97","messageId":"98","endLine":22,"endColumn":26},{"ruleId":"99","severity":1,"message":"129","line":161,"column":13,"nodeType":"101","messageId":"102","endLine":161,"endColumn":15},{"ruleId":"99","severity":1,"message":"129","line":337,"column":13,"nodeType":"101","messageId":"102","endLine":337,"endColumn":15},{"ruleId":"99","severity":1,"message":"130","line":629,"column":7,"nodeType":"101","messageId":"102","endLine":629,"endColumn":11},"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-unused-vars","'displayNodes' is defined but never used.","Identifier","unusedVar","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","no-unreachable","Unreachable code.","ReturnStatement","unreachableCode","no-redeclare","'node' is already defined.","redeclared","VariableDeclaration","'i' is already defined.","'v' is already defined.","no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'indexV'.","ArrowFunctionExpression","unsafeRefs","'w' is already defined.","Function declared in a loop contains unsafe references to variable(s) 'indexW'.","'getLength' is defined but never used.","no-mixed-operators","Unexpected mix of '&&' and '||'. Use parentheses to clarify the intended order of operations.","LogicalExpression","unexpectedMixedOperator","Unexpected mix of '||' and '&&'. Use parentheses to clarify the intended order of operations.","'wt' is assigned a value but never used.","'data' is assigned a value but never used."]
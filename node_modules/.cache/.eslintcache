[{"/home/thomas/Desktop/GIT_Projects/my-app/src/index.js":"1","/home/thomas/Desktop/GIT_Projects/my-app/src/App.js":"2","/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/index.js":"3","/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/App.js":"4","/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/sketch.js":"5","/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/Graph.js":"6","/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/Edge.js":"7","/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/Node.js":"8"},{"size":535,"mtime":1676507566902,"results":"9","hashOfConfig":"10"},{"size":528,"mtime":1676507566902,"results":"11","hashOfConfig":"10"},{"size":169,"mtime":1661174117362,"results":"12","hashOfConfig":"13"},{"size":4195,"mtime":1676514433023,"results":"14","hashOfConfig":"13"},{"size":22494,"mtime":1676514531948,"results":"15","hashOfConfig":"13"},{"size":3509,"mtime":1666381479580,"results":"16","hashOfConfig":"13"},{"size":489,"mtime":1662486077226,"results":"17","hashOfConfig":"13"},{"size":122,"mtime":1662403525155,"results":"18","hashOfConfig":"13"},{"filePath":"19","messages":"20","suppressedMessages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"4x4cdi",{"filePath":"22","messages":"23","suppressedMessages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"25","messages":"26","suppressedMessages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"13t4la7",{"filePath":"29","messages":"30","suppressedMessages":"31","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"32"},{"filePath":"33","messages":"34","suppressedMessages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":27,"fixableErrorCount":0,"fixableWarningCount":0,"source":"36"},{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"28"},{"filePath":"41","messages":"42","suppressedMessages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"28"},{"filePath":"45","messages":"46","suppressedMessages":"47","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"/home/thomas/Desktop/GIT_Projects/my-app/src/index.js",[],[],"/home/thomas/Desktop/GIT_Projects/my-app/src/App.js",[],[],"/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/index.js",[],[],[],"/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/App.js",["48"],[],"import React, {useState, useEffect, useRef} from \"react\";\nimport './App.css';\nimport { ReactP5Wrapper } from \"react-p5-wrapper\";\nimport sketch from \"./sketch.js\";\nimport Select from \"react-select\";\nimport ReactSlider from \"react-slider\";\nimport 'rc-slider/assets/index.css';\n\nexport function App() {\n\n\n  const [addingNodes, setAddingNodes] = useState(false);\n  const [isRunning, setIsRunning] = useState(false);\n  const [clearingBoard, setClearingBoard] = useState(false);\n  //const algo = 'Nearest Neighbor';\n  const [algo, setSelectedAlgo] = useState(\"Not Selected\");\n  const [speed, setSpeed] = useState(5);\n  const algoOptions = [\n    { value: \"0\", label: \"Select Algorithm\" },\n    { value: \"1\", label: \"Nearest Insertion\" },\n    { value: \"2\", label: \"Farthest Insertion\" },\n    { value: \"3\", label: \"Nearest Neighbor\" },\n    { value: \"4\", label: \"Nearest Neighbor Look Ahead (made up)\" },\n    { value: \"5\", label: \"Brute Force\" },\n   // { value: \"6\", label: \"Cluster naively\" },\n    { value: \"6\", label: \"MST\" }\n  ];\n  const handleAlgoSelect = (e) => {\n    setAddingNodes(false);\n    setIsRunning(false);\n    setSelectedAlgo(e.label);\n  };\n  const handleSpeedSelect = (value) => {\n    setIsRunning(false);\n    setSpeed(value);\n  };\n  const [text, setText] = useState(\"Run Algorithm\");\n  const handleRunAlgoButton = () => {\n    setAddingNodes(false);\n    setClearingBoard(false);\n    if (text == \"Run Algorithm\") {\n      setremoveEdges(false);\n      setIsRunning(true);\n      setText(\"Remove Edges\");\n    }\n    else {\n      setremoveEdges(true);\n      setIsRunning(false);\n      setText(\"Run Algorithm\");\n    }\n  };\n\n  const [removeEdges, setremoveEdges] = useState(false);\n\n\n  //in the beginning we click the AddNodesButton 2, because of weird bug that it only works after clicking at least once\n  const btn =useRef();\n  useEffect(() => {btn.current.click(); setTimeout(() => btn.current.click(), 3);},[]); //setTimeout(() => {console.log('ha'); inputRef.current.handleClick() ; setAddingNodes(false); },2000);}, []);\n  \n  return (\n    <>\n    \n    <div className=\"banner\">\n      <div className=\"banner__container\">\n        <h id=\"banner\">Route Optimization Visualizer</h>\n      </div>\n    </div>\n\n      \n      <div className = \"dropdownContainer\"> \n        <Select className = \"dropdown\"\n          options={algoOptions}\n          onChange={handleAlgoSelect}        \n          value={algoOptions.find(function (option) {\n            return option.value === algo;\n          })}\n          defaultValue={{ label: \"Select Algorithm\", value: 0 }}\n          label=\"Single select\"\n        />\n      </div>\n\n\n      <div className = \"sliderContainer\">\n      <label id=\"slider-label\">Chose speed by sliding</label>\n        <ReactSlider className = \"slider\"\n        ariaLabelledby=\"slider-label\"\n        thumbClassName=\"example-thumb\"\n        trackClassName=\"example-track\"\n        max = {50}\n        renderThumb={(props, state) => <div {...props}>{state.valueNow}</div>}\n        defaultValue= {5}\n        onChange ={handleSpeedSelect}\n        />\n      </div>\n    \n\n    <div className = \"Main\">\n      <div className=\"Canvas\">\n        <ReactP5Wrapper sketch={sketch} addingNodes = {addingNodes} isRunning = {isRunning} clearinBoard = {clearingBoard} algo = {algo} speed = {speed} removeEdges = {removeEdges} /> \n      </div>\n    </div>\n\n  \n    <div className = \"Buttons\">\n      <button ref = {btn} className = \"AddNodesButton\" \n        onClick={()=>{\n                  setAddingNodes(!addingNodes);\n                  setIsRunning(false);\n                  setClearingBoard(false);\n                  } }>\n                    {addingNodes ? 'Stop adding Nodes' : 'Add Nodes'}\n        </button>\n        <button className = \"RunAlgoButton\" \n                onClick={()=>{\n                  handleRunAlgoButton();\n                  } }>\n                    {text}\n        </button>\n        <button className = \"ClearBoardButton\" \n                onClick={()=>{\n                  setAddingNodes(false);\n                  setIsRunning(false);\n                  setClearingBoard(!clearingBoard);\n                } }>\n          Clear Bord\n        </button>\n      </div>\n      \n    </>\n  );\n};\n\nexport default App;","/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/sketch.js",["49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75"],[],"import {Graph} from './Graph.js';\nimport {Node} from './Node.js';\nimport {Edge} from './Edge.js';\n\nlet WIDTH = window.innerWidth; //\"static variables\" like in java\nlet HEIGHT = window.innerHeight *3/ 5;\nlet speed = 5; \n\nlet startNode = new Node(WIDTH / 2, HEIGHT / 2, 0);\nlet count = 1; //count the nodes\nlet graph = new Graph(0);\nlet totalGraph = new Graph(0);\nlet startDefined = false;\nlet algo = \"Not Defined\";\n\nconst sketch = (p) => {\n\n  let addingNodes = false;\n  let isRunning = false;\n  let clearingBoard = false;\n  //let algoFinished = false;\n\n\n  p.setup = () => {\n    p.createCanvas(WIDTH, HEIGHT);\n  };\n\n  p.windowResized = () => {\n    WIDTH = window.innerWidth;\n    HEIGHT = window.innerHeight *3/5;\n    p.resizeCanvas(WIDTH, HEIGHT);\n  }\n\n  p.draw = async () => {\n    console.log(\"props are: addingNodes \" + addingNodes + \" isRunnung: \" + isRunning);\n    p.background(220);\n    //draw the nodes\n    //mouse position and already added nodes white\n    p.fill(\"#fff\");\n    p.circle(p.mouseX, p.mouseY, 10);\n    if (startDefined) {\n      let nodes = graph.getNodes();\n      for (let node of nodes) {\n        if (node.color)\n          p.fill(node.color);\n        else \n          p.fill(\"#fff\");\n        p.circle(node.x, node.y, 10);\n      }\n      //draw edges \n      drawEdges(p);\n    }\n     //start node pink\n     p.fill(255, 0, 200);\n     p.circle(startNode.x, startNode.y, 10);\n\n     if (isRunning) {\n      isRunning = false;\n      console.log(\"hi, cur algo is: \" + algo);\n      switch(algo) {\n        case 'Nearest Insertion':\n          await insertion(\"nearest\");\n          break;\n          case 'Farthest Insertion':\n            await insertion(\"farthest\");\n            break;\n          case 'Nearest Neighbor':\n            await nearestNeighbor(startNode, new Array(graph.V).fill(false), false);\n            break;\n          case 'Nearest Neighbor Look Ahead (made up)':\n            await nearestNeighborImproved();\n            break;\n          case 'Brute Force':\n            await bruteForce(startNode, new Array(graph.V).fill(false), 0);\n            break;\n          case 'Cluster naively':\n            await clusterNaively();\n            break;\n          case 'MST':\n            await computeMST();\n            break;\n          default:\n            isRunning = false;\n      }\n            //christofides();\n    }\n\n  };\n\n\n  function anyNodeHasNeighbors() {\n    return graph.E > 0;\n  }\n\n\n  function drawEdges(p) {\n    //displayNeihbors(startNode);\n    if (anyNodeHasNeighbors()) {\n      let edges = graph.getEdges();\n      for (let e of edges) {\n        if (e.color) {\n          p.stroke(e.color);\n        }\n        else \n          p.stroke('black');\n        let v1 = e.either();\n        let v2 = e.other(v1);\n        let x1 = v1.x;\n        let y1 = v1.y;\n        let x2 = v2.x;\n        let y2 = v2.y;\n        p.line(x1, y1, x2, y2);\n      }\n    }\n  }\n\n\n  function removeAllEdges() {\n    let tempGraph = new Graph(0);\n    for (let node of graph.getNodes())\n      tempGraph.addVertex(node);\n    graph = tempGraph;\n    totalGraph = new Graph(0);\n  }\n\n\n  \n  p.mouseClicked = async () => {\n    if (addingNodes) \n      addNodes(p);\n    //the algorithm updates the paths that p.draw() displays\n  };\n\n  /**\n   * Adding nodes to canvas\n   * @param {}\n   */\n  function addNodes(p) {\n    if (!startDefined) {\n      graph.addVertex(startNode);\n      startDefined = true;\n    }\n    p.loop();\n    //if Y is smaller than HEIGHT, the click was outside of canvas (probably on button) and the don't add\n    if (p.mouseY < HEIGHT && p.mouseY > 0) {\n      let node = new Node(p.mouseX, p.mouseY, count++);\n      graph.addVertex(node);\n    }\n  }\n\n    //this function \"sends\" data/additional parameters to our function. When ever the props change, the change is passed here\n    p.updateWithProps = function (newProps) {\n      if (newProps.removeEdges) {\n        removeAllEdges();\n      }\n      addingNodes = newProps.addingNodes;\n      isRunning = newProps.isRunning;\n      clearingBoard = newProps.clearinBoard;\n      if (clearingBoard) {\n        startNode = new Node(WIDTH / 2, HEIGHT / 2, 0, []);\n        count = 1; //count the nodes\n        graph = new Graph(0);\n        startDefined = false;\n        totalGraph = new Graph(0);\n      }\n      if (!newProps.algo !== algo)\n        algo = newProps.algo;\n      if (!newProps.speed !== speed) \n        speed = newProps.speed;\n      if (speed == 0)\n        speed = 1;\n      //whenever a prop changes we start the loop again (it's only stopped after the path got displayed)\n      p.loop();\n    }\n/*\n    async function runAlgorithm() {\n      for (let i = 0; i < nodes.length; ++i) {\n        adj[i] = nodes[i];\n      }\n      adj[nodes.length] = nodes[0];\n    }\n*/\n\n    async function delay(time) {\n      return new Promise(resolve => setTimeout(resolve, time/speed));\n    }\n    \n    \n    function displayNodes() {\n      graph.printGraph();\n    }\n\n    /**\n     * Mode has to be \"nearest\" or \"farthest\" and decides\n     * whether we run nearestInsertion or farthestInsertion.\n     * @param {string} mode \n     */\n    async function insertion(mode) {\n      //add the startNode\n      let toAdd = startNode;\n      var included = new Array(graph.V).fill(false);\n      included[toAdd.index] = true;\n\n      //add the first node\n      let node = null;\n      switch(mode) {\n        case \"nearest\":\n          node = findNode(startNode, included, \"closest\");\n          break;\n        case \"farthest\":\n          node = findNode(startNode, included, \"farthest\");\n          break;\n        default:\n\n      }\n      addEdge(startNode, node, euclidDistance(startNode, node));\n      included[node.index] = true;\n      await delay(1000);\n\n      //the second node is inserted slightly different than the remaining ones\n      let arr = null;\n      switch(mode) {\n        case \"nearest\":\n          arr = findClosestOrFarthestToIncluded(included, \"closest\");\n          break;\n        case \"farthest\":\n          arr = findClosestOrFarthestToIncluded(included, \"farthest\");\n          break;\n        default:\n      }\n      let root = arr[0];\n      toAdd = arr[1];\n      let followUp = arr[2];\n      addEdge(root, toAdd, euclidDistance(root, toAdd));\n      addEdge(followUp, toAdd, euclidDistance(followUp, toAdd));\n      included[toAdd.index] = true;\n      await delay(1000);\n\n      //we know how many nodes well have to add, so for loop\n      for (let i = 0; i< graph.V-3; ++i) {\n        let arr = null;\n        switch(mode) {\n          case \"nearest\":\n            arr = findClosestOrFarthestToIncluded(included, \"closest\");\n            break;\n          case \"farthest\":\n            arr = findClosestOrFarthestToIncluded(included, \"farthest\");\n            break;\n          default:\n\n        }\n        let root = arr[0];\n        let toAdd = arr[1];\n        let followUp = arr[2];\n        //remove edge between root and followUp\n        removeEdge(root, followUp);\n        //mark the three nodes\n        toAdd.color = \"#ae2a0d\";\n        root.color = \"#0f61e8\";\n        followUp.color = \"#0f61e8\";\n        await delay(1000);\n        //add edges\n        addEdge(root, toAdd, euclidDistance(root, toAdd));\n        await delay(400);\n        addEdge(toAdd, followUp, euclidDistance(toAdd, followUp)); \n        included[toAdd.index] = true;\n        await delay(1000);\n        toAdd.color = \"#fff\";\n        root.color = \"#fff\";\n        followUp.color = \"#fff\";\n      }\n      //algoFinished = true;\n    }\n\n    /**\n     * \n     * @param {boolean[]} included \n     * @param {string} mode \n     * @returns \n     */\n    function findClosestOrFarthestToIncluded(included, mode) {\n      if (mode !== \"closest\" && mode !== \"farthest\")\n        throw('Invalid Input. Mode is: ' + mode + ' but has to be \"closest\" or \"farthest\"');\n\n      let curMinOrMax = Number.MAX_VALUE; //min\n      if (mode == \"farthest\") {\n        curMinOrMax = Number.MIN_VALUE; //max\n      }\n      let root = null;\n      let closestToRoot = null;\n      \n      //iterating through all non - included nodes\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      for (let node of nonIncludedNodes) {\n        //and find closest distance to included \n        let [closestDist, potentialRoot] = findClosestNode(node, getIncludedNodes(included));\n        //if that cloeset dist is greate than curMax, than the node is considered to be farther from included\n        if (mode == \"closest\") {\n          if (closestDist < curMinOrMax) {\n            curMinOrMax = closestDist;\n            root = potentialRoot;\n            closestToRoot = node;\n          }\n        }\n        if (mode == \"farthest\") {\n          if (closestDist > curMinOrMax) {\n            curMinOrMax = closestDist;\n            root = potentialRoot;\n            closestToRoot = node;\n          }\n        }\n      }\n      let rootEdges = graph.AdjList.get(root);\n\n      let firstRootNeighbor = rootEdges[0].other(root);\n      if (rootEdges.length == 1)\n        return [root, closestToRoot, firstRootNeighbor];\n      let secondRootNeighbor =  rootEdges[1].other(root);\n      let newDist1 = euclidDistance(closestToRoot, firstRootNeighbor);\n      let newDist2 = euclidDistance(closestToRoot, secondRootNeighbor);\n      let oldDist1 = euclidDistance(root, firstRootNeighbor);\n      let oldDist2 = euclidDistance(root, secondRootNeighbor);\n\n      if (newDist1 - oldDist1 < newDist2 -oldDist2)\n        return [root, closestToRoot, firstRootNeighbor];\n      return [root, closestToRoot, secondRootNeighbor];\n    }\n\n    /**\n     * \n     * @param {Node} node \n     * @param {Node} nodes \n     * @returns [closestDist, closestNode]\n     */\n    function findClosestNode(node, nodes) {\n      let closestNode = null;\n      let closestDist = Number.MAX_VALUE;\n      for (let v of nodes) {\n        let dist = euclidDistance(node, v);\n        if (dist < closestDist) {\n          closestDist = dist;\n          closestNode = v;\n        }\n      }\n      return [closestDist, closestNode];\n    }\n\n    function removeEdge(node1, node2) {\n      graph.removeEdge(node1, node2);\n    }\n\n    /**\n     * Adds an edge between the node node1 and node2 that have to exist in the graph\n     * @param {Node} node1 \n     * @param {Node} node2\n     */\n    function addEdge (node1, node2, weight) {\n      if (node1.index == node2.index)\n      throw('nodes cannot be the same');\n      graph.addEdge(node1, node2, weight);\n    }\n    \n    /**\n     * This function runs nearestNeigbor on the global graph, starting from\n     * curNode, only visiting non-included nodes (as given by the included array).\n     * The boolean value timeOnlyFromCurNode specifies whether the function returns the\n     * total travel time from startNode to startNode, or only from curNode to startNode.\n     * @param {Node} curNode \n     * @param {boolean[]} included \n     * @param {boolean} timeOnlyFromCurNode \n     * @returns \n     */\n    async function nearestNeighbor(curNode, included, timeOnlyFromCurNode) {\n      if (timeOnlyFromCurNode == undefined)\n        timeOnlyFromCurNode = false;\n      let time = 0;\n      //algoFinished = false;\n      included[curNode.index] = true;\n      //adj.push(curNode);\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      for (let i = 0; i < nonIncludedNodes.length; ++i) {\n        let node = findNode(curNode, included, \"closest\");\n        //add an edge between node and curNode\n        let weight = euclidDistance(node, curNode);\n        time += weight;\n        addEdge(node, curNode, weight);\n\n        curNode = node;\n        included[curNode.index] = true;\n\n        //adj.push(curNode);\n        await delay(300);\n      }\n      let weight = euclidDistance(curNode, startNode);\n      time += weight;\n      addEdge(curNode, startNode, weight);\n      await delay(300);\n      if (timeOnlyFromCurNode)\n        return time;\n      return await calculateTravelTime();\n      //algoFinished = true;\n    }\n\n    \n    async function calculateTravelTime(start) {\n      let time = 0;\n      let V = graph.V;\n      let included = new Array(V).fill(false);\n      included[startNode.index] = true;\n      let curNode = startNode;\n      //adding all nodes\n      for (let i = 0; i<graph.V-1; ++i) {\n        let edgesToCurNode = graph.AdjList.get(curNode);\n        for (let edge of edgesToCurNode) {\n          let neighbor = edge.other(curNode);\n          if (!included[neighbor.index]) {\n            time += edge.weight;\n            included[neighbor.index] = true;\n            curNode = neighbor;\n            break;\n          }\n        }\n      }\n      let lastEdge = graph.findEdge(curNode, startNode);\n      time += lastEdge.weight;\n      return time;\n    }\n\n    function getNonIncludedNodes(included) {\n      let out = [];\n      for (let v of graph.getNodes()) {\n        if (!included[v.index])\n          out.push(v);\n      }\n      return out;\n    }\n\n    function getIncludedNodes(included) {\n      let out = [];\n      for (let v of graph.getNodes()) {\n        if (included[v.index])\n          out.push(v);\n      }\n      return out;\n    }\n\n    /**\n     * \n     * @param {Node} curNode \n     * @param {boolean[]} included \n     * @param {double} time \n     * @returns \n     */\n    async function bruteForce(curNode, included, time) {\n      included[curNode.index] = true;\n      let neighbors = getNonIncludedNodes(included);\n      if (neighbors.length == 0) {\n        let weight = euclidDistance(startNode, curNode);\n        addEdge(startNode, curNode, weight);\n        return time + weight;\n      }\n      let minTime = Number.MAX_VALUE;\n      let bestNeighbor = null;\n      for (let neighbor of neighbors) {\n        let includedCopy = JSON.parse(JSON.stringify(included));\n        let tempGraph = copyGraph(graph);\n        addEdge(curNode, neighbor, euclidDistance(curNode, neighbor));\n        await delay(300);\n        let finishTime = await bruteForce(neighbor, includedCopy, time + euclidDistance(curNode, neighbor));\n        if (finishTime < minTime) {\n          minTime = finishTime;\n          bestNeighbor = neighbor;\n        }\n        graph = copyGraph(tempGraph);\n        await delay(300);\n      }\n      addEdge(curNode, bestNeighbor, euclidDistance(curNode, bestNeighbor));\n      await delay(400);\n      return bruteForce(bestNeighbor, included, time + euclidDistance(curNode, bestNeighbor));\n    }\n\n    async function nearestNeighborImproved() {\n      let curNode = startNode;\n      let included = new Array(graph.V).fill(false);\n      included[curNode.index] = true;\n      //in every iteration add one node\n      for (let i = 0; i<graph.V -1; ++i) {\n        let min = Number.MAX_VALUE;\n        let potentialNextNode = null;\n        let nonIncludedNodes = getNonIncludedNodes(included);\n        //iterate through all non-included nodes\n        for (let v of nonIncludedNodes) {\n          let tempGraph = copyGraph(graph);\n          let includedCopy = JSON.parse(JSON.stringify(included));\n          addEdge(curNode, v, euclidDistance(curNode, v));\n          let time = await nearestNeighbor(v, includedCopy, true);\n          time += euclidDistance(curNode, v);\n          delay(300);\n          if (time < min) {\n            potentialNextNode = v;\n            min = time;\n          }      \n          graph = copyGraph(tempGraph);\n        }\n        \n        addEdge(curNode, potentialNextNode, euclidDistance(curNode, potentialNextNode));\n        curNode = potentialNextNode;\n        included[curNode.index] = true;\n        await delay(300);\n      }\n      addEdge(curNode, startNode, euclidDistance(curNode, startNode));\n    }\n\n    function copyGraph(g) {\n      let newGraph = new Graph(0);\n      for (let node of g.getNodes()){\n        newGraph.addVertex(node);\n      }\n      for (let edge of g.getEdges()) {\n        newGraph.addEdgeFromEdge(edge);\n      }\n      return newGraph;\n    }\n\n    /**\n     * This method finds the closest or farthets Node to curNode, \n     * that is not yet inclueded (true in the included array). The \n     * mode decides if we find closest or farthets and has to be\n     * \"closest\" or \"farthsest\".\n     * @param {*} curNode \n     * @param {*} included \n     * @param {string} mode\n     * @returns \n     */\n    function findNode(curNode, included, mode) {\n      if (mode !== \"closest\" && mode !== \"farthest\")\n        throw('Invalid Input. Mode is: ' + mode + ' but has to be \"closest\" or \"farthest\"');\n      let minOrMax = Number.MAX_VALUE; //min\n      if (mode == \"farthest\")\n        minOrMax = Number.MIN_VALUE; //max\n      let curClosestOrFarthest = null;\n      for (let node of graph.getNodes()) {\n        if (included[node.index])\n          continue;\n        let dist = euclidDistance(curNode, node);\n        //let dist = graph.findEdge(curNode, node).weight;\n        if (mode == \"closest\") {\n          if (dist < minOrMax) {\n            minOrMax = dist;\n            curClosestOrFarthest = node;\n          }\n        }\n        else {\n          if (dist > minOrMax) {\n            minOrMax = dist;\n            curClosestOrFarthest = node;\n          }\n        }\n      }\n      return curClosestOrFarthest;\n    }\n\n    /**\n     * \n     * @param {Node} node1 \n     * @param {Node} node2 \n     * @returns \n     */\n    function euclidDistance(node1, node2) {\n      if (!node1 || !node2) {\n        throw('a node for dist does not exists');\n        return\n      }\n      let result = (node1.x - node2.x) * (node1.x - node2.x) + (node1.y - node2.y) * (node1.y - node2.y);\n      return Math.sqrt(result);\n    }\n\n    async function christofides() {\n      await computeMST();\n      let nodesWithOddDegree = getNodesWithOddDegree(graph);  \n      await findPerfectMatchingMinWeight();\n      let edge = new Edge(nodesWithOddDegree[0], nodesWithOddDegree[1], euclidDistance(nodesWithOddDegree[0], nodesWithOddDegree[1]));\n      //console.log('there are nodes with odd degree: ' + nodesWithOddDegree.length);\n      edge.color = 255;\n      graph.addEdgeFromEdge(edge);\n      //min-cost-max matching is harder than I thought...\n      \n    }\n\n    /**\n     * \n     * @param {Node} {even number of nodes} \n     */\n    async function findPerfectMatchingMinWeight(nodes) {\n\n\n    } \n\n    function getNodesWithOddDegree(g) {\n      let out = [];\n      for (let node of g.getNodes()) {\n        if (g.getNeighbors(node).length % 2 == 1){\n          out.push(node);\n        }\n      }\n      return out;\n    }\n\n    /**\n     * Computes MST from the global variable totalGraph, that we also initialize here\n     */\n    async function computeMST() {\n      //first fill total graph if not already done\n      fillTotalGraph();\n      let distTo = new Array(graph.V).fill(Number.MAX_VALUE);\n      let included = new Array(graph.V).fill(false);\n      distTo[startNode.index] = 0;\n      included[startNode.index] = true;\n      updateDistances(startNode, distTo);\n      //adding V nodes to MST\n      for (let i = 0; i< graph.V-1; ++i) {\n        let node = shortestAddableNodeToIncluded(distTo, included);\n        let [weight, root] = findClosestNode(node, getIncludedNodes(included));\n        addEdge(root, node, weight);\n        included[node.index] = true;\n        updateDistances(node, distTo);\n        await delay(300);\n      }\n    }\n\n    function updateDistances(node, distTo) {\n      let neighbors = totalGraph.getNeighbors(node);\n      neighbors.forEach(v => {\n        distTo[v.index] = totalGraph.findEdge(v, node).weight;\n      });\n    }\n\n    /**\n     * This function returns a node and the edge connecting this node\n     * with one that is included such that the weight is minimal.\n     * @param {double[]} distTo \n     * @param {boolean[]} included \n     */\n    function shortestAddableNodeToIncluded(distTo, included) {\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      let closestDist = Number.MAX_VALUE;\n      let closestNode = null;\n      for (let node of nonIncludedNodes) {\n        if (distTo[node.index] < closestDist) {\n          closestDist = distTo[node.index];\n          closestNode = node;\n        }\n      }\n      return closestNode;\n    }\n\n    /**\n     * Creates a total graph (edges between all nodes)\n     */\n    function fillTotalGraph() {\n      if (totalGraph.V == 0) {\n        let nodes = graph.getNodes();\n        let allNodesAdded = false;\n        for (let i = 0; i < nodes.length; ++i) {\n          if (!allNodesAdded)\n            totalGraph.addVertex(nodes[i]);\n          for (let j = i+1; j< nodes.length; ++j) {\n            if (!allNodesAdded) \n              totalGraph.addVertex(nodes[j]);\n            let weight = euclidDistance(nodes[i], nodes[j]);\n            let edge = new Edge(nodes[i], nodes[j], weight);\n            totalGraph.addEdgeFromEdge(edge);\n          }\n          if (!allNodesAdded) \n            allNodesAdded = true;\n        }\n      }\n    }\n\n    /**\n     * \n     * @param {number of clusters} k \n     */\n    async function clusterNaively(k) {\n      fillTotalGraph();\n      let nodesPerCluster = totalGraph.V/k;\n      let edges = totalGraph.getEdges();\n      edges.sort((e1, e2) => (e1.weight >= e2.weight) ? 1 : -1);\n      //add small edges to cluster, if it doesn't exceed its size (size is naively n/k)\n      for (let e of edges) {\n        await delay(1000);    \n        let v1 = e.either();\n        let v2 = e.other(v1);\n        console.log(\"v1: \" + v1.index);\n        console.log(\"v2: \" + v2.index);    \n        //case 1, both nodes not included\n        if (!v1.root && !v2.root) {\n          v2.root = v1;\n          v1.isRoot = true;\n          v1.children = 1;\n          addEdge(v1, v2, e.weight);\n          console.log(\"v1 and v2 both had no root. Now children \" + v1.children);\n          continue;\n        }\n        if (v1.isRoot && !v2.root || v1.root && !v2.root) {\n            if (v1.isRoot) {\n              if (v1.children + 1 < nodesPerCluster) {\n                v2.root = v1;\n                v1.children++;\n              }\n            }\n            else {\n              v2.root = v1.root; \n              v1.root.children++;\n            }\n            addEdge(v1, v2, e.weight);\n            continue;\n          }\n        if (v2.isRoot && !v1.root || v2.root && !v1.root) {\n          if (v2.root.children + 1 < nodesPerCluster) {\n            v1.root = v2.root;\n            v2.root.children++;\n            addEdge(v1, v2, e.weight);\n          }\n          continue;\n        }\n        if (v1.root && v2.root) {\n          if (v1.root.children + 1 + v2.root + 1 < nodesPerCluster) {\n            let temp = v1.root.children + 1;\n            v1.root = v2.root;\n            v2.root.children += temp;\n            addEdge(v1, v2, e.weight);\n          }\n          continue;\n        }\n      }\n\n    }\n\n}\n\nexport default sketch;","/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/Graph.js",["76","77","78","79","80","81","82","83","84","85"],[],"import {Edge} from './Edge.js'; \n\nexport class Graph {\n    constructor(V) {\n        this.V = V;\n        this.E = 0;\n        this.AdjList = new Map();\n    }\n\n    /**\n     * \n     * @param {Node} v \n     */\n    addVertex(v) {\n        this.AdjList.set(v, []);\n        this.V++;\n    }\n\n    /**\n     * \n     * @param {Node} v \n     * @param {Node} w \n     * @param {double} weight\n     */\n    addEdge(v, w, weight) {\n        if (weight == undefined)\n            throw 'weight is undefined';\n        let e = new Edge(v, w, weight); \n        this.AdjList.get(v).push(e);\n        this.AdjList.get(w).push(e);\n        this.E++;\n    }\n\n    addEdgeFromEdge(edge) {\n        let v = edge.either();\n        let w = edge.other(v);\n        this.AdjList.get(v).push(edge);\n        this.AdjList.get(w).push(edge);\n        this.E++;\n    }\n\n    /**\n     * @returns {Edge[]} edges\n     */\n    getEdges() {\n        let edgeList = [];\n        let nodes = this.AdjList.keys();\n        // iterate over the vertices\n        for (let node of nodes) {\n            //get all edges that contain that vertex\n            let edges = this.AdjList.get(node);\n            //iterate over all these edges\n            for (let e of edges) {\n                if (node.index < e.other(node).index)\n                    edgeList.push(e);\n            }\n        }\n        return edgeList;\n    }\n\n    removeAllEdges() {\n        let newMap = new Map();\n        for (let node of this.AdjList) {\n            newMap.set(node, []);\n        }\n        this.AdjList = newMap;\n        this.E = 0;\n    }\n\n    removeEdge(v1, v2) {\n        let e = this.findEdge(v1, v2);\n        this.AdjList.get(v1).splice(this.AdjList.get(v1).indexOf(e), 1);\n        this.AdjList.get(v2).splice(this.AdjList.get(v2).indexOf(e), 1);\n    }\n\n    /**\n     * \n     * @param {Node} v1 \n     * @param {Node} v2 \n     * @returns \n     */\n    findEdge(v1, v2) {\n        let edges = this.getEdges();\n        for (let e of edges) {\n            let node1 = e.either();\n            let node2 = e.other(node1);\n            if (node1.index == v1.index && node2.index == v2.index || node2.index == v1.index && node1.index == v2.index)\n                return e; \n        }\n    }\n\n    getNeighbors(node) {\n        let out = [];\n        for (let edge of this.AdjList.get(node)) {\n            out.push(edge.other(node));\n        }\n        return out;\n    }\n\n    /**\n     * \n     * @returns {Node[]} nodes \n     */\n    getNodes() {\n        let nodes = [];\n        for (let node of this.AdjList.keys()) {\n            nodes.push(node);\n        }\n        return nodes;\n    }\n\n    printGraph() {\n        // get all the vertices\n        var get_keys = this.AdjList.keys();\n \n        // iterate over the vertices\n        for (let node of get_keys) {\n            let str = node.index  + \": \";\n            //get all edges that contain that vertex\n            let edges = this.AdjList.get(node);\n            //iterate over all these edges\n            for (let e of edges) {\n                str += e.other(node).index + \" (w: \" + e.weight + \")  \";\n            }\n            console.log(str);\n        }\n    }\n}\n\n\n/*\n// Using the above implemented graph class\nvar g = new Graph(6);\nvar vertices = [ new Node(1,1,1), new Node(2,2,2), new Node(3,3,3) ];\n \n// adding vertices\nfor (var i = 0; i < vertices.length; i++) {\n    g.addVertex(vertices[i]);\n}\n \n// adding edges\ng.addEdge(vertices[0], vertices[1], 2);\ng.addEdge(vertices[0], vertices[2], 3);\n \n// prints all vertex and\n// its adjacency list\ng.printGraph();\n\n*/","/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/Edge.js",["86"],[],"export class Edge {\n    /**\n     * \n     * @param {Node} v \n     * @param {Node} w \n     * @param {double} weight \n     */\n    constructor(v, w, weight) {\n      this.v = v;\n      this.w = w;\n      this.weight = weight;\n    }\n\n    either() {\n        return this.v;\n    }\n\n    other(node) {\n        if (node.index == this.v.index)\n            return this.w;\n        return this.v;\n    }\n\n    toString() {\n        return this.v.index + \"-\" + this.w.index + \" (\" + this.weight + \")\";\n    }\n  }","/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/Node.js",[],[],{"ruleId":"87","severity":1,"message":"88","line":41,"column":14,"nodeType":"89","messageId":"90","endLine":41,"endColumn":16},{"ruleId":"87","severity":1,"message":"88","line":170,"column":17,"nodeType":"89","messageId":"90","endLine":170,"endColumn":19},{"ruleId":"91","severity":1,"message":"92","line":189,"column":14,"nodeType":"93","messageId":"94","endLine":189,"endColumn":26},{"ruleId":"95","severity":1,"message":"96","line":283,"column":9,"nodeType":"97","messageId":"98","endLine":283,"endColumn":93},{"ruleId":"87","severity":1,"message":"88","line":286,"column":16,"nodeType":"89","messageId":"90","endLine":286,"endColumn":18},{"ruleId":"87","severity":1,"message":"88","line":298,"column":18,"nodeType":"89","messageId":"90","endLine":298,"endColumn":20},{"ruleId":"87","severity":1,"message":"88","line":305,"column":18,"nodeType":"89","messageId":"90","endLine":305,"endColumn":20},{"ruleId":"87","severity":1,"message":"88","line":316,"column":28,"nodeType":"89","messageId":"90","endLine":316,"endColumn":30},{"ruleId":"87","severity":1,"message":"88","line":358,"column":23,"nodeType":"89","messageId":"90","endLine":358,"endColumn":25},{"ruleId":"95","severity":1,"message":"96","line":359,"column":7,"nodeType":"97","messageId":"98","endLine":359,"endColumn":41},{"ruleId":"87","severity":1,"message":"88","line":374,"column":31,"nodeType":"89","messageId":"90","endLine":374,"endColumn":33},{"ruleId":"87","severity":1,"message":"88","line":457,"column":28,"nodeType":"89","messageId":"90","endLine":457,"endColumn":30},{"ruleId":"95","severity":1,"message":"96","line":537,"column":9,"nodeType":"97","messageId":"98","endLine":537,"endColumn":93},{"ruleId":"87","severity":1,"message":"88","line":539,"column":16,"nodeType":"89","messageId":"90","endLine":539,"endColumn":18},{"ruleId":"87","severity":1,"message":"88","line":547,"column":18,"nodeType":"89","messageId":"90","endLine":547,"endColumn":20},{"ruleId":"95","severity":1,"message":"96","line":571,"column":9,"nodeType":"97","messageId":"98","endLine":571,"endColumn":50},{"ruleId":"99","severity":1,"message":"100","line":572,"column":9,"nodeType":"101","messageId":"102","endLine":572,"endColumn":15},{"ruleId":"91","severity":1,"message":"103","line":578,"column":20,"nodeType":"93","messageId":"94","endLine":578,"endColumn":32},{"ruleId":"87","severity":1,"message":"88","line":602,"column":45,"nodeType":"89","messageId":"90","endLine":602,"endColumn":47},{"ruleId":"87","severity":1,"message":"88","line":661,"column":24,"nodeType":"89","messageId":"90","endLine":661,"endColumn":26},{"ruleId":"104","severity":1,"message":"105","line":705,"column":23,"nodeType":"106","messageId":"107","endLine":705,"endColumn":25},{"ruleId":"104","severity":1,"message":"105","line":705,"column":35,"nodeType":"106","messageId":"107","endLine":705,"endColumn":37},{"ruleId":"104","severity":1,"message":"108","line":705,"column":35,"nodeType":"106","messageId":"107","endLine":705,"endColumn":37},{"ruleId":"104","severity":1,"message":"108","line":705,"column":46,"nodeType":"106","messageId":"107","endLine":705,"endColumn":48},{"ruleId":"104","severity":1,"message":"105","line":719,"column":23,"nodeType":"106","messageId":"107","endLine":719,"endColumn":25},{"ruleId":"104","severity":1,"message":"105","line":719,"column":35,"nodeType":"106","messageId":"107","endLine":719,"endColumn":37},{"ruleId":"104","severity":1,"message":"108","line":719,"column":35,"nodeType":"106","messageId":"107","endLine":719,"endColumn":37},{"ruleId":"104","severity":1,"message":"108","line":719,"column":46,"nodeType":"106","messageId":"107","endLine":719,"endColumn":48},{"ruleId":"87","severity":1,"message":"88","line":26,"column":20,"nodeType":"89","messageId":"90","endLine":26,"endColumn":22},{"ruleId":"95","severity":1,"message":"96","line":27,"column":13,"nodeType":"97","messageId":"98","endLine":27,"endColumn":41},{"ruleId":"87","severity":1,"message":"88","line":87,"column":29,"nodeType":"89","messageId":"90","endLine":87,"endColumn":31},{"ruleId":"104","severity":1,"message":"105","line":87,"column":41,"nodeType":"106","messageId":"107","endLine":87,"endColumn":43},{"ruleId":"87","severity":1,"message":"88","line":87,"column":56,"nodeType":"89","messageId":"90","endLine":87,"endColumn":58},{"ruleId":"104","severity":1,"message":"105","line":87,"column":68,"nodeType":"106","messageId":"107","endLine":87,"endColumn":70},{"ruleId":"104","severity":1,"message":"108","line":87,"column":68,"nodeType":"106","messageId":"107","endLine":87,"endColumn":70},{"ruleId":"87","severity":1,"message":"88","line":87,"column":83,"nodeType":"89","messageId":"90","endLine":87,"endColumn":85},{"ruleId":"104","severity":1,"message":"108","line":87,"column":95,"nodeType":"106","messageId":"107","endLine":87,"endColumn":97},{"ruleId":"87","severity":1,"message":"88","line":87,"column":110,"nodeType":"89","messageId":"90","endLine":87,"endColumn":112},{"ruleId":"87","severity":1,"message":"88","line":19,"column":24,"nodeType":"89","messageId":"90","endLine":19,"endColumn":26},"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-unused-vars","'displayNodes' is defined but never used.","Identifier","unusedVar","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","no-unreachable","Unreachable code.","ReturnStatement","unreachableCode","'christofides' is defined but never used.","no-mixed-operators","Unexpected mix of '&&' and '||'. Use parentheses to clarify the intended order of operations.","LogicalExpression","unexpectedMixedOperator","Unexpected mix of '||' and '&&'. Use parentheses to clarify the intended order of operations."]
{"ast":null,"code":"import { Edge } from './Edge.js';\nexport class Graph {\n  constructor(V) {\n    this.V = V;\n    this.E = 0;\n    this.AdjList = new Map();\n  }\n\n  /**\n   * \n   * @param {Node} v \n   */\n  addVertex(v) {\n    this.AdjList.set(v, []);\n    this.V++;\n  }\n\n  /**\n   * \n   * @param {Node} v \n   * @param {Node} w \n   * @param {double} weight\n   */\n  addEdge(v, w, weight) {\n    if (weight == undefined) throw 'weight is undefined';\n    let e = new Edge(v, w, weight);\n    this.AdjList.get(v).push(e);\n    this.AdjList.get(w).push(e);\n    this.E++;\n  }\n  addEdgeFromEdge(edge) {\n    let v = edge.either();\n    let w = edge.other(v);\n    this.AdjList.get(v).push(edge);\n    this.AdjList.get(w).push(edge);\n    this.E++;\n  }\n\n  /**\n   * @returns {Edge[]} edges\n   */\n  getEdges() {\n    let edgeList = [];\n    let nodes = this.AdjList.keys();\n    // iterate over the vertices\n    for (let node of nodes) {\n      //get all edges that contain that vertex\n      let edges = this.AdjList.get(node);\n      //iterate over all these edges\n      for (let e of edges) {\n        if (node.index < e.other(node).index) edgeList.push(e);\n      }\n    }\n    return edgeList;\n  }\n  removeAllEdges() {\n    let newMap = new Map();\n    for (let node of this.AdjList) {\n      newMap.set(node, []);\n    }\n    this.AdjList = newMap;\n    this.E = 0;\n  }\n  removeEdge(v1, v2) {\n    let e = this.findEdge(v1, v2);\n    this.AdjList.get(v1).splice(this.AdjList.get(v1).indexOf(e), 1);\n    this.AdjList.get(v2).splice(this.AdjList.get(v2).indexOf(e), 1);\n  }\n\n  /**\n   * \n   * @param {Node} v1 \n   * @param {Node} v2 \n   * @returns \n   */\n  findEdge(v1, v2) {\n    let edges = this.getEdges();\n    for (let e of edges) {\n      let node1 = e.either();\n      let node2 = e.other(node1);\n      if (node1.index == v1.index && node2.index == v2.index || node2.index == v1.index && node1.index == v2.index) return e;\n    }\n  }\n  getNeighbors(node) {\n    let out = [];\n    for (let edge of this.AdjList.get(node)) {\n      out.push(edge.other(node));\n    }\n    return out;\n  }\n\n  /**\n   * \n   * @returns {Node[]} nodes \n   */\n  getNodes() {\n    let nodes = [];\n    for (let node of this.AdjList.keys()) {\n      nodes.push(node);\n    }\n    return nodes;\n  }\n  printGraph() {\n    // get all the vertices\n    var get_keys = this.AdjList.keys();\n\n    // iterate over the vertices\n    for (let node of get_keys) {\n      let str = node.index + \": \";\n      //get all edges that contain that vertex\n      let edges = this.AdjList.get(node);\n      //iterate over all these edges\n      for (let e of edges) {\n        str += e.other(node).index + \" (w: \" + e.weight + \")  \";\n      }\n      console.log(str);\n    }\n  }\n}\n\n/*\n// Using the above implemented graph class\nvar g = new Graph(6);\nvar vertices = [ new Node(1,1,1), new Node(2,2,2), new Node(3,3,3) ];\n \n// adding vertices\nfor (var i = 0; i < vertices.length; i++) {\n    g.addVertex(vertices[i]);\n}\n \n// adding edges\ng.addEdge(vertices[0], vertices[1], 2);\ng.addEdge(vertices[0], vertices[2], 3);\n \n// prints all vertex and\n// its adjacency list\ng.printGraph();\n\n*/","map":{"version":3,"names":["Edge","Graph","constructor","V","E","AdjList","Map","addVertex","v","set","addEdge","w","weight","undefined","e","get","push","addEdgeFromEdge","edge","either","other","getEdges","edgeList","nodes","keys","node","edges","index","removeAllEdges","newMap","removeEdge","v1","v2","findEdge","splice","indexOf","node1","node2","getNeighbors","out","getNodes","printGraph","get_keys","str","console","log"],"sources":["/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/Graph.js"],"sourcesContent":["import {Edge} from './Edge.js'; \n\nexport class Graph {\n    constructor(V) {\n        this.V = V;\n        this.E = 0;\n        this.AdjList = new Map();\n    }\n\n    /**\n     * \n     * @param {Node} v \n     */\n    addVertex(v) {\n        this.AdjList.set(v, []);\n        this.V++;\n    }\n\n    /**\n     * \n     * @param {Node} v \n     * @param {Node} w \n     * @param {double} weight\n     */\n    addEdge(v, w, weight) {\n        if (weight == undefined)\n            throw 'weight is undefined';\n        let e = new Edge(v, w, weight); \n        this.AdjList.get(v).push(e);\n        this.AdjList.get(w).push(e);\n        this.E++;\n    }\n\n    addEdgeFromEdge(edge) {\n        let v = edge.either();\n        let w = edge.other(v);\n        this.AdjList.get(v).push(edge);\n        this.AdjList.get(w).push(edge);\n        this.E++;\n    }\n\n    /**\n     * @returns {Edge[]} edges\n     */\n    getEdges() {\n        let edgeList = [];\n        let nodes = this.AdjList.keys();\n        // iterate over the vertices\n        for (let node of nodes) {\n            //get all edges that contain that vertex\n            let edges = this.AdjList.get(node);\n            //iterate over all these edges\n            for (let e of edges) {\n                if (node.index < e.other(node).index)\n                    edgeList.push(e);\n            }\n        }\n        return edgeList;\n    }\n\n    removeAllEdges() {\n        let newMap = new Map();\n        for (let node of this.AdjList) {\n            newMap.set(node, []);\n        }\n        this.AdjList = newMap;\n        this.E = 0;\n    }\n\n    removeEdge(v1, v2) {\n        let e = this.findEdge(v1, v2);\n        this.AdjList.get(v1).splice(this.AdjList.get(v1).indexOf(e), 1);\n        this.AdjList.get(v2).splice(this.AdjList.get(v2).indexOf(e), 1);\n    }\n\n    /**\n     * \n     * @param {Node} v1 \n     * @param {Node} v2 \n     * @returns \n     */\n    findEdge(v1, v2) {\n        let edges = this.getEdges();\n        for (let e of edges) {\n            let node1 = e.either();\n            let node2 = e.other(node1);\n            if (node1.index == v1.index && node2.index == v2.index || node2.index == v1.index && node1.index == v2.index)\n                return e; \n        }\n    }\n\n    getNeighbors(node) {\n        let out = [];\n        for (let edge of this.AdjList.get(node)) {\n            out.push(edge.other(node));\n        }\n        return out;\n    }\n\n    /**\n     * \n     * @returns {Node[]} nodes \n     */\n    getNodes() {\n        let nodes = [];\n        for (let node of this.AdjList.keys()) {\n            nodes.push(node);\n        }\n        return nodes;\n    }\n\n    printGraph() {\n        // get all the vertices\n        var get_keys = this.AdjList.keys();\n \n        // iterate over the vertices\n        for (let node of get_keys) {\n            let str = node.index  + \": \";\n            //get all edges that contain that vertex\n            let edges = this.AdjList.get(node);\n            //iterate over all these edges\n            for (let e of edges) {\n                str += e.other(node).index + \" (w: \" + e.weight + \")  \";\n            }\n            console.log(str);\n        }\n    }\n}\n\n\n/*\n// Using the above implemented graph class\nvar g = new Graph(6);\nvar vertices = [ new Node(1,1,1), new Node(2,2,2), new Node(3,3,3) ];\n \n// adding vertices\nfor (var i = 0; i < vertices.length; i++) {\n    g.addVertex(vertices[i]);\n}\n \n// adding edges\ng.addEdge(vertices[0], vertices[1], 2);\ng.addEdge(vertices[0], vertices[2], 3);\n \n// prints all vertex and\n// its adjacency list\ng.printGraph();\n\n*/"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { Graph } from './Graph.js';\nimport { Node } from './Node.js';\nimport { Edge } from './Edge.js';\nimport { Edmonds } from './Blossom.js';\nlet WIDTH = window.innerWidth; //\"static variables\" like in java\nlet HEIGHT = window.innerHeight * 3 / 5;\nlet speed = 5;\nlet startNode = new Node(WIDTH / 2, HEIGHT / 2, 0);\nlet count = 1; //count the nodes\nlet graph = new Graph(0);\nlet totalGraph = new Graph(0);\nlet startDefined = false;\nlet algo = \"Not Defined\";\nlet localSearch = \"Not defined\";\nlet isPlaying = true;\n// state is 0 if no path found yet\n// 1 if we already have a solution (that we might want to improve)\nlet state = 0;\nlet eulerCycle = [];\nconst sketch = p => {\n  let addingNodes = false;\n  let isRunning = false;\n  let clearingBoard = false;\n  //let algoFinished = false;\n  let setIsPlaying = p.setIsPlaying;\n  p.setup = () => {\n    p.createCanvas(WIDTH, HEIGHT);\n  };\n  p.windowResized = () => {\n    WIDTH = window.innerWidth;\n    HEIGHT = window.innerHeight * 3 / 5;\n    p.resizeCanvas(WIDTH, HEIGHT);\n  };\n  p.draw = async () => {\n    p.background(220);\n    //draw the nodes\n    //mouse position and already added nodes white\n    p.fill(\"#fff\");\n    p.circle(p.mouseX, p.mouseY, 10);\n    if (startDefined) {\n      let nodes = graph.getNodes();\n      for (let node of nodes) {\n        if (node.color) p.fill(node.color);else p.fill(\"#fff\");\n        p.circle(node.x, node.y, 10);\n      }\n      //draw edges \n      drawEdges(p);\n    }\n    //start node pink\n    p.fill(255, 0, 200);\n    p.circle(startNode.x, startNode.y, 10);\n\n    //if we did not find any solution yet, we will run a algorithm to find inital solution\n    if (state == 0) {\n      if (isRunning) {\n        setIsPlaying(true);\n        isPlaying = true;\n        isRunning = false;\n        switch (algo) {\n          case 'Nearest Insertion':\n            await insertion(\"nearest\");\n            break;\n          case 'Farthest Insertion':\n            await insertion(\"farthest\");\n            break;\n          case 'Nearest Neighbor':\n            await nearestNeighbor(startNode, new Array(graph.V).fill(false), false);\n            break;\n          case 'Nearest Neighbor Look Ahead (made up)':\n            await nearestNeighborImproved();\n            break;\n          case 'Brute Force':\n            await bruteForce(startNode, new Array(graph.V).fill(false), 0);\n            break;\n          case 'Cluster naively':\n            await clusterNaively();\n            break;\n          case 'Christofides':\n            await christofides();\n            break;\n          default:\n            isRunning = false;\n        }\n        setIsPlaying(false);\n        isPlaying = false;\n        state = 1;\n      }\n    }\n    if (state == 1) {\n      if (isRunning) {\n        setIsPlaying(true);\n        isRunning = false;\n        switch (localSearch) {\n          case '2-opt':\n            await twoOpt();\n            break;\n          default:\n          case '3-opt':\n            await threeOpt();\n            break;\n        }\n        setIsPlaying(false);\n        isPlaying = false;\n      }\n    }\n  };\n  function anyNodeHasNeighbors() {\n    return graph.E > 0;\n  }\n  function drawEdges(p) {\n    //displayNeihbors(startNode);\n    if (anyNodeHasNeighbors()) {\n      let edges = graph.getEdges();\n      for (let e of edges) {\n        if (e.color) {\n          p.stroke(e.color);\n        } else p.stroke('black');\n        let v1 = e.either();\n        let v2 = e.other(v1);\n        let x1 = v1.x;\n        let y1 = v1.y;\n        let x2 = v2.x;\n        let y2 = v2.y;\n        p.line(x1, y1, x2, y2);\n      }\n    }\n  }\n  function waitForIsPlaying() {\n    if (isPlaying) return;\n    return new Promise(resolve => {\n      const checkValue = () => {\n        if (isPlaying) {\n          resolve();\n        } else {\n          setTimeout(checkValue, 50);\n        }\n      };\n      checkValue();\n    });\n  }\n  function removeAllEdges() {\n    let tempGraph = new Graph(0);\n    for (let node of graph.getNodes()) tempGraph.addVertex(node);\n    graph = tempGraph;\n    totalGraph = new Graph(0);\n  }\n  p.mouseClicked = async () => {\n    if (addingNodes) addNodes(p);\n    //the algorithm updates the paths that p.draw() displays\n  };\n\n  /**\n   * Adding nodes to canvas\n   * @param {}\n   */\n  function addNodes(p) {\n    if (!startDefined) {\n      graph.addVertex(startNode);\n      startDefined = true;\n    }\n    p.loop();\n    //if Y is smaller than HEIGHT, the click was outside of canvas (probably on button) and the don't add\n    if (p.mouseY < HEIGHT && p.mouseY > 0) {\n      let node = new Node(p.mouseX, p.mouseY, count++);\n      graph.addVertex(node);\n    }\n  }\n\n  //this function \"sends\" data/additional parameters to our function. When ever the props change, the change is passed here\n  p.updateWithProps = function (newProps) {\n    if (newProps.removeEdges) {\n      removeAllEdges();\n      let nodes = graph.getNodes();\n      for (let node of nodes) {\n        node.color = '#fff';\n      }\n      state = 0;\n    }\n    setIsPlaying = newProps.setIsPlaying;\n    addingNodes = newProps.addingNodes;\n    isRunning = newProps.isRunning;\n    clearingBoard = newProps.clearinBoard;\n    isPlaying = newProps.isPlaying;\n    console.log(\"Updatung is pkaying to: \" + isPlaying);\n    if (clearingBoard) {\n      startNode = new Node(WIDTH / 2, HEIGHT / 2, 0, []);\n      count = 1; //count the nodes\n      graph = new Graph(0);\n      startDefined = false;\n      totalGraph = new Graph(0);\n      state = 0;\n    }\n    if (!newProps.algo !== algo) algo = newProps.algo;\n    if (!newProps.localSearch !== localSearch) localSearch = newProps.localSearch;\n    if (!newProps.speed !== speed) speed = newProps.speed;\n    if (speed == 0) speed = 1;\n    //whenever a prop changes we start the loop again (it's only stopped after the path got displayed)\n    p.loop();\n  };\n  /*\n      async function runAlgorithm() {\n        for (let i = 0; i < nodes.length; ++i) {\n          adj[i] = nodes[i];\n        }\n        adj[nodes.length] = nodes[0];\n      }\n  */\n\n  async function delay(time) {\n    return new Promise(resolve => setTimeout(resolve, time / speed));\n  }\n  function displayNodes() {\n    graph.printGraph();\n  }\n\n  /**\n   * Mode has to be \"nearest\" or \"farthest\" and decides\n   * whether we run nearestInsertion or farthestInsertion.\n   * @param {string} mode \n   */\n  async function insertion(mode) {\n    //add the startNode\n    let toAdd = startNode;\n    var included = new Array(graph.V).fill(false);\n    included[toAdd.index] = true;\n\n    //add the first node\n    let node = null;\n    switch (mode) {\n      case \"nearest\":\n        node = findNode(startNode, included, \"closest\");\n        break;\n      case \"farthest\":\n        node = findNode(startNode, included, \"farthest\");\n        break;\n      default:\n    }\n    addEdge(startNode, node, euclidDistance(startNode, node));\n    included[node.index] = true;\n    await delay(1000);\n\n    //the second node is inserted slightly different than the remaining ones\n    let arr = null;\n    switch (mode) {\n      case \"nearest\":\n        arr = findClosestOrFarthestToIncluded(included, \"closest\");\n        break;\n      case \"farthest\":\n        arr = findClosestOrFarthestToIncluded(included, \"farthest\");\n        break;\n      default:\n    }\n    let root = arr[0];\n    toAdd = arr[1];\n    let followUp = arr[2];\n    addEdge(root, toAdd, euclidDistance(root, toAdd));\n    addEdge(followUp, toAdd, euclidDistance(followUp, toAdd));\n    included[toAdd.index] = true;\n    await delay(1000);\n\n    //we know how many nodes well have to add, so for loop\n    for (let i = 0; i < graph.V - 3; ++i) {\n      let arr = null;\n      switch (mode) {\n        case \"nearest\":\n          arr = findClosestOrFarthestToIncluded(included, \"closest\");\n          break;\n        case \"farthest\":\n          arr = findClosestOrFarthestToIncluded(included, \"farthest\");\n          break;\n        default:\n      }\n      let root = arr[0];\n      let toAdd = arr[1];\n      let followUp = arr[2];\n      //remove edge between root and followUp\n      removeEdge(root, followUp);\n      //mark the three nodes\n      toAdd.color = \"#ae2a0d\";\n      root.color = \"#0f61e8\";\n      followUp.color = \"#0f61e8\";\n      await delay(1000);\n      //add edges\n      addEdge(root, toAdd, euclidDistance(root, toAdd));\n      await delay(400);\n      addEdge(toAdd, followUp, euclidDistance(toAdd, followUp));\n      included[toAdd.index] = true;\n      await delay(1000);\n      toAdd.color = \"#fff\";\n      root.color = \"#fff\";\n      followUp.color = \"#fff\";\n    }\n    //algoFinished = true;\n  }\n\n  /**\n   * \n   * @param {boolean[]} included \n   * @param {string} mode \n   * @returns \n   */\n  function findClosestOrFarthestToIncluded(included, mode) {\n    if (mode !== \"closest\" && mode !== \"farthest\") throw 'Invalid Input. Mode is: ' + mode + ' but has to be \"closest\" or \"farthest\"';\n    let curMinOrMax = Number.MAX_VALUE; //min\n    if (mode == \"farthest\") {\n      curMinOrMax = Number.MIN_VALUE; //max\n    }\n\n    let root = null;\n    let closestToRoot = null;\n\n    //iterating through all non - included nodes\n    let nonIncludedNodes = getNonIncludedNodes(included);\n    for (let node of nonIncludedNodes) {\n      //and find closest distance to included \n      let [closestDist, potentialRoot] = findClosestNode(node, getIncludedNodes(included));\n      //if that cloeset dist is greate than curMax, than the node is considered to be farther from included\n      if (mode == \"closest\") {\n        if (closestDist < curMinOrMax) {\n          curMinOrMax = closestDist;\n          root = potentialRoot;\n          closestToRoot = node;\n        }\n      }\n      if (mode == \"farthest\") {\n        if (closestDist > curMinOrMax) {\n          curMinOrMax = closestDist;\n          root = potentialRoot;\n          closestToRoot = node;\n        }\n      }\n    }\n    let rootEdges = graph.AdjList.get(root);\n    let firstRootNeighbor = rootEdges[0].other(root);\n    if (rootEdges.length == 1) return [root, closestToRoot, firstRootNeighbor];\n    let secondRootNeighbor = rootEdges[1].other(root);\n    let newDist1 = euclidDistance(closestToRoot, firstRootNeighbor);\n    let newDist2 = euclidDistance(closestToRoot, secondRootNeighbor);\n    let oldDist1 = euclidDistance(root, firstRootNeighbor);\n    let oldDist2 = euclidDistance(root, secondRootNeighbor);\n    if (newDist1 - oldDist1 < newDist2 - oldDist2) return [root, closestToRoot, firstRootNeighbor];\n    return [root, closestToRoot, secondRootNeighbor];\n  }\n\n  /**\n   * \n   * @param {Node} node \n   * @param {Node} nodes \n   * @returns [closestDist, closestNode]\n   */\n  function findClosestNode(node, nodes) {\n    let closestNode = null;\n    let closestDist = Number.MAX_VALUE;\n    for (let v of nodes) {\n      let dist = euclidDistance(node, v);\n      if (dist < closestDist) {\n        closestDist = dist;\n        closestNode = v;\n      }\n    }\n    return [closestDist, closestNode];\n  }\n  function removeEdge(node1, node2) {\n    graph.removeEdge(node1, node2);\n  }\n\n  /**\n   * Adds an edge between the node node1 and node2 that have to exist in the graph\n   * @param {Node} node1 \n   * @param {Node} node2\n   */\n  function addEdge(node1, node2, weight) {\n    if (node1.index == node2.index) throw 'nodes cannot be the same';\n    graph.addEdge(node1, node2, weight);\n  }\n\n  /**\n   * This function runs nearestNeigbor on the global graph, starting from\n   * curNode, only visiting non-included nodes (as given by the included array).\n   * The boolean value timeOnlyFromCurNode specifies whether the function returns the\n   * total travel time from startNode to startNode, or only from curNode to startNode.\n   * @param {Node} curNode \n   * @param {boolean[]} included \n   * @param {boolean} timeOnlyFromCurNode \n   * @returns \n   */\n  async function nearestNeighbor(curNode, included, timeOnlyFromCurNode) {\n    if (timeOnlyFromCurNode == undefined) timeOnlyFromCurNode = false;\n    let time = 0;\n    //algoFinished = false;\n    included[curNode.index] = true;\n    //adj.push(curNode);\n    let nonIncludedNodes = getNonIncludedNodes(included);\n    for (let i = 0; i < nonIncludedNodes.length; ++i) {\n      let node = findNode(curNode, included, \"closest\");\n      //add an edge between node and curNode\n      let weight = euclidDistance(node, curNode);\n      time += weight;\n      addEdge(node, curNode, weight);\n      curNode = node;\n      included[curNode.index] = true;\n\n      //adj.push(curNode);\n      await delay(300);\n    }\n    let weight = euclidDistance(curNode, startNode);\n    time += weight;\n    addEdge(curNode, startNode, weight);\n    await delay(300);\n    if (timeOnlyFromCurNode) return time;\n    return await calculateTravelTime();\n    //algoFinished = true;\n  }\n\n  async function calculateTravelTime(start) {\n    let time = 0;\n    let V = graph.V;\n    let included = new Array(V).fill(false);\n    included[startNode.index] = true;\n    let curNode = startNode;\n    //adding all nodes\n    for (let i = 0; i < graph.V - 1; ++i) {\n      let edgesToCurNode = graph.AdjList.get(curNode);\n      for (let edge of edgesToCurNode) {\n        let neighbor = edge.other(curNode);\n        if (!included[neighbor.index]) {\n          time += edge.weight;\n          included[neighbor.index] = true;\n          curNode = neighbor;\n          break;\n        }\n      }\n    }\n    let lastEdge = graph.findEdge(curNode, startNode);\n    time += lastEdge.weight;\n    return time;\n  }\n  function getNonIncludedNodes(included) {\n    let out = [];\n    for (let v of graph.getNodes()) {\n      if (!included[v.index]) out.push(v);\n    }\n    return out;\n  }\n  function getIncludedNodes(included) {\n    let out = [];\n    for (let v of graph.getNodes()) {\n      if (included[v.index]) out.push(v);\n    }\n    return out;\n  }\n\n  /**\n   * \n   * @param {Node} curNode \n   * @param {boolean[]} included \n   * @param {double} time \n   * @returns \n   */\n  async function bruteForce(curNode, included, time) {\n    included[curNode.index] = true;\n    let neighbors = getNonIncludedNodes(included);\n    if (neighbors.length == 0) {\n      let weight = euclidDistance(startNode, curNode);\n      addEdge(startNode, curNode, weight);\n      return time + weight;\n    }\n    let minTime = Number.MAX_VALUE;\n    let bestNeighbor = null;\n    for (let neighbor of neighbors) {\n      waitForIsPlaying();\n      let includedCopy = JSON.parse(JSON.stringify(included));\n      let tempGraph = copyGraph(graph);\n      addEdge(curNode, neighbor, euclidDistance(curNode, neighbor));\n      await delay(300);\n      let finishTime = await bruteForce(neighbor, includedCopy, time + euclidDistance(curNode, neighbor));\n      if (finishTime < minTime) {\n        minTime = finishTime;\n        bestNeighbor = neighbor;\n      }\n      graph = copyGraph(tempGraph);\n      await delay(300);\n    }\n    addEdge(curNode, bestNeighbor, euclidDistance(curNode, bestNeighbor));\n    await delay(400);\n    return bruteForce(bestNeighbor, included, time + euclidDistance(curNode, bestNeighbor));\n  }\n  async function nearestNeighborImproved() {\n    let curNode = startNode;\n    let included = new Array(graph.V).fill(false);\n    included[curNode.index] = true;\n    //in every iteration add one node\n    for (let i = 0; i < graph.V - 1; ++i) {\n      let min = Number.MAX_VALUE;\n      let potentialNextNode = null;\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      //iterate through all non-included nodes\n      for (let v of nonIncludedNodes) {\n        let tempGraph = copyGraph(graph);\n        let includedCopy = JSON.parse(JSON.stringify(included));\n        addEdge(curNode, v, euclidDistance(curNode, v));\n        let time = await nearestNeighbor(v, includedCopy, true);\n        time += euclidDistance(curNode, v);\n        delay(300);\n        if (time < min) {\n          potentialNextNode = v;\n          min = time;\n        }\n        graph = copyGraph(tempGraph);\n      }\n      addEdge(curNode, potentialNextNode, euclidDistance(curNode, potentialNextNode));\n      curNode = potentialNextNode;\n      included[curNode.index] = true;\n      await delay(300);\n    }\n    addEdge(curNode, startNode, euclidDistance(curNode, startNode));\n  }\n  function copyGraph(g) {\n    let newGraph = new Graph(0);\n    for (let node of g.getNodes()) {\n      newGraph.addVertex(node);\n    }\n    for (let edge of g.getEdges()) {\n      newGraph.addEdgeFromEdge(edge);\n    }\n    return newGraph;\n  }\n\n  /**\n   * This method finds the closest or farthets Node to curNode, \n   * that is not yet inclueded (true in the included array). The \n   * mode decides if we find closest or farthets and has to be\n   * \"closest\" or \"farthsest\".\n   * @param {*} curNode \n   * @param {*} included \n   * @param {string} mode\n   * @returns \n   */\n  function findNode(curNode, included, mode) {\n    if (mode !== \"closest\" && mode !== \"farthest\") throw 'Invalid Input. Mode is: ' + mode + ' but has to be \"closest\" or \"farthest\"';\n    let minOrMax = Number.MAX_VALUE; //min\n    if (mode == \"farthest\") minOrMax = Number.MIN_VALUE; //max\n    let curClosestOrFarthest = null;\n    for (let node of graph.getNodes()) {\n      if (included[node.index]) continue;\n      let dist = euclidDistance(curNode, node);\n      //let dist = graph.findEdge(curNode, node).weight;\n      if (mode == \"closest\") {\n        if (dist < minOrMax) {\n          minOrMax = dist;\n          curClosestOrFarthest = node;\n        }\n      } else {\n        if (dist > minOrMax) {\n          minOrMax = dist;\n          curClosestOrFarthest = node;\n        }\n      }\n    }\n    return curClosestOrFarthest;\n  }\n\n  /**\n   * \n   * @param {Node} node1 \n   * @param {Node} node2 \n   * @returns \n   */\n  function euclidDistance(node1, node2) {\n    if (!node1 || !node2) {\n      throw 'a node for dist does not exists';\n      return;\n    }\n    let result = (node1.x - node2.x) * (node1.x - node2.x) + (node1.y - node2.y) * (node1.y - node2.y);\n    return Math.sqrt(result);\n  }\n  async function christofides() {\n    await computeMST();\n    let nodesWithOddDegree = await getNodesWithOddDegree(graph);\n    for (var node of nodesWithOddDegree) {\n      node.color = \"#ae2a0d\";\n    }\n    // await delay(15000);\n    await findPerfectMatchingMinWeight(nodesWithOddDegree);\n    for (var node of nodesWithOddDegree) {\n      node.color = \"#fff\";\n    }\n    await findEulerianCycle();\n\n    // for (node of eulerCycle) {\n    //   console.log(node.index+  \"-\");\n    // }\n    let included = new Array(graph.V).fill(false);\n    var curNode = eulerCycle.pop();\n    var temp = curNode;\n    // we have to go back to this one in the end\n    var first = curNode;\n    included[curNode.index] = true;\n    while (eulerCycle.length > 0) {\n      curNode = eulerCycle.pop();\n      if (!included[curNode.index]) {\n        included[curNode.index] = true;\n        addEdge(temp, curNode, euclidDistance(temp, curNode));\n        temp = curNode;\n      }\n    }\n    addEdge(temp, first, euclidDistance(curNode, first));\n    // let edge = new Edge(nodesWithOddDegree[0], nodesWithOddDegree[1], euclidDistance(nodesWithOddDegree[0], nodesWithOddDegree[1]));\n    // //console.log('there are nodes with odd degree: ' + nodesWithOddDegree.length);\n    // edge.color = 255;\n    // graph.addEdgeFromEdge(edge);\n\n    for (var node of nodesWithOddDegree) {\n      node.color = \"#fff\";\n    }\n  }\n  async function findEulerianCycle() {\n    // Find a vertex with odd degree\n    let v = graph.getNodes()[0];\n    for (var node of graph.getNodes()) {\n      if (graph.getNeighbors(node).length % 2 == 1) {\n        v = node;\n        break;\n      }\n    }\n    // Print tour starting from oddv\n    await printEulerUtil(v);\n  }\n  async function printEulerUtil(v) {\n    eulerCycle.push(v);\n\n    //Print Euler tour starting from vertex u\n\n    // Recur for all the vertices adjacent to\n    // this vertex\n    for (let node of graph.getNeighbors(v)) {\n      await delay(500);\n      // If edge u-v is not removed and it's a\n      // valid next edge\n      if (await isValidNextEdge(v, node)) {\n        graph.removeEdge(v, node);\n        await printEulerUtil(node);\n        break;\n      }\n    }\n  }\n\n  // The function to check if edge u-v can be considered\n  // as next edge in Euler Tout\n  async function isValidNextEdge(u, v) {\n    // The edge u-v is valid in one of the following\n    // two cases:\n    // 1) If v is the only adjacent vertex of u\n    let count = graph.getNeighbors(u).length;\n    if (count == 1) return true;\n\n    // 2) If there are multiple adjacents, then u-v\n    //    is not a bridge\n    // Do following steps to check if u-v is a bridge\n\n    // 2.a) count of vertices reachable from u\n    let visited = new Array(graph.V);\n    visited.fill(false);\n    let count1 = await DFSCount(u, visited);\n\n    // 2.b) Remove edge (u, v) and after removing\n    // the edge, count vertices reachable from u\n    graph.removeEdge(u, v);\n    visited.fill(false);\n    let count2 = await DFSCount(u, visited);\n\n    // 2.c) Add the edge back to the graph\n    graph.addEdge(u, v, euclidDistance(u, v));\n    // 2.d) If count1 is greater, then edge (u, v)\n    // is a bridge\n    return count1 > count2 ? false : true;\n  }\n  async function DFSCount(v, visited) {\n    // Mark the current node as visited\n    visited[v.index] = true;\n    let count = 1;\n\n    // Recur for all vertices adjacent to this vertex\n\n    for (let node of graph.getNeighbors(v)) {\n      if (!visited[node.index]) count += await DFSCount(node, visited);\n    }\n    return count;\n    let nodesWithOddDegree = getNodesWithOddDegree(graph);\n    await findPerfectMatchingMinWeight();\n    let edge = new Edge(nodesWithOddDegree[0], nodesWithOddDegree[1], euclidDistance(nodesWithOddDegree[0], nodesWithOddDegree[1]));\n    //console.log('there are nodes with odd degree: ' + nodesWithOddDegree.length);\n    edge.color = 255;\n    graph.addEdgeFromEdge(edge);\n    //min-cost-max matching is harder than I thought...\n  }\n\n  /**\n   * \n   * @param {Node} {even number of nodes} \n   */\n  async function findPerfectMatchingMinWeight(nodes) {\n    var edmondsEdges = [];\n    for (var i = 0; i < nodes.length - 1; ++i) {\n      for (var j = i + 1; j < nodes.length; ++j) {\n        var v = nodes[i];\n        var w = nodes[j];\n        var weight = euclidDistance(v, w);\n        edmondsEdges.push([v.index, w.index, -weight]);\n      }\n    }\n    var edmonds = new Edmonds(edmondsEdges);\n    var result = edmonds.maxWeightMatching();\n    for (var i = 0; i < result.length; ++i) {\n      var indexV = i;\n      var indexW = result[i];\n      var v = graph.getNodes().find(node => node.index === indexV);\n      var w = graph.getNodes().find(node => node.index === indexW);\n      if (indexV < indexW) {\n        addEdge(v, w, euclidDistance(v, w));\n      }\n    }\n  }\n  function getNodesWithOddDegree(g) {\n    let out = [];\n    for (let node of g.getNodes()) {\n      if (g.getNeighbors(node).length % 2 == 1) {\n        out.push(node);\n      }\n    }\n    return out;\n  }\n\n  /**\n   * Computes MST from the global variable totalGraph, that we also initialize here\n   */\n  async function computeMST() {\n    //first fill total graph if not already done\n    fillTotalGraph();\n    let distTo = new Array(graph.V).fill(Number.MAX_VALUE);\n    let included = new Array(graph.V).fill(false);\n    distTo[startNode.index] = 0;\n    included[startNode.index] = true;\n    updateDistances(startNode, distTo);\n    //adding V nodes to MST\n    for (let i = 0; i < graph.V - 1; ++i) {\n      let node = shortestAddableNodeToIncluded(distTo, included);\n      let [weight, root] = findClosestNode(node, getIncludedNodes(included));\n      addEdge(root, node, weight);\n      included[node.index] = true;\n      updateDistances(node, distTo);\n      graph.printGraph();\n      await delay(300);\n    }\n  }\n  function updateDistances(node, distTo) {\n    let neighbors = totalGraph.getNeighbors(node);\n    neighbors.forEach(v => {\n      distTo[v.index] = totalGraph.findEdge(v, node).weight;\n    });\n  }\n\n  /**\n   * This function returns a node and the edge connecting this node\n   * with one that is included such that the weight is minimal.\n   * @param {double[]} distTo \n   * @param {boolean[]} included \n   */\n  function shortestAddableNodeToIncluded(distTo, included) {\n    let nonIncludedNodes = getNonIncludedNodes(included);\n    let closestDist = Number.MAX_VALUE;\n    let closestNode = null;\n    for (let node of nonIncludedNodes) {\n      if (distTo[node.index] < closestDist) {\n        closestDist = distTo[node.index];\n        closestNode = node;\n      }\n    }\n    return closestNode;\n  }\n\n  /**\n   * Creates a total graph (edges between all nodes)\n   */\n  function fillTotalGraph() {\n    if (totalGraph.V == 0) {\n      let nodes = graph.getNodes();\n      let allNodesAdded = false;\n      for (let i = 0; i < nodes.length; ++i) {\n        if (!allNodesAdded) totalGraph.addVertex(nodes[i]);\n        for (let j = i + 1; j < nodes.length; ++j) {\n          if (!allNodesAdded) totalGraph.addVertex(nodes[j]);\n          let weight = euclidDistance(nodes[i], nodes[j]);\n          let edge = new Edge(nodes[i], nodes[j], weight);\n          totalGraph.addEdgeFromEdge(edge);\n        }\n        if (!allNodesAdded) allNodesAdded = true;\n      }\n    }\n  }\n  function getPath() {\n    let path = [];\n    let visited = new Array(graph.V).fill(false);\n    let cur = startNode;\n    for (var i = 0; i < graph.V; ++i) {\n      path.push(cur);\n      visited[cur.index] = true;\n      // get both neighbors\n      var neighbors = graph.getNeighbors(cur);\n      cur = visited[neighbors[0].index] ? neighbors[1] : neighbors[0];\n    }\n    path.push(startNode);\n    // for (let node of path) {\n    //   console.log(node.index + \"-\");\n    // }\n    return path;\n  }\n  function getLength(path) {\n    let length = 0;\n    let n = path.length;\n    for (let i = 0; i < n - 1; ++i) {\n      length += euclidDistance(path[i], path[i + 1]);\n    }\n    return length;\n  }\n  async function do2Opt(path, i, j) {\n    path[i].color = \"#0f61e8\";\n    path[i + 1].color = \"#0f61e8\";\n    path[j].color = \"#0f61e8\";\n    path[j + 1].color = \"#0f61e8\";\n\n    // find out why not defined sometimes!\n    let oldEdge1 = graph.findEdge(path[i], path[i + 1]);\n    let oldEdge2 = graph.findEdge(path[j], path[j + 1]);\n    oldEdge1.color = \"#0f61e8\";\n    oldEdge2.color = \"#0f61e8\";\n    await delay(2000);\n    let newEdge1 = new Edge(path[i], path[j], euclidDistance(path[i], path[j]));\n    newEdge1.color = \"#ae2a0d\";\n    let newEdge2 = new Edge(path[i + 1], path[j + 1], euclidDistance(path[i + 1], path[j + 1]));\n    newEdge2.color = \"#ae2a0d\";\n    await delay(2000);\n    graph.addEdgeFromEdge(newEdge1);\n    graph.addEdgeFromEdge(newEdge2);\n    await delay(2000);\n    removeEdge(path[i], path[i + 1]);\n    removeEdge(path[j], path[j + 1]);\n    await delay(2000);\n    newEdge1.color = \"#000000\";\n    newEdge2.color = \"#000000\";\n    path[i].color = \"#fff\";\n    path[i + 1].color = \"#fff\";\n    path[j].color = \"#fff\";\n    path[j + 1].color = \"#fff\";\n    path[i].color = \"#fff\";\n    path[j + 1].color = \"#fff\";\n    path[j].color = \"#fff\";\n    path[i + 1].color = \"#fff\";\n  }\n  async function twoOpt() {\n    let foundImprovement = true;\n    let path = getPath();\n    let n = path.length;\n    while (foundImprovement) {\n      foundImprovement = false;\n      for (let i = 0; i < n - 2; i++) {\n        for (let j = i + 1; j < n - 1; j++) {\n          // first subtract new lengths\n          var gain = -euclidDistance(path[i], path[j]);\n          gain -= euclidDistance(path[i + 1], path[j + 1]);\n          // then add old lengths\n          gain += euclidDistance(path[i], path[i + 1]);\n          gain += euclidDistance(path[j], path[j + 1]);\n          // If old length is greater than new length\n          if (gain > 1e-4) {\n            await do2Opt(path, i, j);\n            // curLength -= gain;\n            foundImprovement = true;\n            path = getPath();\n          }\n          gain = 0;\n        }\n      }\n    }\n  }\n  async function threeOpt() {\n    let foundImprovement = true;\n    let path = getPath();\n    let n = path.length;\n    while (foundImprovement) {\n      foundImprovement = false;\n      for (let i = 0; i < n - 3; ++i) {\n        for (let j = i + 1; j < n - 2; ++j) {\n          for (let k = j + 1; k < n - 1; ++k) {\n            // first subtract new lengths\n            var gain = await gainOfBest3OptWiring(path, i, j, k);\n            // If old length is greater than new length\n            if (gain > 1e-4) {\n              // curLength -= gain;\n              foundImprovement = true;\n              path = getPath();\n            }\n            gain = 0;\n          }\n        }\n      }\n    }\n  }\n  async function gainOfBest3OptWiring(path, i, j, k) {\n    // (a,b) are one edge, (c,d) and (e,f)\n    let a = path[i];\n    let b = path[i + 1];\n    let c = path[j];\n    let d = path[j + 1];\n    let e = path[k];\n    let f = path[k + 1];\n\n    // this has good picture for all permutations: http://tsp-basics.blogspot.com/2017/03/3-opt-move.html \n    // a going to b\n    let w0 = [a, b, c, d, e, f]; //that is original wiring\n    let w1 = [a, b, c, e, d, f];\n    // a going to c\n    let w2 = [a, c, b, d, e, f];\n    let w3 = [a, c, b, e, d, f];\n    // a going to d\n    let w4 = [a, d, e, b, c, f];\n    let w5 = [a, d, e, c, b, f];\n    // a going to e\n    let w6 = [a, e, d, b, c, f];\n    let w7 = [a, e, d, c, b, f];\n    let alternativeOptions = [w1, w2, w3, w4, w5, w6, w7];\n    let shortestWiring = w0;\n    let originalLength = length3OptWiring(w0);\n    let shortestLength = originalLength;\n    for (let option of alternativeOptions) {\n      let length = length3OptWiring(option);\n      if (shortestLength > length) {\n        shortestLength = length;\n        shortestWiring = option;\n      }\n    }\n    if (originalLength > shortestLength) {\n      a.color = \"#0f61e8\";\n      b.color = \"#0f61e8\";\n      c.color = \"#0f61e8\";\n      d.color = \"#0f61e8\";\n      e.color = \"#0f61e8\";\n      f.color = \"#0f61e8\";\n      let oldEdge1 = graph.findEdge(a, b);\n      oldEdge1.color = \"#0f61e8\";\n      let oldEdge2 = graph.findEdge(c, d);\n      oldEdge2.color = \"#0f61e8\";\n      let oldEdge3 = graph.findEdge(e, f);\n      oldEdge3.color = \"#0f61e8\";\n      await delay(2000);\n      //color new edges and add them\n      let newEdge1 = new Edge(shortestWiring[0], shortestWiring[1], euclidDistance(shortestWiring[0], shortestWiring[1]));\n      let newEdge2 = new Edge(shortestWiring[2], shortestWiring[3], euclidDistance(shortestWiring[2], shortestWiring[3]));\n      let newEdge3 = new Edge(shortestWiring[4], shortestWiring[5], euclidDistance(shortestWiring[4], shortestWiring[5]));\n      newEdge1.color = \"#ae2a0d\";\n      newEdge2.color = \"#ae2a0d\";\n      newEdge3.color = \"#ae2a0d\";\n      graph.addEdgeFromEdge(newEdge1);\n      graph.addEdgeFromEdge(newEdge2);\n      graph.addEdgeFromEdge(newEdge3);\n      await delay(2000);\n      removeEdge(a, b);\n      removeEdge(c, d);\n      removeEdge(e, f);\n      await delay(1000);\n      newEdge1.color = \"#000000\";\n      newEdge2.color = \"#000000\";\n      newEdge3.color = \"#000000\";\n      a.color = \"#fff\";\n      b.color = \"#fff\";\n      c.color = \"#fff\";\n      d.color = \"#fff\";\n      e.color = \"#fff\";\n      f.color = \"#fff\";\n    }\n    return originalLength - shortestLength;\n  }\n  function length3OptWiring(wiring) {\n    let length = 0;\n    for (let i = 0; i < 6; i += 2) {\n      length += euclidDistance(wiring[i], wiring[i + 1]);\n    }\n    return length;\n  }\n\n  /**\n   * \n   * @param {number of clusters} k \n   */\n  async function clusterNaively(k) {\n    fillTotalGraph();\n    let nodesPerCluster = totalGraph.V / k;\n    let edges = totalGraph.getEdges();\n    edges.sort((e1, e2) => e1.weight >= e2.weight ? 1 : -1);\n    //add small edges to cluster, if it doesn't exceed its size (size is naively n/k)\n    for (let e of edges) {\n      await delay(1000);\n      let v1 = e.either();\n      let v2 = e.other(v1);\n      //case 1, both nodes not included\n      if (!v1.root && !v2.root) {\n        v2.root = v1;\n        v1.isRoot = true;\n        v1.children = 1;\n        addEdge(v1, v2, e.weight);\n        continue;\n      }\n      if (v1.isRoot && !v2.root || v1.root && !v2.root) {\n        if (v1.isRoot) {\n          if (v1.children + 1 < nodesPerCluster) {\n            v2.root = v1;\n            v1.children++;\n          }\n        } else {\n          v2.root = v1.root;\n          v1.root.children++;\n        }\n        addEdge(v1, v2, e.weight);\n        continue;\n      }\n      if (v2.isRoot && !v1.root || v2.root && !v1.root) {\n        if (v2.root.children + 1 < nodesPerCluster) {\n          v1.root = v2.root;\n          v2.root.children++;\n          addEdge(v1, v2, e.weight);\n        }\n        continue;\n      }\n      if (v1.root && v2.root) {\n        if (v1.root.children + 1 + v2.root + 1 < nodesPerCluster) {\n          let temp = v1.root.children + 1;\n          v1.root = v2.root;\n          v2.root.children += temp;\n          addEdge(v1, v2, e.weight);\n        }\n        continue;\n      }\n    }\n  }\n};\nexport default sketch;","map":{"version":3,"names":["Graph","Node","Edge","Edmonds","WIDTH","window","innerWidth","HEIGHT","innerHeight","speed","startNode","count","graph","totalGraph","startDefined","algo","localSearch","isPlaying","state","eulerCycle","sketch","p","addingNodes","isRunning","clearingBoard","setIsPlaying","setup","createCanvas","windowResized","resizeCanvas","draw","background","fill","circle","mouseX","mouseY","nodes","getNodes","node","color","x","y","drawEdges","insertion","nearestNeighbor","Array","V","nearestNeighborImproved","bruteForce","clusterNaively","christofides","twoOpt","threeOpt","anyNodeHasNeighbors","E","edges","getEdges","e","stroke","v1","either","v2","other","x1","y1","x2","y2","line","waitForIsPlaying","Promise","resolve","checkValue","setTimeout","removeAllEdges","tempGraph","addVertex","mouseClicked","addNodes","loop","updateWithProps","newProps","removeEdges","clearinBoard","console","log","delay","time","displayNodes","printGraph","mode","toAdd","included","index","findNode","addEdge","euclidDistance","arr","findClosestOrFarthestToIncluded","root","followUp","i","removeEdge","curMinOrMax","Number","MAX_VALUE","MIN_VALUE","closestToRoot","nonIncludedNodes","getNonIncludedNodes","closestDist","potentialRoot","findClosestNode","getIncludedNodes","rootEdges","AdjList","get","firstRootNeighbor","length","secondRootNeighbor","newDist1","newDist2","oldDist1","oldDist2","closestNode","v","dist","node1","node2","weight","curNode","timeOnlyFromCurNode","undefined","calculateTravelTime","start","edgesToCurNode","edge","neighbor","lastEdge","findEdge","out","push","neighbors","minTime","bestNeighbor","includedCopy","JSON","parse","stringify","copyGraph","finishTime","min","potentialNextNode","g","newGraph","addEdgeFromEdge","minOrMax","curClosestOrFarthest","result","Math","sqrt","computeMST","nodesWithOddDegree","getNodesWithOddDegree","findPerfectMatchingMinWeight","findEulerianCycle","pop","temp","first","getNeighbors","printEulerUtil","isValidNextEdge","u","visited","count1","DFSCount","count2","edmondsEdges","j","w","edmonds","maxWeightMatching","indexV","indexW","find","fillTotalGraph","distTo","updateDistances","shortestAddableNodeToIncluded","forEach","allNodesAdded","getPath","path","cur","getLength","n","do2Opt","oldEdge1","oldEdge2","newEdge1","newEdge2","foundImprovement","gain","k","gainOfBest3OptWiring","a","b","c","d","f","w0","w1","w2","w3","w4","w5","w6","w7","alternativeOptions","shortestWiring","originalLength","length3OptWiring","shortestLength","option","oldEdge3","newEdge3","wiring","nodesPerCluster","sort","e1","e2","isRoot","children"],"sources":["/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/sketch.js"],"sourcesContent":["import {Graph} from './Graph.js';\nimport {Node} from './Node.js';\nimport {Edge} from './Edge.js';\nimport {Edmonds} from './Blossom.js'; \n\nlet WIDTH = window.innerWidth; //\"static variables\" like in java\nlet HEIGHT = window.innerHeight *3/ 5;\nlet speed = 5; \n\nlet startNode = new Node(WIDTH / 2, HEIGHT / 2, 0);\nlet count = 1; //count the nodes\nlet graph = new Graph(0);\nlet totalGraph = new Graph(0);\nlet startDefined = false;\nlet algo = \"Not Defined\";\nlet localSearch = \"Not defined\";\nlet isPlaying = true;\n// state is 0 if no path found yet\n// 1 if we already have a solution (that we might want to improve)\nlet state = 0;\nlet eulerCycle = [];\n\nconst sketch = (p) => {\n\n  let addingNodes = false;\n  let isRunning = false;\n  let clearingBoard = false;\n  //let algoFinished = false;\n  let setIsPlaying = p.setIsPlaying;\n\n  p.setup = () => {\n    p.createCanvas(WIDTH, HEIGHT);\n  };\n\n  p.windowResized = () => {\n    WIDTH = window.innerWidth;\n    HEIGHT = window.innerHeight *3/5;\n    p.resizeCanvas(WIDTH, HEIGHT);\n  }\n\n  p.draw = async () => {\n    p.background(220);\n    //draw the nodes\n    //mouse position and already added nodes white\n    p.fill(\"#fff\");\n    p.circle(p.mouseX, p.mouseY, 10);\n    if (startDefined) {\n      let nodes = graph.getNodes();\n      for (let node of nodes) {\n        if (node.color)\n          p.fill(node.color);\n        else \n          p.fill(\"#fff\");\n        p.circle(node.x, node.y, 10);\n      }\n      //draw edges \n      drawEdges(p);\n    }\n     //start node pink\n     p.fill(255, 0, 200);\n     p.circle(startNode.x, startNode.y, 10);\n\n    //if we did not find any solution yet, we will run a algorithm to find inital solution\n    if (state == 0) {\n      if (isRunning) {\n        setIsPlaying(true);\n        isPlaying = true;\n        isRunning = false;\n        switch(algo) {\n          case 'Nearest Insertion':\n            await insertion(\"nearest\");\n            break;\n            case 'Farthest Insertion':\n              await insertion(\"farthest\");\n              break;\n            case 'Nearest Neighbor':\n              await nearestNeighbor(startNode, new Array(graph.V).fill(false), false);\n              break;\n            case 'Nearest Neighbor Look Ahead (made up)':\n              await nearestNeighborImproved();\n              break;\n            case 'Brute Force':\n              await bruteForce(startNode, new Array(graph.V).fill(false), 0);\n              break;\n            case 'Cluster naively':\n              await clusterNaively();\n              break;\n            case 'Christofides':\n              await christofides();\n              break;\n            default:\n              isRunning = false;\n        }\n        setIsPlaying(false);\n        isPlaying = false;\n        state = 1;\n      }\n    }\n    if (state == 1) {\n      if (isRunning) {\n        setIsPlaying(true);\n        isRunning = false;\n        switch (localSearch) {\n          case '2-opt':\n            await twoOpt();\n            break;\n          default:\n          case '3-opt':\n            await threeOpt();\n            break;\n          \n        }\n        setIsPlaying(false);\n        isPlaying = false;\n\n      }\n    }\n\n  };\n\n\n  function anyNodeHasNeighbors() {\n    return graph.E > 0;\n  }\n\n\n  function drawEdges(p) {\n    //displayNeihbors(startNode);\n    if (anyNodeHasNeighbors()) {\n      let edges = graph.getEdges();\n      for (let e of edges) {\n        if (e.color) {\n          p.stroke(e.color);\n        }\n        else \n          p.stroke('black');\n        let v1 = e.either();\n        let v2 = e.other(v1);\n        let x1 = v1.x;\n        let y1 = v1.y;\n        let x2 = v2.x;\n        let y2 = v2.y;\n        p.line(x1, y1, x2, y2);\n      }\n    }\n  }\n\n  function waitForIsPlaying() {\n    if (isPlaying)\n      return;\n    return new Promise((resolve) => {\n      const checkValue = () => {\n        if (isPlaying) {\n          resolve();\n        } else {\n          setTimeout(checkValue, 50);\n        }\n      };\n      checkValue();\n    });\n  }\n  \n\n  function removeAllEdges() {\n    let tempGraph = new Graph(0);\n    for (let node of graph.getNodes())\n      tempGraph.addVertex(node);\n    graph = tempGraph;\n    totalGraph = new Graph(0);\n  }\n\n\n  \n  p.mouseClicked = async () => {\n    if (addingNodes) \n      addNodes(p);\n    //the algorithm updates the paths that p.draw() displays\n  };\n\n  /**\n   * Adding nodes to canvas\n   * @param {}\n   */\n  function addNodes(p) {\n    if (!startDefined) {\n      graph.addVertex(startNode);\n      startDefined = true;\n    }\n    p.loop();\n    //if Y is smaller than HEIGHT, the click was outside of canvas (probably on button) and the don't add\n    if (p.mouseY < HEIGHT && p.mouseY > 0) {\n      let node = new Node(p.mouseX, p.mouseY, count++);\n      graph.addVertex(node);\n    }\n  }\n\n    //this function \"sends\" data/additional parameters to our function. When ever the props change, the change is passed here\n    p.updateWithProps = function (newProps) {\n      if (newProps.removeEdges) {\n        removeAllEdges();\n        let nodes = graph.getNodes();\n        for (let node of nodes) {\n          node.color = '#fff';\n        }\n        state = 0;\n      }\n      setIsPlaying = newProps.setIsPlaying;\n      addingNodes = newProps.addingNodes;\n      isRunning = newProps.isRunning;\n      clearingBoard = newProps.clearinBoard;\n      isPlaying = newProps.isPlaying;\n      console.log(\"Updatung is pkaying to: \" + isPlaying);\n      if (clearingBoard) {\n        startNode = new Node(WIDTH / 2, HEIGHT / 2, 0, []);\n        count = 1; //count the nodes\n        graph = new Graph(0);\n        startDefined = false;\n        totalGraph = new Graph(0);\n        state = 0;\n      }\n      if (!newProps.algo !== algo)\n        algo = newProps.algo;\n      if (!newProps.localSearch !== localSearch)\n        localSearch = newProps.localSearch;\n      if (!newProps.speed !== speed) \n        speed = newProps.speed;\n      if (speed == 0)\n        speed = 1;\n      //whenever a prop changes we start the loop again (it's only stopped after the path got displayed)\n      p.loop();\n    }\n/*\n    async function runAlgorithm() {\n      for (let i = 0; i < nodes.length; ++i) {\n        adj[i] = nodes[i];\n      }\n      adj[nodes.length] = nodes[0];\n    }\n*/\n\nasync function delay(time) {\n  return new Promise(resolve => setTimeout(resolve, time/speed));\n}\n    \n    \n    function displayNodes() {\n      graph.printGraph();\n    }\n\n    /**\n     * Mode has to be \"nearest\" or \"farthest\" and decides\n     * whether we run nearestInsertion or farthestInsertion.\n     * @param {string} mode \n     */\n    async function insertion(mode) {\n      //add the startNode\n      let toAdd = startNode;\n      var included = new Array(graph.V).fill(false);\n      included[toAdd.index] = true;\n\n      //add the first node\n      let node = null;\n      switch(mode) {\n        case \"nearest\":\n          node = findNode(startNode, included, \"closest\");\n          break;\n        case \"farthest\":\n          node = findNode(startNode, included, \"farthest\");\n          break;\n        default:\n\n      }\n      addEdge(startNode, node, euclidDistance(startNode, node));\n      included[node.index] = true;\n      await delay(1000);\n\n      //the second node is inserted slightly different than the remaining ones\n      let arr = null;\n      switch(mode) {\n        case \"nearest\":\n          arr = findClosestOrFarthestToIncluded(included, \"closest\");\n          break;\n        case \"farthest\":\n          arr = findClosestOrFarthestToIncluded(included, \"farthest\");\n          break;\n        default:\n      }\n      let root = arr[0];\n      toAdd = arr[1];\n      let followUp = arr[2];\n      addEdge(root, toAdd, euclidDistance(root, toAdd));\n      addEdge(followUp, toAdd, euclidDistance(followUp, toAdd));\n      included[toAdd.index] = true;\n      await delay(1000);\n\n      //we know how many nodes well have to add, so for loop\n      for (let i = 0; i< graph.V-3; ++i) {\n        let arr = null;\n        switch(mode) {\n          case \"nearest\":\n            arr = findClosestOrFarthestToIncluded(included, \"closest\");\n            break;\n          case \"farthest\":\n            arr = findClosestOrFarthestToIncluded(included, \"farthest\");\n            break;\n          default:\n\n        }\n        let root = arr[0];\n        let toAdd = arr[1];\n        let followUp = arr[2];\n        //remove edge between root and followUp\n        removeEdge(root, followUp);\n        //mark the three nodes\n        toAdd.color = \"#ae2a0d\";\n        root.color = \"#0f61e8\";\n        followUp.color = \"#0f61e8\";\n        await delay(1000);\n        //add edges\n        addEdge(root, toAdd, euclidDistance(root, toAdd));\n        await delay(400);\n        addEdge(toAdd, followUp, euclidDistance(toAdd, followUp)); \n        included[toAdd.index] = true;\n        await delay(1000);\n        toAdd.color = \"#fff\";\n        root.color = \"#fff\";\n        followUp.color = \"#fff\";\n      }\n      //algoFinished = true;\n    }\n\n    /**\n     * \n     * @param {boolean[]} included \n     * @param {string} mode \n     * @returns \n     */\n    function findClosestOrFarthestToIncluded(included, mode) {\n      if (mode !== \"closest\" && mode !== \"farthest\")\n        throw('Invalid Input. Mode is: ' + mode + ' but has to be \"closest\" or \"farthest\"');\n\n      let curMinOrMax = Number.MAX_VALUE; //min\n      if (mode == \"farthest\") {\n        curMinOrMax = Number.MIN_VALUE; //max\n      }\n      let root = null;\n      let closestToRoot = null;\n      \n      //iterating through all non - included nodes\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      for (let node of nonIncludedNodes) {\n        //and find closest distance to included \n        let [closestDist, potentialRoot] = findClosestNode(node, getIncludedNodes(included));\n        //if that cloeset dist is greate than curMax, than the node is considered to be farther from included\n        if (mode == \"closest\") {\n          if (closestDist < curMinOrMax) {\n            curMinOrMax = closestDist;\n            root = potentialRoot;\n            closestToRoot = node;\n          }\n        }\n        if (mode == \"farthest\") {\n          if (closestDist > curMinOrMax) {\n            curMinOrMax = closestDist;\n            root = potentialRoot;\n            closestToRoot = node;\n          }\n        }\n      }\n      let rootEdges = graph.AdjList.get(root);\n\n      let firstRootNeighbor = rootEdges[0].other(root);\n      if (rootEdges.length == 1)\n        return [root, closestToRoot, firstRootNeighbor];\n      let secondRootNeighbor =  rootEdges[1].other(root);\n      let newDist1 = euclidDistance(closestToRoot, firstRootNeighbor);\n      let newDist2 = euclidDistance(closestToRoot, secondRootNeighbor);\n      let oldDist1 = euclidDistance(root, firstRootNeighbor);\n      let oldDist2 = euclidDistance(root, secondRootNeighbor);\n\n      if (newDist1 - oldDist1 < newDist2 -oldDist2)\n        return [root, closestToRoot, firstRootNeighbor];\n      return [root, closestToRoot, secondRootNeighbor];\n    }\n\n    /**\n     * \n     * @param {Node} node \n     * @param {Node} nodes \n     * @returns [closestDist, closestNode]\n     */\n    function findClosestNode(node, nodes) {\n      let closestNode = null;\n      let closestDist = Number.MAX_VALUE;\n      for (let v of nodes) {\n        let dist = euclidDistance(node, v);\n        if (dist < closestDist) {\n          closestDist = dist;\n          closestNode = v;\n        }\n      }\n      return [closestDist, closestNode];\n    }\n\n    function removeEdge(node1, node2) {\n      graph.removeEdge(node1, node2);\n    }\n\n    /**\n     * Adds an edge between the node node1 and node2 that have to exist in the graph\n     * @param {Node} node1 \n     * @param {Node} node2\n     */\n    function addEdge (node1, node2, weight) {\n      if (node1.index == node2.index)\n        throw('nodes cannot be the same');\n      graph.addEdge(node1, node2, weight);\n    }\n    \n    /**\n     * This function runs nearestNeigbor on the global graph, starting from\n     * curNode, only visiting non-included nodes (as given by the included array).\n     * The boolean value timeOnlyFromCurNode specifies whether the function returns the\n     * total travel time from startNode to startNode, or only from curNode to startNode.\n     * @param {Node} curNode \n     * @param {boolean[]} included \n     * @param {boolean} timeOnlyFromCurNode \n     * @returns \n     */\n    async function nearestNeighbor(curNode, included, timeOnlyFromCurNode) {\n      if (timeOnlyFromCurNode == undefined)\n        timeOnlyFromCurNode = false;\n      let time = 0;\n      //algoFinished = false;\n      included[curNode.index] = true;\n      //adj.push(curNode);\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      for (let i = 0; i < nonIncludedNodes.length; ++i) {\n        let node = findNode(curNode, included, \"closest\");\n        //add an edge between node and curNode\n        let weight = euclidDistance(node, curNode);\n        time += weight;\n        addEdge(node, curNode, weight);\n\n        curNode = node;\n        included[curNode.index] = true;\n\n        //adj.push(curNode);\n        await delay(300);\n      }\n      let weight = euclidDistance(curNode, startNode);\n      time += weight;\n      addEdge(curNode, startNode, weight);\n      await delay(300);\n      if (timeOnlyFromCurNode)\n        return time;\n      return await calculateTravelTime();\n      //algoFinished = true;\n    }\n\n    \n    async function calculateTravelTime(start) {\n      let time = 0;\n      let V = graph.V;\n      let included = new Array(V).fill(false);\n      included[startNode.index] = true;\n      let curNode = startNode;\n      //adding all nodes\n      for (let i = 0; i<graph.V-1; ++i) {\n        let edgesToCurNode = graph.AdjList.get(curNode);\n        for (let edge of edgesToCurNode) {\n          let neighbor = edge.other(curNode);\n          if (!included[neighbor.index]) {\n            time += edge.weight;\n            included[neighbor.index] = true;\n            curNode = neighbor;\n            break;\n          }\n        }\n      }\n      let lastEdge = graph.findEdge(curNode, startNode);\n      time += lastEdge.weight;\n      return time;\n    }\n\n    function getNonIncludedNodes(included) {\n      let out = [];\n      for (let v of graph.getNodes()) {\n        if (!included[v.index])\n          out.push(v);\n      }\n      return out;\n    }\n\n    function getIncludedNodes(included) {\n      let out = [];\n      for (let v of graph.getNodes()) {\n        if (included[v.index])\n          out.push(v);\n      }\n      return out;\n    }\n\n    /**\n     * \n     * @param {Node} curNode \n     * @param {boolean[]} included \n     * @param {double} time \n     * @returns \n     */\n    async function bruteForce(curNode, included, time) {\n      included[curNode.index] = true;\n      let neighbors = getNonIncludedNodes(included);\n      if (neighbors.length == 0) {\n        let weight = euclidDistance(startNode, curNode);\n        addEdge(startNode, curNode, weight);\n        return time + weight;\n      }\n      let minTime = Number.MAX_VALUE;\n      let bestNeighbor = null;\n      for (let neighbor of neighbors) {\n        waitForIsPlaying();\n        let includedCopy = JSON.parse(JSON.stringify(included));\n        let tempGraph = copyGraph(graph);\n        addEdge(curNode, neighbor, euclidDistance(curNode, neighbor));\n        await delay(300);\n        let finishTime = await bruteForce(neighbor, includedCopy, time + euclidDistance(curNode, neighbor));\n        if (finishTime < minTime) {\n          minTime = finishTime;\n          bestNeighbor = neighbor;\n        }\n        graph = copyGraph(tempGraph);\n        await delay(300);\n      }\n      addEdge(curNode, bestNeighbor, euclidDistance(curNode, bestNeighbor));\n      await delay(400);\n      return bruteForce(bestNeighbor, included, time + euclidDistance(curNode, bestNeighbor));\n    }\n\n    async function nearestNeighborImproved() {\n      let curNode = startNode;\n      let included = new Array(graph.V).fill(false);\n      included[curNode.index] = true;\n      //in every iteration add one node\n      for (let i = 0; i<graph.V -1; ++i) {\n        let min = Number.MAX_VALUE;\n        let potentialNextNode = null;\n        let nonIncludedNodes = getNonIncludedNodes(included);\n        //iterate through all non-included nodes\n        for (let v of nonIncludedNodes) {\n          let tempGraph = copyGraph(graph);\n          let includedCopy = JSON.parse(JSON.stringify(included));\n          addEdge(curNode, v, euclidDistance(curNode, v));\n          let time = await nearestNeighbor(v, includedCopy, true);\n          time += euclidDistance(curNode, v);\n          delay(300);\n          if (time < min) {\n            potentialNextNode = v;\n            min = time;\n          }      \n          graph = copyGraph(tempGraph);\n        }\n        \n        addEdge(curNode, potentialNextNode, euclidDistance(curNode, potentialNextNode));\n        curNode = potentialNextNode;\n        included[curNode.index] = true;\n        await delay(300);\n      }\n      addEdge(curNode, startNode, euclidDistance(curNode, startNode));\n    }\n\n    function copyGraph(g) {\n      let newGraph = new Graph(0);\n      for (let node of g.getNodes()){\n        newGraph.addVertex(node);\n      }\n      for (let edge of g.getEdges()) {\n        newGraph.addEdgeFromEdge(edge);\n      }\n      return newGraph;\n    }\n\n    /**\n     * This method finds the closest or farthets Node to curNode, \n     * that is not yet inclueded (true in the included array). The \n     * mode decides if we find closest or farthets and has to be\n     * \"closest\" or \"farthsest\".\n     * @param {*} curNode \n     * @param {*} included \n     * @param {string} mode\n     * @returns \n     */\n    function findNode(curNode, included, mode) {\n      if (mode !== \"closest\" && mode !== \"farthest\")\n        throw('Invalid Input. Mode is: ' + mode + ' but has to be \"closest\" or \"farthest\"');\n      let minOrMax = Number.MAX_VALUE; //min\n      if (mode == \"farthest\")\n        minOrMax = Number.MIN_VALUE; //max\n      let curClosestOrFarthest = null;\n      for (let node of graph.getNodes()) {\n        if (included[node.index])\n          continue;\n        let dist = euclidDistance(curNode, node);\n        //let dist = graph.findEdge(curNode, node).weight;\n        if (mode == \"closest\") {\n          if (dist < minOrMax) {\n            minOrMax = dist;\n            curClosestOrFarthest = node;\n          }\n        }\n        else {\n          if (dist > minOrMax) {\n            minOrMax = dist;\n            curClosestOrFarthest = node;\n          }\n        }\n      }\n      return curClosestOrFarthest;\n    }\n\n    /**\n     * \n     * @param {Node} node1 \n     * @param {Node} node2 \n     * @returns \n     */\n    function euclidDistance(node1, node2) {\n      if (!node1 || !node2) {\n        throw('a node for dist does not exists');\n        return\n      }\n      let result = (node1.x - node2.x) * (node1.x - node2.x) + (node1.y - node2.y) * (node1.y - node2.y);\n      return Math.sqrt(result);\n    }\n\n    async function christofides() {\n      await computeMST();\n\n\n      let nodesWithOddDegree = await getNodesWithOddDegree(graph);  \n\n      for (var node of nodesWithOddDegree) {\n        node.color = \"#ae2a0d\";\n      }\n      // await delay(15000);\n      await findPerfectMatchingMinWeight(nodesWithOddDegree);\n      for (var node of nodesWithOddDegree) {\n        node.color = \"#fff\";\n      }\n      await findEulerianCycle();\n    \n      // for (node of eulerCycle) {\n      //   console.log(node.index+  \"-\");\n      // }\n      let included = new Array(graph.V).fill(false);\n      var curNode = eulerCycle.pop();\n      var temp = curNode;\n      // we have to go back to this one in the end\n      var first = curNode;\n      included[curNode.index] = true;\n      while (eulerCycle.length > 0) {\n        curNode = eulerCycle.pop();\n        if (!included[curNode.index]) {\n          included[curNode.index] = true;\n          addEdge(temp, curNode, euclidDistance(temp, curNode));\n          temp = curNode;\n        }\n      }\n\n      addEdge(temp, first, euclidDistance(curNode, first));\n      // let edge = new Edge(nodesWithOddDegree[0], nodesWithOddDegree[1], euclidDistance(nodesWithOddDegree[0], nodesWithOddDegree[1]));\n      // //console.log('there are nodes with odd degree: ' + nodesWithOddDegree.length);\n      // edge.color = 255;\n      // graph.addEdgeFromEdge(edge);\n\n      for (var node of nodesWithOddDegree) {\n        node.color = \"#fff\";\n      }\n      \n    }\n\n    async function findEulerianCycle() {\n      // Find a vertex with odd degree\n      let v = graph.getNodes()[0];\n      for (var node of graph.getNodes()) {\n        if (graph.getNeighbors(node).length % 2== 1) {\n          v = node;\n          break;\n        }\n      }\n      // Print tour starting from oddv\n      await printEulerUtil(v);\n    \n    }\n\n    async function printEulerUtil(v) {\n      eulerCycle.push(v);\n\n      //Print Euler tour starting from vertex u\n    \n      // Recur for all the vertices adjacent to\n      // this vertex\n      for (let node of graph.getNeighbors(v)) {\n        await delay(500);\n        // If edge u-v is not removed and it's a\n        // valid next edge\n        if (await isValidNextEdge(v, node)) {\n          graph.removeEdge(v, node);\n          await printEulerUtil(node);\n          break;\n        }\n      }\n    }\n\n\n    // The function to check if edge u-v can be considered\n    // as next edge in Euler Tout\n    async function isValidNextEdge(u, v) {\n      // The edge u-v is valid in one of the following\n      // two cases:\n      // 1) If v is the only adjacent vertex of u\n      let count = graph.getNeighbors(u).length; \n      if (count == 1) \n        return true;\n\n      // 2) If there are multiple adjacents, then u-v\n      //    is not a bridge\n      // Do following steps to check if u-v is a bridge\n      \n      // 2.a) count of vertices reachable from u\n      let visited = new Array(graph.V);\n      visited.fill(false);\n      let count1 = await DFSCount(u, visited);\n      \n      // 2.b) Remove edge (u, v) and after removing\n      // the edge, count vertices reachable from u\n      graph.removeEdge(u, v);\n      visited.fill(false);\n      let count2 = await DFSCount(u, visited);\n\n      // 2.c) Add the edge back to the graph\n      graph.addEdge(u, v, euclidDistance(u, v));\n      // 2.d) If count1 is greater, then edge (u, v)\n      // is a bridge\n      return count1 > count2 ? false : true;\n    }\n\n\n    async function DFSCount(v, visited) {\n      // Mark the current node as visited\n      visited[v.index] = true;\n      let count = 1;\n      \n      // Recur for all vertices adjacent to this vertex\n      \n      for (let node of graph.getNeighbors(v)) {\n        if (!visited[node.index]) \n          count += await DFSCount(node, visited);\n      }\n      return count;\n      let nodesWithOddDegree = getNodesWithOddDegree(graph);  \n      await findPerfectMatchingMinWeight();\n      let edge = new Edge(nodesWithOddDegree[0], nodesWithOddDegree[1], euclidDistance(nodesWithOddDegree[0], nodesWithOddDegree[1]));\n      //console.log('there are nodes with odd degree: ' + nodesWithOddDegree.length);\n      edge.color = 255;\n      graph.addEdgeFromEdge(edge);\n      //min-cost-max matching is harder than I thought...\n      \n    }\n\n    /**\n     * \n     * @param {Node} {even number of nodes} \n     */\n    async function findPerfectMatchingMinWeight(nodes) {\n      var edmondsEdges = [];\n      for (var i = 0; i< nodes.length-1; ++i) {\n        for (var j = i+1; j < nodes.length; ++j) {\n          var v = nodes[i];\n          var w = nodes[j];\n          var weight = euclidDistance(v, w);\n          edmondsEdges.push([v.index, w.index, - weight])\n        }\n      }\n      var edmonds = new Edmonds(edmondsEdges);\n\n      var result = edmonds.maxWeightMatching();\n      \n\n      for (var i = 0; i < result.length; ++i) {\n        var indexV = i;\n        var indexW = result[i];\n        var v = graph.getNodes().find(node => node.index === indexV);\n        var w = graph.getNodes().find(node => node.index === indexW);\n        if (indexV < indexW) {\n          addEdge(v, w, euclidDistance(v, w));\n        }\n      }\n    } \n\n\n    function getNodesWithOddDegree(g) {\n      let out = [];\n      for (let node of g.getNodes()) {\n        if (g.getNeighbors(node).length % 2 == 1){\n          out.push(node);\n        }\n      }\n      return out;\n    }\n\n    /**\n     * Computes MST from the global variable totalGraph, that we also initialize here\n     */\n    async function computeMST() {\n      //first fill total graph if not already done\n      fillTotalGraph();\n      let distTo = new Array(graph.V).fill(Number.MAX_VALUE);\n      let included = new Array(graph.V).fill(false);\n      distTo[startNode.index] = 0;\n      included[startNode.index] = true;\n      updateDistances(startNode, distTo);\n      //adding V nodes to MST\n      for (let i = 0; i< graph.V-1; ++i) {\n        let node = shortestAddableNodeToIncluded(distTo, included);\n        let [weight, root] = findClosestNode(node, getIncludedNodes(included));\n        addEdge(root, node, weight);\n        included[node.index] = true;\n        updateDistances(node, distTo);\n        graph.printGraph();\n        await delay(300);\n      }\n    }\n\n    function updateDistances(node, distTo) {\n      let neighbors = totalGraph.getNeighbors(node);\n      neighbors.forEach(v => {\n        distTo[v.index] = totalGraph.findEdge(v, node).weight;\n      });\n    }\n\n    /**\n     * This function returns a node and the edge connecting this node\n     * with one that is included such that the weight is minimal.\n     * @param {double[]} distTo \n     * @param {boolean[]} included \n     */\n    function shortestAddableNodeToIncluded(distTo, included) {\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      let closestDist = Number.MAX_VALUE;\n      let closestNode = null;\n      for (let node of nonIncludedNodes) {\n        if (distTo[node.index] < closestDist) {\n          closestDist = distTo[node.index];\n          closestNode = node;\n        }\n      }\n      return closestNode;\n    }\n\n    /**\n     * Creates a total graph (edges between all nodes)\n     */\n    function fillTotalGraph() {\n      if (totalGraph.V == 0) {\n        let nodes = graph.getNodes();\n        let allNodesAdded = false;\n        for (let i = 0; i < nodes.length; ++i) {\n          if (!allNodesAdded)\n            totalGraph.addVertex(nodes[i]);\n          for (let j = i+1; j< nodes.length; ++j) {\n            if (!allNodesAdded) \n              totalGraph.addVertex(nodes[j]);\n            let weight = euclidDistance(nodes[i], nodes[j]);\n            let edge = new Edge(nodes[i], nodes[j], weight);\n            totalGraph.addEdgeFromEdge(edge);\n          }\n          if (!allNodesAdded) \n            allNodesAdded = true;\n        }\n      }\n    }\n\n    function getPath() {\n      let path = [];\n      let visited = new Array(graph.V).fill(false);\n      let cur = startNode;\n      for (var i = 0; i < graph.V; ++i) {\n        path.push(cur);\n        visited[cur.index] = true;\n        // get both neighbors\n        var neighbors = graph.getNeighbors(cur);\n        cur = visited[neighbors[0].index] ? neighbors[1] : neighbors[0]; \n      }\n      path.push(startNode);\n      // for (let node of path) {\n      //   console.log(node.index + \"-\");\n      // }\n      return path;\n    }\n\n    function getLength(path) {\n      let length = 0;\n      let n = path.length;\n      for (let i = 0; i < n-1; ++i) {\n        length += euclidDistance(path[i], path[i+1]);\n      }\n      return length;\n    }\n\n    async function do2Opt(path, i, j) {\n      path[i].color = \"#0f61e8\";\n      path[i+1].color = \"#0f61e8\";\n      path[j].color = \"#0f61e8\";\n      path[j+1].color = \"#0f61e8\";\n\n\n      // find out why not defined sometimes!\n      let oldEdge1 = graph.findEdge(path[i], path[i+1]);\n      let oldEdge2 = graph.findEdge(path[j], path[j+1]);\n      oldEdge1.color = \"#0f61e8\";\n      oldEdge2.color = \"#0f61e8\";\n      await delay(2000);\n      let newEdge1 = new Edge(path[i], path[j], euclidDistance(path[i], path[j]));\n      newEdge1.color = \"#ae2a0d\";\n      let newEdge2 = new Edge(path[i+1], path[j+1], euclidDistance(path[i+1], path[j+1]));\n      newEdge2.color = \"#ae2a0d\";\n      await delay(2000);\n      graph.addEdgeFromEdge(newEdge1);\n      graph.addEdgeFromEdge(newEdge2);\n      await delay(2000);\n      removeEdge(path[i], path[i+1]);\n      removeEdge(path[j], path[j+1]);\n      await delay(2000);\n      newEdge1.color = \"#000000\";\n      newEdge2.color = \"#000000\";\n\n\n      path[i].color = \"#fff\";\n      path[i+1].color = \"#fff\";\n      path[j].color = \"#fff\";\n      path[j+1].color = \"#fff\";\n\n      path[i].color = \"#fff\";\n      path[j+1].color = \"#fff\";\n      path[j].color = \"#fff\";\n      path[i+1].color = \"#fff\";\n\n\n    }\n\n\n    async function twoOpt() {\n      let foundImprovement = true;\n      let path = getPath();\n      let n = path.length;\n      while (foundImprovement) {\n        foundImprovement = false;\n        for (let i = 0; i < n - 2; i++) {\n          for (let j = i + 1; j < n-1; j++) {\n            // first subtract new lengths\n            var gain = -euclidDistance(path[i], path[j]);\n            gain -= euclidDistance(path[i+1], path[j+1]);\n            // then add old lengths\n            gain += euclidDistance(path[i], path[i+1]);\n            gain += euclidDistance(path[j], path[j+1]);\n            // If old length is greater than new length\n            if (gain > 1e-4) {\n              await do2Opt(path, i, j);\n              // curLength -= gain;\n              foundImprovement = true;\n              path = getPath();\n            }\n            gain = 0;\n          }\n        }\n      }\n    }\n\n    async function threeOpt() {\n      let foundImprovement = true;\n      let path = getPath();\n      let n = path.length;\n      while (foundImprovement) {\n        foundImprovement = false;\n        for (let i = 0; i < n - 3; ++i) {\n          for (let j = i + 1; j < n-2; ++j) {\n            for (let k = j+1; k < n-1; ++k) {\n              // first subtract new lengths\n              var gain = await gainOfBest3OptWiring(path, i, j, k);\n              // If old length is greater than new length\n              if (gain > 1e-4) {\n                // curLength -= gain;\n                foundImprovement = true;\n                path = getPath();\n              }\n              gain = 0;\n            }\n          }\n        }\n      }\n    }\n\n    async function gainOfBest3OptWiring(path, i, j, k) {\n      // (a,b) are one edge, (c,d) and (e,f)\n      let a = path[i];\n      let b = path[i+1];\n      let c  = path[j];\n      let d = path[j+1];\n      let e = path[k];\n      let f = path[k+1];\n\n      // this has good picture for all permutations: http://tsp-basics.blogspot.com/2017/03/3-opt-move.html \n      // a going to b\n      let w0 = [a, b, c, d, e, f]; //that is original wiring\n      let w1 = [a, b, c, e, d, f];\n      // a going to c\n      let w2 = [a, c, b, d, e, f];\n      let w3 = [a, c, b, e, d, f];\n      // a going to d\n      let w4 = [a, d, e, b, c, f];\n      let w5 = [a, d, e, c, b, f];\n      // a going to e\n      let w6 = [a, e, d, b, c, f];\n      let w7 = [a, e, d, c, b, f];\n      let alternativeOptions = [w1, w2, w3, w4, w5, w6, w7];\n      let shortestWiring = w0;\n      let originalLength = length3OptWiring(w0);\n      let shortestLength = originalLength;\n      for (let option of alternativeOptions) {\n        let length = length3OptWiring(option);\n        if (shortestLength > length) {\n          shortestLength = length;\n          shortestWiring = option;\n        }\n      }\n\n      if (originalLength > shortestLength) { \n        a.color = \"#0f61e8\";\n        b.color = \"#0f61e8\";\n        c.color = \"#0f61e8\";\n        d.color = \"#0f61e8\";\n        e.color = \"#0f61e8\";\n        f.color = \"#0f61e8\";\n        let oldEdge1 = graph.findEdge(a, b);\n        oldEdge1.color = \"#0f61e8\";\n        let oldEdge2 = graph.findEdge(c, d);\n        oldEdge2.color = \"#0f61e8\";\n        let oldEdge3 = graph.findEdge(e, f);\n        oldEdge3.color = \"#0f61e8\";\n        await delay(2000);\n        //color new edges and add them\n        let newEdge1 =new Edge(shortestWiring[0], shortestWiring[1], euclidDistance(shortestWiring[0], shortestWiring[1]));\n        let newEdge2 = new Edge(shortestWiring[2], shortestWiring[3], euclidDistance(shortestWiring[2], shortestWiring[3]));\n        let newEdge3 = new Edge(shortestWiring[4], shortestWiring[5], euclidDistance(shortestWiring[4], shortestWiring[5]));\n        newEdge1.color = \"#ae2a0d\";\n        newEdge2.color = \"#ae2a0d\";\n        newEdge3.color = \"#ae2a0d\";\n        graph.addEdgeFromEdge(newEdge1);\n        graph.addEdgeFromEdge(newEdge2);\n        graph.addEdgeFromEdge(newEdge3);\n        await delay(2000);\n        removeEdge(a, b);\n        removeEdge(c, d);\n        removeEdge(e, f);\n        await delay(1000);\n        newEdge1.color = \"#000000\";\n        newEdge2.color = \"#000000\";\n        newEdge3.color = \"#000000\";\n        a.color = \"#fff\";\n        b.color = \"#fff\";\n        c.color = \"#fff\";\n        d.color = \"#fff\";\n        e.color = \"#fff\";\n        f.color = \"#fff\";\n\n      }\n      \n      return originalLength - shortestLength;\n\n    }\n\n    function length3OptWiring(wiring) {\n      let length = 0;\n      for (let i = 0; i < 6; i+=2) {\n        length += euclidDistance(wiring[i], wiring[i+1]);\n      }\n      return length;\n    }\n\n    /**\n     * \n     * @param {number of clusters} k \n     */\n    async function clusterNaively(k) {\n      fillTotalGraph();\n      let nodesPerCluster = totalGraph.V/k;\n      let edges = totalGraph.getEdges();\n      edges.sort((e1, e2) => (e1.weight >= e2.weight) ? 1 : -1);\n      //add small edges to cluster, if it doesn't exceed its size (size is naively n/k)\n      for (let e of edges) {\n        await delay(1000);    \n        let v1 = e.either();\n        let v2 = e.other(v1);  \n        //case 1, both nodes not included\n        if (!v1.root && !v2.root) {\n          v2.root = v1;\n          v1.isRoot = true;\n          v1.children = 1;\n          addEdge(v1, v2, e.weight);\n          continue;\n        }\n        if (v1.isRoot && !v2.root || v1.root && !v2.root) {\n            if (v1.isRoot) {\n              if (v1.children + 1 < nodesPerCluster) {\n                v2.root = v1;\n                v1.children++;\n              }\n            }\n            else {\n              v2.root = v1.root; \n              v1.root.children++;\n            }\n            addEdge(v1, v2, e.weight);\n            continue;\n          }\n        if (v2.isRoot && !v1.root || v2.root && !v1.root) {\n          if (v2.root.children + 1 < nodesPerCluster) {\n            v1.root = v2.root;\n            v2.root.children++;\n            addEdge(v1, v2, e.weight);\n          }\n          continue;\n        }\n        if (v1.root && v2.root) {\n          if (v1.root.children + 1 + v2.root + 1 < nodesPerCluster) {\n            let temp = v1.root.children + 1;\n            v1.root = v2.root;\n            v2.root.children += temp;\n            addEdge(v1, v2, e.weight);\n          }\n          continue;\n        }\n      }\n\n    }\n\n    \n\n}\n\nexport default sketch;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
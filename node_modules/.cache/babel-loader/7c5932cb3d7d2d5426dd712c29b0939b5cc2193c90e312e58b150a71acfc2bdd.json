{"ast":null,"code":"import _slicedToArray from\"/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import _regeneratorRuntime from\"/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";import _createForOfIteratorHelper from\"/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import _asyncToGenerator from\"/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import{Graph}from'./Graph.js';import{Node}from'./Node.js';import{Edge}from'./Edge.js';var WIDTH=window.innerWidth;//\"static variables\" like in java\nvar HEIGHT=window.innerHeight*3/5;var speed=5;var startNode=new Node(WIDTH/2,HEIGHT/2,0);var count=1;//count the nodes\nvar graph=new Graph(0);var totalGraph=new Graph(0);var startDefined=false;var algo=\"Nearest Insertion\";var sketch=function sketch(p){var addingNodes=false;var isRunning=false;var clearingBoard=false;//let algoFinished = false;\np.setup=function(){p.createCanvas(WIDTH,HEIGHT);};p.windowResized=function(){WIDTH=window.innerWidth;HEIGHT=window.innerHeight*3/5;p.resizeCanvas(WIDTH,HEIGHT);};p.draw=/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(){var nodes,_iterator,_step,node;return _regeneratorRuntime().wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:p.background(220);//draw the nodes\n//mouse position and already added nodes white\np.fill(\"#fff\");p.circle(p.mouseX,p.mouseY,10);if(startDefined){nodes=graph.getNodes();_iterator=_createForOfIteratorHelper(nodes);try{for(_iterator.s();!(_step=_iterator.n()).done;){node=_step.value;if(node.color)p.fill(node.color);else p.fill(\"#fff\");p.circle(node.x,node.y,10);}//draw edges \n}catch(err){_iterator.e(err);}finally{_iterator.f();}drawEdges(p);}//start node pink\np.fill(255,0,200);p.circle(startNode.x,startNode.y,10);case 6:case\"end\":return _context.stop();}},_callee);}));function anyNodeHasNeighbors(){return graph.E>0;}function drawEdges(p){//displayNeihbors(startNode);\nif(anyNodeHasNeighbors()){var edges=graph.getEdges();var _iterator2=_createForOfIteratorHelper(edges),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var e=_step2.value;if(e.color){p.stroke(e.color);}else p.stroke('black');var v1=e.either();var v2=e.other(v1);var x1=v1.x;var y1=v1.y;var x2=v2.x;var y2=v2.y;p.line(x1,y1,x2,y2);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}}function removeAllEdges(){var tempGraph=new Graph(0);var _iterator3=_createForOfIteratorHelper(graph.getNodes()),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var node=_step3.value;tempGraph.addVertex(node);}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}graph=tempGraph;totalGraph=new Graph(0);}p.mouseClicked=/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(){return _regeneratorRuntime().wrap(function _callee2$(_context2){while(1)switch(_context2.prev=_context2.next){case 0:if(addingNodes)addNodes(p);//the algorithm updates the paths that p.draw() displays\nif(!isRunning){_context2.next=29;break;}isRunning=false;console.log(\"hi, cur algo is: \"+algo);_context2.t0=algo;_context2.next=_context2.t0==='Nearest Insertion'?7:_context2.t0==='Farthest Insertion'?10:_context2.t0==='Nearest Neighbor'?13:_context2.t0==='Nearest Neighbor Look Ahead (made up)'?16:_context2.t0==='Brute Force'?19:_context2.t0==='Cluster naively'?22:_context2.t0==='MST'?25:28;break;case 7:_context2.next=9;return insertion(\"nearest\");case 9:return _context2.abrupt(\"break\",29);case 10:_context2.next=12;return insertion(\"farthest\");case 12:return _context2.abrupt(\"break\",29);case 13:_context2.next=15;return nearestNeighbor(startNode,new Array(graph.V).fill(false),false);case 15:return _context2.abrupt(\"break\",29);case 16:_context2.next=18;return nearestNeighborImproved();case 18:return _context2.abrupt(\"break\",29);case 19:_context2.next=21;return bruteForce(startNode,new Array(graph.V).fill(false),0);case 21:return _context2.abrupt(\"break\",29);case 22:_context2.next=24;return clusterNaively();case 24:return _context2.abrupt(\"break\",29);case 25:_context2.next=27;return computeMST();case 27:return _context2.abrupt(\"break\",29);case 28:isRunning=false;case 29:isRunning=false;case 30:case\"end\":return _context2.stop();}},_callee2);}));/**\n   * Adding nodes to canvas\n   * @param {}\n   */function addNodes(p){if(!startDefined){graph.addVertex(startNode);startDefined=true;}p.loop();//if Y is smaller than HEIGHT, the click was outside of canvas (probably on button) and the don't add\nif(p.mouseY<HEIGHT){var node=new Node(p.mouseX,p.mouseY,count++);graph.addVertex(node);}}//this function \"sends\" data/additional parameters to our function. When ever the props change, the change is passed here\np.updateWithProps=function(newProps){if(!newProps.isRunning)removeAllEdges();addingNodes=newProps.addingNodes;isRunning=newProps.isRunning;clearingBoard=newProps.clearinBoard;if(clearingBoard){startNode=new Node(WIDTH/2,HEIGHT/2,0,[]);count=1;//count the nodes\ngraph=new Graph(0);startDefined=false;totalGraph=new Graph(0);}if(!newProps.algo!==algo)algo=newProps.algo;if(!newProps.speed!==speed)speed=newProps.speed;if(speed==0)speed=1;//whenever a prop changes we start the loop again (it's only stopped after the path got displayed)\np.loop();};/*\n    async function runAlgorithm() {\n      for (let i = 0; i < nodes.length; ++i) {\n        adj[i] = nodes[i];\n      }\n      adj[nodes.length] = nodes[0];\n    }\n*/function delay(_x){return _delay.apply(this,arguments);}function _delay(){_delay=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(time){return _regeneratorRuntime().wrap(function _callee3$(_context3){while(1)switch(_context3.prev=_context3.next){case 0:return _context3.abrupt(\"return\",new Promise(function(resolve){return setTimeout(resolve,time/speed);}));case 1:case\"end\":return _context3.stop();}},_callee3);}));return _delay.apply(this,arguments);}function displayNodes(){graph.printGraph();}/**\n     * Mode has to be \"nearest\" or \"farthest\" and decides\n     * whether we run nearestInsertion or farthestInsertion.\n     * @param {string} mode \n     */function insertion(_x2){return _insertion.apply(this,arguments);}/**\n     * \n     * @param {boolean[]} included \n     * @param {string} mode \n     * @returns \n     */function _insertion(){_insertion=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(mode){var toAdd,included,node,arr,root,followUp,i,_arr,_root,_toAdd,_followUp;return _regeneratorRuntime().wrap(function _callee4$(_context4){while(1)switch(_context4.prev=_context4.next){case 0://add the startNode\ntoAdd=startNode;included=new Array(graph.V).fill(false);included[toAdd.index]=true;//add the first node\nnode=null;_context4.t0=mode;_context4.next=_context4.t0===\"nearest\"?7:_context4.t0===\"farthest\"?9:11;break;case 7:node=findNode(startNode,included,\"closest\");return _context4.abrupt(\"break\",11);case 9:node=findNode(startNode,included,\"farthest\");return _context4.abrupt(\"break\",11);case 11:addEdge(startNode,node,euclidDistance(startNode,node));included[node.index]=true;_context4.next=15;return delay(1000);case 15://the second node is inserted slightly different than the remaining ones\narr=null;_context4.t1=mode;_context4.next=_context4.t1===\"nearest\"?19:_context4.t1===\"farthest\"?21:23;break;case 19:arr=findClosestOrFarthestToIncluded(included,\"closest\");return _context4.abrupt(\"break\",23);case 21:arr=findClosestOrFarthestToIncluded(included,\"farthest\");return _context4.abrupt(\"break\",23);case 23:root=arr[0];toAdd=arr[1];followUp=arr[2];addEdge(root,toAdd,euclidDistance(root,toAdd));addEdge(followUp,toAdd,euclidDistance(followUp,toAdd));included[toAdd.index]=true;_context4.next=31;return delay(1000);case 31:i=0;case 32:if(!(i<graph.V-3)){_context4.next=63;break;}_arr=null;_context4.t2=mode;_context4.next=_context4.t2===\"nearest\"?37:_context4.t2===\"farthest\"?39:41;break;case 37:_arr=findClosestOrFarthestToIncluded(included,\"closest\");return _context4.abrupt(\"break\",41);case 39:_arr=findClosestOrFarthestToIncluded(included,\"farthest\");return _context4.abrupt(\"break\",41);case 41:_root=_arr[0];_toAdd=_arr[1];_followUp=_arr[2];//remove edge between root and followUp\nremoveEdge(_root,_followUp);//mark the three nodes\n_toAdd.color=\"#ae2a0d\";_root.color=\"#0f61e8\";_followUp.color=\"#0f61e8\";_context4.next=50;return delay(1000);case 50://add edges\naddEdge(_root,_toAdd,euclidDistance(_root,_toAdd));_context4.next=53;return delay(400);case 53:addEdge(_toAdd,_followUp,euclidDistance(_toAdd,_followUp));included[_toAdd.index]=true;_context4.next=57;return delay(1000);case 57:_toAdd.color=\"#fff\";_root.color=\"#fff\";_followUp.color=\"#fff\";case 60:++i;_context4.next=32;break;case 63:case\"end\":return _context4.stop();}},_callee4);}));return _insertion.apply(this,arguments);}function findClosestOrFarthestToIncluded(included,mode){if(mode!==\"closest\"&&mode!==\"farthest\")throw'Invalid Input. Mode is: '+mode+' but has to be \"closest\" or \"farthest\"';var curMinOrMax=Number.MAX_VALUE;//min\nif(mode==\"farthest\"){curMinOrMax=Number.MIN_VALUE;//max\n}var root=null;var closestToRoot=null;//iterating through all non - included nodes\nvar nonIncludedNodes=getNonIncludedNodes(included);var _iterator4=_createForOfIteratorHelper(nonIncludedNodes),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var node=_step4.value;//and find closest distance to included \nvar _findClosestNode=findClosestNode(node,getIncludedNodes(included)),_findClosestNode2=_slicedToArray(_findClosestNode,2),closestDist=_findClosestNode2[0],potentialRoot=_findClosestNode2[1];//if that cloeset dist is greate than curMax, than the node is considered to be farther from included\nif(mode==\"closest\"){if(closestDist<curMinOrMax){curMinOrMax=closestDist;root=potentialRoot;closestToRoot=node;}}if(mode==\"farthest\"){if(closestDist>curMinOrMax){curMinOrMax=closestDist;root=potentialRoot;closestToRoot=node;}}}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}var rootEdges=graph.AdjList.get(root);var firstRootNeighbor=rootEdges[0].other(root);if(rootEdges.length==1)return[root,closestToRoot,firstRootNeighbor];var secondRootNeighbor=rootEdges[1].other(root);var newDist1=euclidDistance(closestToRoot,firstRootNeighbor);var newDist2=euclidDistance(closestToRoot,secondRootNeighbor);var oldDist1=euclidDistance(root,firstRootNeighbor);var oldDist2=euclidDistance(root,secondRootNeighbor);if(newDist1-oldDist1<newDist2-oldDist2)return[root,closestToRoot,firstRootNeighbor];return[root,closestToRoot,secondRootNeighbor];}/**\n     * \n     * @param {Node} node \n     * @param {Node} nodes \n     * @returns [closestDist, closestNode]\n     */function findClosestNode(node,nodes){var closestNode=null;var closestDist=Number.MAX_VALUE;var _iterator5=_createForOfIteratorHelper(nodes),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var v=_step5.value;var dist=euclidDistance(node,v);if(dist<closestDist){closestDist=dist;closestNode=v;}}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}return[closestDist,closestNode];}function removeEdge(node1,node2){graph.removeEdge(node1,node2);}/**\n     * Adds an edge between the node node1 and node2 that have to exist in the graph\n     * @param {Node} node1 \n     * @param {Node} node2\n     */function addEdge(node1,node2,weight){if(node1.index==node2.index)throw'nodes cannot be the same';graph.addEdge(node1,node2,weight);}/**\n     * This function runs nearestNeigbor on the global graph, starting from\n     * curNode, only visiting non-included nodes (as given by the included array).\n     * The boolean value timeOnlyFromCurNode specifies whether the function returns the\n     * total travel time from startNode to startNode, or only from curNode to startNode.\n     * @param {Node} curNode \n     * @param {boolean[]} included \n     * @param {boolean} timeOnlyFromCurNode \n     * @returns \n     */function nearestNeighbor(_x3,_x4,_x5){return _nearestNeighbor.apply(this,arguments);}function _nearestNeighbor(){_nearestNeighbor=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(curNode,included,timeOnlyFromCurNode){var time,nonIncludedNodes,i,node,_weight,weight;return _regeneratorRuntime().wrap(function _callee5$(_context5){while(1)switch(_context5.prev=_context5.next){case 0:if(timeOnlyFromCurNode==undefined)timeOnlyFromCurNode=false;time=0;//algoFinished = false;\nincluded[curNode.index]=true;//adj.push(curNode);\nnonIncludedNodes=getNonIncludedNodes(included);i=0;case 5:if(!(i<nonIncludedNodes.length)){_context5.next=17;break;}node=findNode(curNode,included,\"closest\");//add an edge between node and curNode\n_weight=euclidDistance(node,curNode);time+=_weight;addEdge(node,curNode,_weight);curNode=node;included[curNode.index]=true;//adj.push(curNode);\n_context5.next=14;return delay(300);case 14:++i;_context5.next=5;break;case 17:weight=euclidDistance(curNode,startNode);time+=weight;addEdge(curNode,startNode,weight);_context5.next=22;return delay(300);case 22:if(!timeOnlyFromCurNode){_context5.next=24;break;}return _context5.abrupt(\"return\",time);case 24:_context5.next=26;return calculateTravelTime();case 26:return _context5.abrupt(\"return\",_context5.sent);case 27:case\"end\":return _context5.stop();}},_callee5);}));return _nearestNeighbor.apply(this,arguments);}function calculateTravelTime(_x6){return _calculateTravelTime.apply(this,arguments);}function _calculateTravelTime(){_calculateTravelTime=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(start){var time,V,included,curNode,i,edgesToCurNode,_iterator13,_step13,edge,neighbor,lastEdge;return _regeneratorRuntime().wrap(function _callee6$(_context6){while(1)switch(_context6.prev=_context6.next){case 0:time=0;V=graph.V;included=new Array(V).fill(false);included[startNode.index]=true;curNode=startNode;//adding all nodes\ni=0;case 6:if(!(i<graph.V-1)){_context6.next=32;break;}edgesToCurNode=graph.AdjList.get(curNode);_iterator13=_createForOfIteratorHelper(edgesToCurNode);_context6.prev=9;_iterator13.s();case 11:if((_step13=_iterator13.n()).done){_context6.next=21;break;}edge=_step13.value;neighbor=edge.other(curNode);if(included[neighbor.index]){_context6.next=19;break;}time+=edge.weight;included[neighbor.index]=true;curNode=neighbor;return _context6.abrupt(\"break\",21);case 19:_context6.next=11;break;case 21:_context6.next=26;break;case 23:_context6.prev=23;_context6.t0=_context6[\"catch\"](9);_iterator13.e(_context6.t0);case 26:_context6.prev=26;_iterator13.f();return _context6.finish(26);case 29:++i;_context6.next=6;break;case 32:lastEdge=graph.findEdge(curNode,startNode);time+=lastEdge.weight;return _context6.abrupt(\"return\",time);case 35:case\"end\":return _context6.stop();}},_callee6,null,[[9,23,26,29]]);}));return _calculateTravelTime.apply(this,arguments);}function getNonIncludedNodes(included){var out=[];var _iterator6=_createForOfIteratorHelper(graph.getNodes()),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var v=_step6.value;if(!included[v.index])out.push(v);}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}return out;}function getIncludedNodes(included){var out=[];var _iterator7=_createForOfIteratorHelper(graph.getNodes()),_step7;try{for(_iterator7.s();!(_step7=_iterator7.n()).done;){var v=_step7.value;if(included[v.index])out.push(v);}}catch(err){_iterator7.e(err);}finally{_iterator7.f();}return out;}/**\n     * \n     * @param {Node} curNode \n     * @param {boolean[]} included \n     * @param {double} time \n     * @returns \n     */function bruteForce(_x7,_x8,_x9){return _bruteForce.apply(this,arguments);}function _bruteForce(){_bruteForce=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(curNode,included,time){var neighbors,weight,minTime,bestNeighbor,_iterator14,_step14,neighbor,includedCopy,tempGraph,finishTime;return _regeneratorRuntime().wrap(function _callee7$(_context7){while(1)switch(_context7.prev=_context7.next){case 0:included[curNode.index]=true;neighbors=getNonIncludedNodes(included);if(!(neighbors.length==0)){_context7.next=6;break;}weight=euclidDistance(startNode,curNode);addEdge(startNode,curNode,weight);return _context7.abrupt(\"return\",time+weight);case 6:minTime=Number.MAX_VALUE;bestNeighbor=null;_iterator14=_createForOfIteratorHelper(neighbors);_context7.prev=9;_iterator14.s();case 11:if((_step14=_iterator14.n()).done){_context7.next=27;break;}neighbor=_step14.value;includedCopy=JSON.parse(JSON.stringify(included));tempGraph=copyGraph(graph);addEdge(curNode,neighbor,euclidDistance(curNode,neighbor));_context7.next=18;return delay(300);case 18:_context7.next=20;return bruteForce(neighbor,includedCopy,time+euclidDistance(curNode,neighbor));case 20:finishTime=_context7.sent;if(finishTime<minTime){minTime=finishTime;bestNeighbor=neighbor;}graph=copyGraph(tempGraph);_context7.next=25;return delay(300);case 25:_context7.next=11;break;case 27:_context7.next=32;break;case 29:_context7.prev=29;_context7.t0=_context7[\"catch\"](9);_iterator14.e(_context7.t0);case 32:_context7.prev=32;_iterator14.f();return _context7.finish(32);case 35:addEdge(curNode,bestNeighbor,euclidDistance(curNode,bestNeighbor));_context7.next=38;return delay(400);case 38:return _context7.abrupt(\"return\",bruteForce(bestNeighbor,included,time+euclidDistance(curNode,bestNeighbor)));case 39:case\"end\":return _context7.stop();}},_callee7,null,[[9,29,32,35]]);}));return _bruteForce.apply(this,arguments);}function nearestNeighborImproved(){return _nearestNeighborImproved.apply(this,arguments);}function _nearestNeighborImproved(){_nearestNeighborImproved=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(){var curNode,included,i,min,potentialNextNode,nonIncludedNodes,_iterator15,_step15,v,tempGraph,includedCopy,time;return _regeneratorRuntime().wrap(function _callee8$(_context8){while(1)switch(_context8.prev=_context8.next){case 0:curNode=startNode;included=new Array(graph.V).fill(false);included[curNode.index]=true;//in every iteration add one node\ni=0;case 4:if(!(i<graph.V-1)){_context8.next=41;break;}min=Number.MAX_VALUE;potentialNextNode=null;nonIncludedNodes=getNonIncludedNodes(included);//iterate through all non-included nodes\n_iterator15=_createForOfIteratorHelper(nonIncludedNodes);_context8.prev=9;_iterator15.s();case 11:if((_step15=_iterator15.n()).done){_context8.next=25;break;}v=_step15.value;tempGraph=copyGraph(graph);includedCopy=JSON.parse(JSON.stringify(included));addEdge(curNode,v,euclidDistance(curNode,v));_context8.next=18;return nearestNeighbor(v,includedCopy,true);case 18:time=_context8.sent;time+=euclidDistance(curNode,v);delay(300);if(time<min){potentialNextNode=v;min=time;}graph=copyGraph(tempGraph);case 23:_context8.next=11;break;case 25:_context8.next=30;break;case 27:_context8.prev=27;_context8.t0=_context8[\"catch\"](9);_iterator15.e(_context8.t0);case 30:_context8.prev=30;_iterator15.f();return _context8.finish(30);case 33:addEdge(curNode,potentialNextNode,euclidDistance(curNode,potentialNextNode));curNode=potentialNextNode;included[curNode.index]=true;_context8.next=38;return delay(300);case 38:++i;_context8.next=4;break;case 41:addEdge(curNode,startNode,euclidDistance(curNode,startNode));case 42:case\"end\":return _context8.stop();}},_callee8,null,[[9,27,30,33]]);}));return _nearestNeighborImproved.apply(this,arguments);}function copyGraph(g){var newGraph=new Graph(0);var _iterator8=_createForOfIteratorHelper(g.getNodes()),_step8;try{for(_iterator8.s();!(_step8=_iterator8.n()).done;){var node=_step8.value;newGraph.addVertex(node);}}catch(err){_iterator8.e(err);}finally{_iterator8.f();}var _iterator9=_createForOfIteratorHelper(g.getEdges()),_step9;try{for(_iterator9.s();!(_step9=_iterator9.n()).done;){var edge=_step9.value;newGraph.addEdgeFromEdge(edge);}}catch(err){_iterator9.e(err);}finally{_iterator9.f();}return newGraph;}/**\n     * This method finds the closest or farthets Node to curNode, \n     * that is not yet inclueded (true in the included array). The \n     * mode decides if we find closest or farthets and has to be\n     * \"closest\" or \"farthsest\".\n     * @param {*} curNode \n     * @param {*} included \n     * @param {string} mode\n     * @returns \n     */function findNode(curNode,included,mode){if(mode!==\"closest\"&&mode!==\"farthest\")throw'Invalid Input. Mode is: '+mode+' but has to be \"closest\" or \"farthest\"';var minOrMax=Number.MAX_VALUE;//min\nif(mode==\"farthest\")minOrMax=Number.MIN_VALUE;//max\nvar curClosestOrFarthest=null;var _iterator10=_createForOfIteratorHelper(graph.getNodes()),_step10;try{for(_iterator10.s();!(_step10=_iterator10.n()).done;){var node=_step10.value;if(included[node.index])continue;var dist=euclidDistance(curNode,node);//let dist = graph.findEdge(curNode, node).weight;\nif(mode==\"closest\"){if(dist<minOrMax){minOrMax=dist;curClosestOrFarthest=node;}}else{if(dist>minOrMax){minOrMax=dist;curClosestOrFarthest=node;}}}}catch(err){_iterator10.e(err);}finally{_iterator10.f();}return curClosestOrFarthest;}/**\n     * \n     * @param {Node} node1 \n     * @param {Node} node2 \n     * @returns \n     */function euclidDistance(node1,node2){if(!node1||!node2){throw'a node for dist does not exists';return;}var result=(node1.x-node2.x)*(node1.x-node2.x)+(node1.y-node2.y)*(node1.y-node2.y);return Math.sqrt(result);}function christofides(){return _christofides.apply(this,arguments);}/**\n     * \n     * @param {Node} {even number of nodes} \n     */function _christofides(){_christofides=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(){var nodesWithOddDegree,edge;return _regeneratorRuntime().wrap(function _callee9$(_context9){while(1)switch(_context9.prev=_context9.next){case 0:_context9.next=2;return computeMST();case 2:nodesWithOddDegree=getNodesWithOddDegree(graph);_context9.next=5;return findPerfectMatchingMinWeight();case 5:edge=new Edge(nodesWithOddDegree[0],nodesWithOddDegree[1],euclidDistance(nodesWithOddDegree[0],nodesWithOddDegree[1]));//console.log('there are nodes with odd degree: ' + nodesWithOddDegree.length);\nedge.color=255;graph.addEdgeFromEdge(edge);//min-cost-max matching is harder than I thought...\ncase 8:case\"end\":return _context9.stop();}},_callee9);}));return _christofides.apply(this,arguments);}function findPerfectMatchingMinWeight(_x10){return _findPerfectMatchingMinWeight.apply(this,arguments);}function _findPerfectMatchingMinWeight(){_findPerfectMatchingMinWeight=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(nodes){return _regeneratorRuntime().wrap(function _callee10$(_context10){while(1)switch(_context10.prev=_context10.next){case 0:case\"end\":return _context10.stop();}},_callee10);}));return _findPerfectMatchingMinWeight.apply(this,arguments);}function getNodesWithOddDegree(g){var out=[];var _iterator11=_createForOfIteratorHelper(g.getNodes()),_step11;try{for(_iterator11.s();!(_step11=_iterator11.n()).done;){var node=_step11.value;if(g.getNeighbors(node).length%2==1){out.push(node);}}}catch(err){_iterator11.e(err);}finally{_iterator11.f();}return out;}/**\n     * Computes MST from the global variable totalGraph, that we also initialize here\n     */function computeMST(){return _computeMST.apply(this,arguments);}function _computeMST(){_computeMST=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(){var distTo,included,i,node,_findClosestNode3,_findClosestNode4,weight,root;return _regeneratorRuntime().wrap(function _callee11$(_context11){while(1)switch(_context11.prev=_context11.next){case 0://first fill total graph if not already done\nfillTotalGraph();distTo=new Array(graph.V).fill(Number.MAX_VALUE);included=new Array(graph.V).fill(false);distTo[startNode.index]=0;included[startNode.index]=true;updateDistances(startNode,distTo);//adding V nodes to MST\ni=0;case 7:if(!(i<graph.V-1)){_context11.next=18;break;}node=shortestAddableNodeToIncluded(distTo,included);_findClosestNode3=findClosestNode(node,getIncludedNodes(included)),_findClosestNode4=_slicedToArray(_findClosestNode3,2),weight=_findClosestNode4[0],root=_findClosestNode4[1];addEdge(root,node,weight);included[node.index]=true;updateDistances(node,distTo);_context11.next=15;return delay(300);case 15:++i;_context11.next=7;break;case 18:case\"end\":return _context11.stop();}},_callee11);}));return _computeMST.apply(this,arguments);}function updateDistances(node,distTo){var neighbors=totalGraph.getNeighbors(node);neighbors.forEach(function(v){distTo[v.index]=totalGraph.findEdge(v,node).weight;});}/**\n     * This function returns a node and the edge connecting this node\n     * with one that is included such that the weight is minimal.\n     * @param {double[]} distTo \n     * @param {boolean[]} included \n     */function shortestAddableNodeToIncluded(distTo,included){var nonIncludedNodes=getNonIncludedNodes(included);var closestDist=Number.MAX_VALUE;var closestNode=null;var _iterator12=_createForOfIteratorHelper(nonIncludedNodes),_step12;try{for(_iterator12.s();!(_step12=_iterator12.n()).done;){var node=_step12.value;if(distTo[node.index]<closestDist){closestDist=distTo[node.index];closestNode=node;}}}catch(err){_iterator12.e(err);}finally{_iterator12.f();}return closestNode;}/**\n     * Creates a total graph (edges between all nodes)\n     */function fillTotalGraph(){if(totalGraph.V==0){var nodes=graph.getNodes();var allNodesAdded=false;for(var i=0;i<nodes.length;++i){if(!allNodesAdded)totalGraph.addVertex(nodes[i]);for(var j=i+1;j<nodes.length;++j){if(!allNodesAdded)totalGraph.addVertex(nodes[j]);var weight=euclidDistance(nodes[i],nodes[j]);var edge=new Edge(nodes[i],nodes[j],weight);totalGraph.addEdgeFromEdge(edge);}if(!allNodesAdded)allNodesAdded=true;}}}/**\n     * \n     * @param {number of clusters} k \n     */function clusterNaively(_x11){return _clusterNaively.apply(this,arguments);}function _clusterNaively(){_clusterNaively=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(k){var nodesPerCluster,edges,_iterator16,_step16,e,v1,v2,temp;return _regeneratorRuntime().wrap(function _callee12$(_context12){while(1)switch(_context12.prev=_context12.next){case 0:fillTotalGraph();nodesPerCluster=totalGraph.V/k;edges=totalGraph.getEdges();edges.sort(function(e1,e2){return e1.weight>=e2.weight?1:-1;});//add small edges to cluster, if it doesn't exceed its size (size is naively n/k)\n_iterator16=_createForOfIteratorHelper(edges);_context12.prev=5;_iterator16.s();case 7:if((_step16=_iterator16.n()).done){_context12.next=34;break;}e=_step16.value;_context12.next=11;return delay(1000);case 11:v1=e.either();v2=e.other(v1);console.log(\"v1: \"+v1.index);console.log(\"v2: \"+v2.index);//case 1, both nodes not included\nif(!(!v1.root&&!v2.root)){_context12.next=22;break;}v2.root=v1;v1.isRoot=true;v1.children=1;addEdge(v1,v2,e.weight);console.log(\"v1 and v2 both had no root. Now children \"+v1.children);return _context12.abrupt(\"continue\",32);case 22:if(!(v1.isRoot&&!v2.root||v1.root&&!v2.root)){_context12.next=26;break;}if(v1.isRoot){if(v1.children+1<nodesPerCluster){v2.root=v1;v1.children++;}}else{v2.root=v1.root;v1.root.children++;}addEdge(v1,v2,e.weight);return _context12.abrupt(\"continue\",32);case 26:if(!(v2.isRoot&&!v1.root||v2.root&&!v1.root)){_context12.next=29;break;}if(v2.root.children+1<nodesPerCluster){v1.root=v2.root;v2.root.children++;addEdge(v1,v2,e.weight);}return _context12.abrupt(\"continue\",32);case 29:if(!(v1.root&&v2.root)){_context12.next=32;break;}if(v1.root.children+1+v2.root+1<nodesPerCluster){temp=v1.root.children+1;v1.root=v2.root;v2.root.children+=temp;addEdge(v1,v2,e.weight);}return _context12.abrupt(\"continue\",32);case 32:_context12.next=7;break;case 34:_context12.next=39;break;case 36:_context12.prev=36;_context12.t0=_context12[\"catch\"](5);_iterator16.e(_context12.t0);case 39:_context12.prev=39;_iterator16.f();return _context12.finish(39);case 42:case\"end\":return _context12.stop();}},_callee12,null,[[5,36,39,42]]);}));return _clusterNaively.apply(this,arguments);}};export default sketch;","map":{"version":3,"names":["Graph","Node","Edge","WIDTH","window","innerWidth","HEIGHT","innerHeight","speed","startNode","count","graph","totalGraph","startDefined","algo","sketch","p","addingNodes","isRunning","clearingBoard","setup","createCanvas","windowResized","resizeCanvas","draw","background","fill","circle","mouseX","mouseY","nodes","getNodes","node","color","x","y","drawEdges","anyNodeHasNeighbors","E","edges","getEdges","e","stroke","v1","either","v2","other","x1","y1","x2","y2","line","removeAllEdges","tempGraph","addVertex","mouseClicked","addNodes","console","log","insertion","nearestNeighbor","Array","V","nearestNeighborImproved","bruteForce","clusterNaively","computeMST","loop","updateWithProps","newProps","clearinBoard","delay","time","Promise","resolve","setTimeout","displayNodes","printGraph","mode","toAdd","included","index","findNode","addEdge","euclidDistance","arr","findClosestOrFarthestToIncluded","root","followUp","i","removeEdge","curMinOrMax","Number","MAX_VALUE","MIN_VALUE","closestToRoot","nonIncludedNodes","getNonIncludedNodes","findClosestNode","getIncludedNodes","closestDist","potentialRoot","rootEdges","AdjList","get","firstRootNeighbor","length","secondRootNeighbor","newDist1","newDist2","oldDist1","oldDist2","closestNode","v","dist","node1","node2","weight","curNode","timeOnlyFromCurNode","undefined","calculateTravelTime","start","edgesToCurNode","edge","neighbor","lastEdge","findEdge","out","push","neighbors","minTime","bestNeighbor","includedCopy","JSON","parse","stringify","copyGraph","finishTime","min","potentialNextNode","g","newGraph","addEdgeFromEdge","minOrMax","curClosestOrFarthest","result","Math","sqrt","christofides","nodesWithOddDegree","getNodesWithOddDegree","findPerfectMatchingMinWeight","getNeighbors","fillTotalGraph","distTo","updateDistances","shortestAddableNodeToIncluded","forEach","allNodesAdded","j","k","nodesPerCluster","sort","e1","e2","isRoot","children","temp"],"sources":["/home/thomas/Desktop/GIT_Projects/RouteOptimizationVisualizer/src/sketch.js"],"sourcesContent":["import {Graph} from './Graph.js';\nimport {Node} from './Node.js';\nimport {Edge} from './Edge.js';\n\nlet WIDTH = window.innerWidth; //\"static variables\" like in java\nlet HEIGHT = window.innerHeight *3/ 5;\nlet speed = 5; \n\nlet startNode = new Node(WIDTH / 2, HEIGHT / 2, 0);\nlet count = 1; //count the nodes\nlet graph = new Graph(0);\nlet totalGraph = new Graph(0);\nlet startDefined = false;\nlet algo = \"Nearest Insertion\";\n\nconst sketch = (p) => {\n\n  let addingNodes = false;\n  let isRunning = false;\n  let clearingBoard = false;\n  //let algoFinished = false;\n\n\n  p.setup = () => {\n    p.createCanvas(WIDTH, HEIGHT);\n  };\n\n  p.windowResized = () => {\n    WIDTH = window.innerWidth;\n    HEIGHT = window.innerHeight *3/5;\n    p.resizeCanvas(WIDTH, HEIGHT);\n  }\n\n  p.draw = async () => {\n    p.background(220);\n    //draw the nodes\n    //mouse position and already added nodes white\n    p.fill(\"#fff\");\n    p.circle(p.mouseX, p.mouseY, 10);\n    if (startDefined) {\n      let nodes = graph.getNodes();\n      for (let node of nodes) {\n        if (node.color)\n          p.fill(node.color);\n        else \n          p.fill(\"#fff\");\n        p.circle(node.x, node.y, 10);\n      }\n      //draw edges \n      drawEdges(p);\n    }\n     //start node pink\n     p.fill(255, 0, 200);\n     p.circle(startNode.x, startNode.y, 10);\n  };\n\n\n  function anyNodeHasNeighbors() {\n    return graph.E > 0;\n  }\n\n\n  function drawEdges(p) {\n    //displayNeihbors(startNode);\n    if (anyNodeHasNeighbors()) {\n      let edges = graph.getEdges();\n      for (let e of edges) {\n        if (e.color) {\n          p.stroke(e.color);\n        }\n        else \n          p.stroke('black');\n        let v1 = e.either();\n        let v2 = e.other(v1);\n        let x1 = v1.x;\n        let y1 = v1.y;\n        let x2 = v2.x;\n        let y2 = v2.y;\n        p.line(x1, y1, x2, y2);\n      }\n    }\n  }\n\n\n  function removeAllEdges() {\n    let tempGraph = new Graph(0);\n    for (let node of graph.getNodes())\n      tempGraph.addVertex(node);\n    graph = tempGraph;\n    totalGraph = new Graph(0);\n  }\n\n\n  \n  p.mouseClicked = async () => {\n    if (addingNodes) \n      addNodes(p);\n    //the algorithm updates the paths that p.draw() displays\n    if (isRunning) {\n      isRunning = false;\n\n      console.log(\"hi, cur algo is: \" + algo);\n      switch(algo) {\n        case 'Nearest Insertion':\n          await insertion(\"nearest\");\n          break;\n          case 'Farthest Insertion':\n            await insertion(\"farthest\");\n            break;\n          case 'Nearest Neighbor':\n            await nearestNeighbor(startNode, new Array(graph.V).fill(false), false);\n            break;\n          case 'Nearest Neighbor Look Ahead (made up)':\n            await nearestNeighborImproved();\n            break;\n          case 'Brute Force':\n            await bruteForce(startNode, new Array(graph.V).fill(false), 0);\n            break;\n          case 'Cluster naively':\n            await clusterNaively();\n            break;\n          case 'MST':\n            await computeMST();\n            break;\n          default:\n            isRunning = false;\n      }\n            //christofides();\n    }\n    isRunning = false;\n  };\n\n  /**\n   * Adding nodes to canvas\n   * @param {}\n   */\n  function addNodes(p) {\n    if (!startDefined) {\n      graph.addVertex(startNode);\n      startDefined = true;\n    }\n    p.loop();\n    //if Y is smaller than HEIGHT, the click was outside of canvas (probably on button) and the don't add\n    if (p.mouseY < HEIGHT) {\n      let node = new Node(p.mouseX, p.mouseY, count++);\n      graph.addVertex(node);\n    }\n  }\n\n    //this function \"sends\" data/additional parameters to our function. When ever the props change, the change is passed here\n    p.updateWithProps = function (newProps) {\n      if (!newProps.isRunning)\n        removeAllEdges();\n      addingNodes = newProps.addingNodes;\n      isRunning = newProps.isRunning;\n      clearingBoard = newProps.clearinBoard;\n      if (clearingBoard) {\n        startNode = new Node(WIDTH / 2, HEIGHT / 2, 0, []);\n        count = 1; //count the nodes\n        graph = new Graph(0);\n        startDefined = false;\n        totalGraph = new Graph(0);\n      }\n      if (!newProps.algo !== algo)\n        algo = newProps.algo;\n      if (!newProps.speed !== speed) \n        speed = newProps.speed;\n      if (speed == 0)\n        speed = 1;\n      //whenever a prop changes we start the loop again (it's only stopped after the path got displayed)\n      p.loop();\n    }\n/*\n    async function runAlgorithm() {\n      for (let i = 0; i < nodes.length; ++i) {\n        adj[i] = nodes[i];\n      }\n      adj[nodes.length] = nodes[0];\n    }\n*/\n\n    async function delay(time) {\n      return new Promise(resolve => setTimeout(resolve, time/speed));\n    }\n    \n    \n    function displayNodes() {\n      graph.printGraph();\n    }\n\n    /**\n     * Mode has to be \"nearest\" or \"farthest\" and decides\n     * whether we run nearestInsertion or farthestInsertion.\n     * @param {string} mode \n     */\n    async function insertion(mode) {\n      //add the startNode\n      let toAdd = startNode;\n      var included = new Array(graph.V).fill(false);\n      included[toAdd.index] = true;\n\n      //add the first node\n      let node = null;\n      switch(mode) {\n        case \"nearest\":\n          node = findNode(startNode, included, \"closest\");\n          break;\n        case \"farthest\":\n          node = findNode(startNode, included, \"farthest\");\n          break;\n        default:\n\n      }\n      addEdge(startNode, node, euclidDistance(startNode, node));\n      included[node.index] = true;\n      await delay(1000);\n\n      //the second node is inserted slightly different than the remaining ones\n      let arr = null;\n      switch(mode) {\n        case \"nearest\":\n          arr = findClosestOrFarthestToIncluded(included, \"closest\");\n          break;\n        case \"farthest\":\n          arr = findClosestOrFarthestToIncluded(included, \"farthest\");\n          break;\n        default:\n      }\n      let root = arr[0];\n      toAdd = arr[1];\n      let followUp = arr[2];\n      addEdge(root, toAdd, euclidDistance(root, toAdd));\n      addEdge(followUp, toAdd, euclidDistance(followUp, toAdd));\n      included[toAdd.index] = true;\n      await delay(1000);\n\n      //we know how many nodes well have to add, so for loop\n      for (let i = 0; i< graph.V-3; ++i) {\n        let arr = null;\n        switch(mode) {\n          case \"nearest\":\n            arr = findClosestOrFarthestToIncluded(included, \"closest\");\n            break;\n          case \"farthest\":\n            arr = findClosestOrFarthestToIncluded(included, \"farthest\");\n            break;\n          default:\n\n        }\n        let root = arr[0];\n        let toAdd = arr[1];\n        let followUp = arr[2];\n        //remove edge between root and followUp\n        removeEdge(root, followUp);\n        //mark the three nodes\n        toAdd.color = \"#ae2a0d\";\n        root.color = \"#0f61e8\";\n        followUp.color = \"#0f61e8\";\n        await delay(1000);\n        //add edges\n        addEdge(root, toAdd, euclidDistance(root, toAdd));\n        await delay(400);\n        addEdge(toAdd, followUp, euclidDistance(toAdd, followUp)); \n        included[toAdd.index] = true;\n        await delay(1000);\n        toAdd.color = \"#fff\";\n        root.color = \"#fff\";\n        followUp.color = \"#fff\";\n      }\n      //algoFinished = true;\n    }\n\n    /**\n     * \n     * @param {boolean[]} included \n     * @param {string} mode \n     * @returns \n     */\n    function findClosestOrFarthestToIncluded(included, mode) {\n      if (mode !== \"closest\" && mode !== \"farthest\")\n        throw('Invalid Input. Mode is: ' + mode + ' but has to be \"closest\" or \"farthest\"');\n\n      let curMinOrMax = Number.MAX_VALUE; //min\n      if (mode == \"farthest\") {\n        curMinOrMax = Number.MIN_VALUE; //max\n      }\n      let root = null;\n      let closestToRoot = null;\n      \n      //iterating through all non - included nodes\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      for (let node of nonIncludedNodes) {\n        //and find closest distance to included \n        let [closestDist, potentialRoot] = findClosestNode(node, getIncludedNodes(included));\n        //if that cloeset dist is greate than curMax, than the node is considered to be farther from included\n        if (mode == \"closest\") {\n          if (closestDist < curMinOrMax) {\n            curMinOrMax = closestDist;\n            root = potentialRoot;\n            closestToRoot = node;\n          }\n        }\n        if (mode == \"farthest\") {\n          if (closestDist > curMinOrMax) {\n            curMinOrMax = closestDist;\n            root = potentialRoot;\n            closestToRoot = node;\n          }\n        }\n      }\n      let rootEdges = graph.AdjList.get(root);\n\n      let firstRootNeighbor = rootEdges[0].other(root);\n      if (rootEdges.length == 1)\n        return [root, closestToRoot, firstRootNeighbor];\n      let secondRootNeighbor =  rootEdges[1].other(root);\n      let newDist1 = euclidDistance(closestToRoot, firstRootNeighbor);\n      let newDist2 = euclidDistance(closestToRoot, secondRootNeighbor);\n      let oldDist1 = euclidDistance(root, firstRootNeighbor);\n      let oldDist2 = euclidDistance(root, secondRootNeighbor);\n\n      if (newDist1 - oldDist1 < newDist2 -oldDist2)\n        return [root, closestToRoot, firstRootNeighbor];\n      return [root, closestToRoot, secondRootNeighbor];\n    }\n\n    /**\n     * \n     * @param {Node} node \n     * @param {Node} nodes \n     * @returns [closestDist, closestNode]\n     */\n    function findClosestNode(node, nodes) {\n      let closestNode = null;\n      let closestDist = Number.MAX_VALUE;\n      for (let v of nodes) {\n        let dist = euclidDistance(node, v);\n        if (dist < closestDist) {\n          closestDist = dist;\n          closestNode = v;\n        }\n      }\n      return [closestDist, closestNode];\n    }\n\n    function removeEdge(node1, node2) {\n      graph.removeEdge(node1, node2);\n    }\n\n    /**\n     * Adds an edge between the node node1 and node2 that have to exist in the graph\n     * @param {Node} node1 \n     * @param {Node} node2\n     */\n    function addEdge (node1, node2, weight) {\n      if (node1.index == node2.index)\n      throw('nodes cannot be the same');\n      graph.addEdge(node1, node2, weight);\n    }\n    \n    /**\n     * This function runs nearestNeigbor on the global graph, starting from\n     * curNode, only visiting non-included nodes (as given by the included array).\n     * The boolean value timeOnlyFromCurNode specifies whether the function returns the\n     * total travel time from startNode to startNode, or only from curNode to startNode.\n     * @param {Node} curNode \n     * @param {boolean[]} included \n     * @param {boolean} timeOnlyFromCurNode \n     * @returns \n     */\n    async function nearestNeighbor(curNode, included, timeOnlyFromCurNode) {\n      if (timeOnlyFromCurNode == undefined)\n        timeOnlyFromCurNode = false;\n      let time = 0;\n      //algoFinished = false;\n      included[curNode.index] = true;\n      //adj.push(curNode);\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      for (let i = 0; i < nonIncludedNodes.length; ++i) {\n        let node = findNode(curNode, included, \"closest\");\n        //add an edge between node and curNode\n        let weight = euclidDistance(node, curNode);\n        time += weight;\n        addEdge(node, curNode, weight);\n\n        curNode = node;\n        included[curNode.index] = true;\n\n        //adj.push(curNode);\n        await delay(300);\n      }\n      let weight = euclidDistance(curNode, startNode);\n      time += weight;\n      addEdge(curNode, startNode, weight);\n      await delay(300);\n      if (timeOnlyFromCurNode)\n        return time;\n      return await calculateTravelTime();\n      //algoFinished = true;\n    }\n\n    \n    async function calculateTravelTime(start) {\n      let time = 0;\n      let V = graph.V;\n      let included = new Array(V).fill(false);\n      included[startNode.index] = true;\n      let curNode = startNode;\n      //adding all nodes\n      for (let i = 0; i<graph.V-1; ++i) {\n        let edgesToCurNode = graph.AdjList.get(curNode);\n        for (let edge of edgesToCurNode) {\n          let neighbor = edge.other(curNode);\n          if (!included[neighbor.index]) {\n            time += edge.weight;\n            included[neighbor.index] = true;\n            curNode = neighbor;\n            break;\n          }\n        }\n      }\n      let lastEdge = graph.findEdge(curNode, startNode);\n      time += lastEdge.weight;\n      return time;\n    }\n\n    function getNonIncludedNodes(included) {\n      let out = [];\n      for (let v of graph.getNodes()) {\n        if (!included[v.index])\n          out.push(v);\n      }\n      return out;\n    }\n\n    function getIncludedNodes(included) {\n      let out = [];\n      for (let v of graph.getNodes()) {\n        if (included[v.index])\n          out.push(v);\n      }\n      return out;\n    }\n\n    /**\n     * \n     * @param {Node} curNode \n     * @param {boolean[]} included \n     * @param {double} time \n     * @returns \n     */\n    async function bruteForce(curNode, included, time) {\n      included[curNode.index] = true;\n      let neighbors = getNonIncludedNodes(included);\n      if (neighbors.length == 0) {\n        let weight = euclidDistance(startNode, curNode);\n        addEdge(startNode, curNode, weight);\n        return time + weight;\n      }\n      let minTime = Number.MAX_VALUE;\n      let bestNeighbor = null;\n      for (let neighbor of neighbors) {\n        let includedCopy = JSON.parse(JSON.stringify(included));\n        let tempGraph = copyGraph(graph);\n        addEdge(curNode, neighbor, euclidDistance(curNode, neighbor));\n        await delay(300);\n        let finishTime = await bruteForce(neighbor, includedCopy, time + euclidDistance(curNode, neighbor));\n        if (finishTime < minTime) {\n          minTime = finishTime;\n          bestNeighbor = neighbor;\n        }\n        graph = copyGraph(tempGraph);\n        await delay(300);\n      }\n      addEdge(curNode, bestNeighbor, euclidDistance(curNode, bestNeighbor));\n      await delay(400);\n      return bruteForce(bestNeighbor, included, time + euclidDistance(curNode, bestNeighbor));\n    }\n\n    async function nearestNeighborImproved() {\n      let curNode = startNode;\n      let included = new Array(graph.V).fill(false);\n      included[curNode.index] = true;\n      //in every iteration add one node\n      for (let i = 0; i<graph.V -1; ++i) {\n        let min = Number.MAX_VALUE;\n        let potentialNextNode = null;\n        let nonIncludedNodes = getNonIncludedNodes(included);\n        //iterate through all non-included nodes\n        for (let v of nonIncludedNodes) {\n          let tempGraph = copyGraph(graph);\n          let includedCopy = JSON.parse(JSON.stringify(included));\n          addEdge(curNode, v, euclidDistance(curNode, v));\n          let time = await nearestNeighbor(v, includedCopy, true);\n          time += euclidDistance(curNode, v);\n          delay(300);\n          if (time < min) {\n            potentialNextNode = v;\n            min = time;\n          }      \n          graph = copyGraph(tempGraph);\n        }\n        \n        addEdge(curNode, potentialNextNode, euclidDistance(curNode, potentialNextNode));\n        curNode = potentialNextNode;\n        included[curNode.index] = true;\n        await delay(300);\n      }\n      addEdge(curNode, startNode, euclidDistance(curNode, startNode));\n    }\n\n    function copyGraph(g) {\n      let newGraph = new Graph(0);\n      for (let node of g.getNodes()){\n        newGraph.addVertex(node);\n      }\n      for (let edge of g.getEdges()) {\n        newGraph.addEdgeFromEdge(edge);\n      }\n      return newGraph;\n    }\n\n    /**\n     * This method finds the closest or farthets Node to curNode, \n     * that is not yet inclueded (true in the included array). The \n     * mode decides if we find closest or farthets and has to be\n     * \"closest\" or \"farthsest\".\n     * @param {*} curNode \n     * @param {*} included \n     * @param {string} mode\n     * @returns \n     */\n    function findNode(curNode, included, mode) {\n      if (mode !== \"closest\" && mode !== \"farthest\")\n        throw('Invalid Input. Mode is: ' + mode + ' but has to be \"closest\" or \"farthest\"');\n      let minOrMax = Number.MAX_VALUE; //min\n      if (mode == \"farthest\")\n        minOrMax = Number.MIN_VALUE; //max\n      let curClosestOrFarthest = null;\n      for (let node of graph.getNodes()) {\n        if (included[node.index])\n          continue;\n        let dist = euclidDistance(curNode, node);\n        //let dist = graph.findEdge(curNode, node).weight;\n        if (mode == \"closest\") {\n          if (dist < minOrMax) {\n            minOrMax = dist;\n            curClosestOrFarthest = node;\n          }\n        }\n        else {\n          if (dist > minOrMax) {\n            minOrMax = dist;\n            curClosestOrFarthest = node;\n          }\n        }\n      }\n      return curClosestOrFarthest;\n    }\n\n    /**\n     * \n     * @param {Node} node1 \n     * @param {Node} node2 \n     * @returns \n     */\n    function euclidDistance(node1, node2) {\n      if (!node1 || !node2) {\n        throw('a node for dist does not exists');\n        return\n      }\n      let result = (node1.x - node2.x) * (node1.x - node2.x) + (node1.y - node2.y) * (node1.y - node2.y);\n      return Math.sqrt(result);\n    }\n\n    async function christofides() {\n      await computeMST();\n      let nodesWithOddDegree = getNodesWithOddDegree(graph);  \n      await findPerfectMatchingMinWeight();\n      let edge = new Edge(nodesWithOddDegree[0], nodesWithOddDegree[1], euclidDistance(nodesWithOddDegree[0], nodesWithOddDegree[1]));\n      //console.log('there are nodes with odd degree: ' + nodesWithOddDegree.length);\n      edge.color = 255;\n      graph.addEdgeFromEdge(edge);\n      //min-cost-max matching is harder than I thought...\n      \n    }\n\n    /**\n     * \n     * @param {Node} {even number of nodes} \n     */\n    async function findPerfectMatchingMinWeight(nodes) {\n\n\n    } \n\n    function getNodesWithOddDegree(g) {\n      let out = [];\n      for (let node of g.getNodes()) {\n        if (g.getNeighbors(node).length % 2 == 1){\n          out.push(node);\n        }\n      }\n      return out;\n    }\n\n    /**\n     * Computes MST from the global variable totalGraph, that we also initialize here\n     */\n    async function computeMST() {\n      //first fill total graph if not already done\n      fillTotalGraph();\n      let distTo = new Array(graph.V).fill(Number.MAX_VALUE);\n      let included = new Array(graph.V).fill(false);\n      distTo[startNode.index] = 0;\n      included[startNode.index] = true;\n      updateDistances(startNode, distTo);\n      //adding V nodes to MST\n      for (let i = 0; i< graph.V-1; ++i) {\n        let node = shortestAddableNodeToIncluded(distTo, included);\n        let [weight, root] = findClosestNode(node, getIncludedNodes(included));\n        addEdge(root, node, weight);\n        included[node.index] = true;\n        updateDistances(node, distTo);\n        await delay(300);\n      }\n    }\n\n    function updateDistances(node, distTo) {\n      let neighbors = totalGraph.getNeighbors(node);\n      neighbors.forEach(v => {\n        distTo[v.index] = totalGraph.findEdge(v, node).weight;\n      });\n    }\n\n    /**\n     * This function returns a node and the edge connecting this node\n     * with one that is included such that the weight is minimal.\n     * @param {double[]} distTo \n     * @param {boolean[]} included \n     */\n    function shortestAddableNodeToIncluded(distTo, included) {\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      let closestDist = Number.MAX_VALUE;\n      let closestNode = null;\n      for (let node of nonIncludedNodes) {\n        if (distTo[node.index] < closestDist) {\n          closestDist = distTo[node.index];\n          closestNode = node;\n        }\n      }\n      return closestNode;\n    }\n\n    /**\n     * Creates a total graph (edges between all nodes)\n     */\n    function fillTotalGraph() {\n      if (totalGraph.V == 0) {\n        let nodes = graph.getNodes();\n        let allNodesAdded = false;\n        for (let i = 0; i < nodes.length; ++i) {\n          if (!allNodesAdded)\n            totalGraph.addVertex(nodes[i]);\n          for (let j = i+1; j< nodes.length; ++j) {\n            if (!allNodesAdded) \n              totalGraph.addVertex(nodes[j]);\n            let weight = euclidDistance(nodes[i], nodes[j]);\n            let edge = new Edge(nodes[i], nodes[j], weight);\n            totalGraph.addEdgeFromEdge(edge);\n          }\n          if (!allNodesAdded) \n            allNodesAdded = true;\n        }\n      }\n    }\n\n    /**\n     * \n     * @param {number of clusters} k \n     */\n    async function clusterNaively(k) {\n      fillTotalGraph();\n      let nodesPerCluster = totalGraph.V/k;\n      let edges = totalGraph.getEdges();\n      edges.sort((e1, e2) => (e1.weight >= e2.weight) ? 1 : -1);\n      //add small edges to cluster, if it doesn't exceed its size (size is naively n/k)\n      for (let e of edges) {\n        await delay(1000);    \n        let v1 = e.either();\n        let v2 = e.other(v1);\n        console.log(\"v1: \" + v1.index);\n        console.log(\"v2: \" + v2.index);    \n        //case 1, both nodes not included\n        if (!v1.root && !v2.root) {\n          v2.root = v1;\n          v1.isRoot = true;\n          v1.children = 1;\n          addEdge(v1, v2, e.weight);\n          console.log(\"v1 and v2 both had no root. Now children \" + v1.children);\n          continue;\n        }\n        if (v1.isRoot && !v2.root || v1.root && !v2.root) {\n            if (v1.isRoot) {\n              if (v1.children + 1 < nodesPerCluster) {\n                v2.root = v1;\n                v1.children++;\n              }\n            }\n            else {\n              v2.root = v1.root; \n              v1.root.children++;\n            }\n            addEdge(v1, v2, e.weight);\n            continue;\n          }\n        if (v2.isRoot && !v1.root || v2.root && !v1.root) {\n          if (v2.root.children + 1 < nodesPerCluster) {\n            v1.root = v2.root;\n            v2.root.children++;\n            addEdge(v1, v2, e.weight);\n          }\n          continue;\n        }\n        if (v1.root && v2.root) {\n          if (v1.root.children + 1 + v2.root + 1 < nodesPerCluster) {\n            let temp = v1.root.children + 1;\n            v1.root = v2.root;\n            v2.root.children += temp;\n            addEdge(v1, v2, e.weight);\n          }\n          continue;\n        }\n      }\n\n    }\n\n}\n\nexport default sketch;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _slicedToArray from\"/home/thomas/Dev/RouteOptimizationVisualizer/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";import _regeneratorRuntime from\"/home/thomas/Dev/RouteOptimizationVisualizer/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";import _createForOfIteratorHelper from\"/home/thomas/Dev/RouteOptimizationVisualizer/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";import _asyncToGenerator from\"/home/thomas/Dev/RouteOptimizationVisualizer/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";import{Graph}from'./Graph.js';import{Node}from'./Node.js';import{Edge}from'./Edge.js';import{Edmonds}from'./Blossom.js';var WIDTH=window.innerWidth;//\"static variables\" like in java\nvar HEIGHT=window.innerHeight*3/5;var speed=5;var startNode=new Node(WIDTH/2,HEIGHT/2,0);var count=1;//count the nodes\nvar graph=new Graph(0);var totalGraph=new Graph(0);var startDefined=false;var algo=\"Not Defined\";var localSearch=\"Not defined\";var isPlaying=true;// state is 0 if no path found yet\n// 1 if we already have a solution (that we might want to improve)\nvar state=0;var eulerCycle=[];var sketch=function sketch(p){var addingNodes=false;var isRunning=false;var clearingBoard=false;//let algoFinished = false;\nvar setIsPlaying=p.setIsPlaying;p.setup=function(){p.createCanvas(WIDTH,HEIGHT);};p.windowResized=function(){WIDTH=window.innerWidth;HEIGHT=window.innerHeight*3/5;p.resizeCanvas(WIDTH,HEIGHT);};p.draw=/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(){var nodes,_iterator,_step,node;return _regeneratorRuntime().wrap(function _callee$(_context){while(1)switch(_context.prev=_context.next){case 0:p.background(220);//draw the nodes\n//mouse position and already added nodes white\np.fill(\"#fff\");p.circle(p.mouseX,p.mouseY,10);if(startDefined){nodes=graph.getNodes();_iterator=_createForOfIteratorHelper(nodes);try{for(_iterator.s();!(_step=_iterator.n()).done;){node=_step.value;if(node.color)p.fill(node.color);else p.fill(\"#fff\");p.circle(node.x,node.y,10);}//draw edges \n}catch(err){_iterator.e(err);}finally{_iterator.f();}drawEdges(p);}//start node pink\np.fill(255,0,200);p.circle(startNode.x,startNode.y,10);//if we did not find any solution yet, we will run a algorithm to find inital solution\nif(!(state==0)){_context.next=42;break;}if(!isRunning){_context.next=42;break;}console.log(\"Starting here\");isRunning=false;setIsPlaying(true);isPlaying=true;isRunning=false;_context.t0=algo;_context.next=_context.t0==='Nearest Insertion'?16:_context.t0==='Farthest Insertion'?19:_context.t0==='Nearest Neighbor'?22:_context.t0==='Nearest Neighbor Look Ahead (made up)'?25:_context.t0==='Brute Force'?28:_context.t0==='Cluster naively'?31:_context.t0==='Christofides'?34:37;break;case 16:_context.next=18;return insertion(\"nearest\");case 18:return _context.abrupt(\"break\",38);case 19:_context.next=21;return insertion(\"farthest\");case 21:return _context.abrupt(\"break\",38);case 22:_context.next=24;return nearestNeighbor(startNode,new Array(graph.V).fill(false),false);case 24:return _context.abrupt(\"break\",38);case 25:_context.next=27;return nearestNeighborImproved();case 27:return _context.abrupt(\"break\",38);case 28:_context.next=30;return bruteForce(startNode,new Array(graph.V).fill(false),0);case 30:return _context.abrupt(\"break\",38);case 31:_context.next=33;return clusterNaively();case 33:return _context.abrupt(\"break\",38);case 34:_context.next=36;return christofides();case 36:return _context.abrupt(\"break\",38);case 37:isRunning=false;case 38:setIsPlaying(false);isPlaying=false;isRunning=false;state=1;case 42:if(!(state==1)){_context.next=61;break;}if(!isRunning){_context.next=61;break;}console.log(\"Starting here\");isRunning=false;setIsPlaying(true);isPlaying=true;isRunning=false;_context.t1=localSearch;_context.next=_context.t1==='2-opt'?52:_context.t1==='3-opt'?55:55;break;case 52:_context.next=54;return twoOpt();case 54:return _context.abrupt(\"break\",58);case 55:_context.next=57;return threeOpt();case 57:return _context.abrupt(\"break\",58);case 58:setIsPlaying(false);isPlaying=false;isRunning=false;case 61:case\"end\":return _context.stop();}},_callee);}));function anyNodeHasNeighbors(){return graph.E>0;}function drawEdges(p){//displayNeihbors(startNode);\nif(anyNodeHasNeighbors()){var edges=graph.getEdges();var _iterator2=_createForOfIteratorHelper(edges),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var e=_step2.value;if(e.color){p.stroke(e.color);}else p.stroke('black');var v1=e.either();var v2=e.other(v1);var x1=v1.x;var y1=v1.y;var x2=v2.x;var y2=v2.y;p.line(x1,y1,x2,y2);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}}// async function waitForIsPlaying() {\n//   if (isPlaying)\n//     return;\n//   delay(1000);\n//   await waitForIsPlaying();\n// }\nfunction waitForIsPlaying(){return _waitForIsPlaying.apply(this,arguments);}function _waitForIsPlaying(){_waitForIsPlaying=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee3(){return _regeneratorRuntime().wrap(function _callee3$(_context3){while(1)switch(_context3.prev=_context3.next){case 0:return _context3.abrupt(\"return\",new Promise(function(resolve){function checkIsPlaying(){if(isPlaying){resolve();}else{setTimeout(checkIsPlaying,300);}}checkIsPlaying();}));case 1:case\"end\":return _context3.stop();}},_callee3);}));return _waitForIsPlaying.apply(this,arguments);}function removeAllEdges(){var tempGraph=new Graph(0);var _iterator3=_createForOfIteratorHelper(graph.getNodes()),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var node=_step3.value;tempGraph.addVertex(node);}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}graph=tempGraph;totalGraph=new Graph(0);}p.mouseClicked=/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(){return _regeneratorRuntime().wrap(function _callee2$(_context2){while(1)switch(_context2.prev=_context2.next){case 0:if(addingNodes)addNodes(p);//the algorithm updates the paths that p.draw() displays\ncase 1:case\"end\":return _context2.stop();}},_callee2);}));/**\n   * Adding nodes to canvas\n   * @param {}\n   */function addNodes(p){if(!startDefined){graph.addVertex(startNode);startDefined=true;}p.loop();//if Y is smaller than HEIGHT, the click was outside of canvas (probably on button) and the don't add\nif(p.mouseY<HEIGHT&&p.mouseY>0){var node=new Node(p.mouseX,p.mouseY,count++);graph.addVertex(node);}}//this function \"sends\" data/additional parameters to our function. When ever the props change, the change is passed here\np.updateWithProps=function(newProps){if(newProps.removeEdges){removeAllEdges();var nodes=graph.getNodes();var _iterator4=_createForOfIteratorHelper(nodes),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var node=_step4.value;node.color='#fff';}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}state=0;}setIsPlaying=newProps.setIsPlaying;addingNodes=newProps.addingNodes;isRunning=newProps.isRunning;clearingBoard=newProps.clearinBoard;isPlaying=newProps.isPlaying;if(clearingBoard){startNode=new Node(WIDTH/2,HEIGHT/2,0,[]);count=1;//count the nodes\ngraph=new Graph(0);startDefined=false;totalGraph=new Graph(0);state=0;}if(!newProps.algo!==algo)algo=newProps.algo;if(!newProps.localSearch!==localSearch)localSearch=newProps.localSearch;if(!newProps.speed!==speed)speed=newProps.speed;if(speed==0)speed=1;//whenever a prop changes we start the loop again (it's only stopped after the path got displayed)\np.loop();};/*\n    async function runAlgorithm() {\n      for (let i = 0; i < nodes.length; ++i) {\n        adj[i] = nodes[i];\n      }\n      adj[nodes.length] = nodes[0];\n    }\n*/function delay(_x){return _delay.apply(this,arguments);}function _delay(){_delay=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee4(time){return _regeneratorRuntime().wrap(function _callee4$(_context4){while(1)switch(_context4.prev=_context4.next){case 0:_context4.next=2;return waitForIsPlaying();case 2:return _context4.abrupt(\"return\",new Promise(function(resolve){return setTimeout(resolve,time/speed);}));case 3:case\"end\":return _context4.stop();}},_callee4);}));return _delay.apply(this,arguments);}function displayNodes(){graph.printGraph();}/**\n     * Mode has to be \"nearest\" or \"farthest\" and decides\n     * whether we run nearestInsertion or farthestInsertion.\n     * @param {string} mode \n     */function insertion(_x2){return _insertion.apply(this,arguments);}/**\n     * \n     * @param {boolean[]} included \n     * @param {string} mode \n     * @returns \n     */function _insertion(){_insertion=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee5(mode){var toAdd,included,node,arr,root,followUp,i,_arr,_root,_toAdd,_followUp;return _regeneratorRuntime().wrap(function _callee5$(_context5){while(1)switch(_context5.prev=_context5.next){case 0://add the startNode\ntoAdd=startNode;included=new Array(graph.V).fill(false);included[toAdd.index]=true;//add the first node\nnode=null;_context5.t0=mode;_context5.next=_context5.t0===\"nearest\"?7:_context5.t0===\"farthest\"?9:11;break;case 7:node=findNode(startNode,included,\"closest\");return _context5.abrupt(\"break\",11);case 9:node=findNode(startNode,included,\"farthest\");return _context5.abrupt(\"break\",11);case 11:addEdge(startNode,node,euclidDistance(startNode,node));included[node.index]=true;_context5.next=15;return delay(1000);case 15://the second node is inserted slightly different than the remaining ones\narr=null;_context5.t1=mode;_context5.next=_context5.t1===\"nearest\"?19:_context5.t1===\"farthest\"?21:23;break;case 19:arr=findClosestOrFarthestToIncluded(included,\"closest\");return _context5.abrupt(\"break\",23);case 21:arr=findClosestOrFarthestToIncluded(included,\"farthest\");return _context5.abrupt(\"break\",23);case 23:root=arr[0];toAdd=arr[1];followUp=arr[2];addEdge(root,toAdd,euclidDistance(root,toAdd));addEdge(followUp,toAdd,euclidDistance(followUp,toAdd));included[toAdd.index]=true;_context5.next=31;return delay(1000);case 31:i=0;case 32:if(!(i<graph.V-3)){_context5.next=65;break;}_context5.next=35;return waitForIsPlaying();case 35:_arr=null;_context5.t2=mode;_context5.next=_context5.t2===\"nearest\"?39:_context5.t2===\"farthest\"?41:43;break;case 39:_arr=findClosestOrFarthestToIncluded(included,\"closest\");return _context5.abrupt(\"break\",43);case 41:_arr=findClosestOrFarthestToIncluded(included,\"farthest\");return _context5.abrupt(\"break\",43);case 43:_root=_arr[0];_toAdd=_arr[1];_followUp=_arr[2];//remove edge between root and followUp\nremoveEdge(_root,_followUp);//mark the three nodes\n_toAdd.color=\"#ae2a0d\";_root.color=\"#0f61e8\";_followUp.color=\"#0f61e8\";_context5.next=52;return delay(1000);case 52://add edges\naddEdge(_root,_toAdd,euclidDistance(_root,_toAdd));_context5.next=55;return delay(400);case 55:addEdge(_toAdd,_followUp,euclidDistance(_toAdd,_followUp));included[_toAdd.index]=true;_context5.next=59;return delay(1000);case 59:_toAdd.color=\"#fff\";_root.color=\"#fff\";_followUp.color=\"#fff\";case 62:++i;_context5.next=32;break;case 65:case\"end\":return _context5.stop();}},_callee5);}));return _insertion.apply(this,arguments);}function findClosestOrFarthestToIncluded(included,mode){if(mode!==\"closest\"&&mode!==\"farthest\")throw'Invalid Input. Mode is: '+mode+' but has to be \"closest\" or \"farthest\"';var curMinOrMax=Number.MAX_VALUE;//min\nif(mode==\"farthest\"){curMinOrMax=Number.MIN_VALUE;//max\n}var root=null;var closestToRoot=null;//iterating through all non - included nodes\nvar nonIncludedNodes=getNonIncludedNodes(included);var _iterator5=_createForOfIteratorHelper(nonIncludedNodes),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var node=_step5.value;//and find closest distance to included \nvar _findClosestNode=findClosestNode(node,getIncludedNodes(included)),_findClosestNode2=_slicedToArray(_findClosestNode,2),closestDist=_findClosestNode2[0],potentialRoot=_findClosestNode2[1];//if that cloeset dist is greate than curMax, than the node is considered to be farther from included\nif(mode==\"closest\"){if(closestDist<curMinOrMax){curMinOrMax=closestDist;root=potentialRoot;closestToRoot=node;}}if(mode==\"farthest\"){if(closestDist>curMinOrMax){curMinOrMax=closestDist;root=potentialRoot;closestToRoot=node;}}}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}var rootEdges=graph.AdjList.get(root);var firstRootNeighbor=rootEdges[0].other(root);if(rootEdges.length==1)return[root,closestToRoot,firstRootNeighbor];var secondRootNeighbor=rootEdges[1].other(root);var newDist1=euclidDistance(closestToRoot,firstRootNeighbor);var newDist2=euclidDistance(closestToRoot,secondRootNeighbor);var oldDist1=euclidDistance(root,firstRootNeighbor);var oldDist2=euclidDistance(root,secondRootNeighbor);if(newDist1-oldDist1<newDist2-oldDist2)return[root,closestToRoot,firstRootNeighbor];return[root,closestToRoot,secondRootNeighbor];}/**\n     * \n     * @param {Node} node \n     * @param {Node} nodes \n     * @returns [closestDist, closestNode]\n     */function findClosestNode(node,nodes){var closestNode=null;var closestDist=Number.MAX_VALUE;var _iterator6=_createForOfIteratorHelper(nodes),_step6;try{for(_iterator6.s();!(_step6=_iterator6.n()).done;){var v=_step6.value;var dist=euclidDistance(node,v);if(dist<closestDist){closestDist=dist;closestNode=v;}}}catch(err){_iterator6.e(err);}finally{_iterator6.f();}return[closestDist,closestNode];}function removeEdge(node1,node2){graph.removeEdge(node1,node2);}/**\n     * Adds an edge between the node node1 and node2 that have to exist in the graph\n     * @param {Node} node1 \n     * @param {Node} node2\n     */function addEdge(node1,node2,weight){if(node1.index==node2.index)throw'nodes cannot be the same';graph.addEdge(node1,node2,weight);}/**\n     * This function runs nearestNeigbor on the global graph, starting from\n     * curNode, only visiting non-included nodes (as given by the included array).\n     * The boolean value timeOnlyFromCurNode specifies whether the function returns the\n     * total travel time from startNode to startNode, or only from curNode to startNode.\n     * @param {Node} curNode \n     * @param {boolean[]} included \n     * @param {boolean} timeOnlyFromCurNode \n     * @returns \n     */function nearestNeighbor(_x3,_x4,_x5){return _nearestNeighbor.apply(this,arguments);}function _nearestNeighbor(){_nearestNeighbor=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee6(curNode,included,timeOnlyFromCurNode){var time,nonIncludedNodes,i,node,_weight,weight;return _regeneratorRuntime().wrap(function _callee6$(_context6){while(1)switch(_context6.prev=_context6.next){case 0:if(timeOnlyFromCurNode==undefined)timeOnlyFromCurNode=false;time=0;//algoFinished = false;\nincluded[curNode.index]=true;//adj.push(curNode);\nnonIncludedNodes=getNonIncludedNodes(included);i=0;case 5:if(!(i<nonIncludedNodes.length)){_context6.next=19;break;}_context6.next=8;return waitForIsPlaying();case 8:node=findNode(curNode,included,\"closest\");//add an edge between node and curNode\n_weight=euclidDistance(node,curNode);time+=_weight;addEdge(node,curNode,_weight);curNode=node;included[curNode.index]=true;//adj.push(curNode);\n_context6.next=16;return delay(300);case 16:++i;_context6.next=5;break;case 19:weight=euclidDistance(curNode,startNode);time+=weight;addEdge(curNode,startNode,weight);_context6.next=24;return delay(300);case 24:if(!timeOnlyFromCurNode){_context6.next=26;break;}return _context6.abrupt(\"return\",time);case 26:_context6.next=28;return calculateTravelTime();case 28:return _context6.abrupt(\"return\",_context6.sent);case 29:case\"end\":return _context6.stop();}},_callee6);}));return _nearestNeighbor.apply(this,arguments);}function calculateTravelTime(_x6){return _calculateTravelTime.apply(this,arguments);}function _calculateTravelTime(){_calculateTravelTime=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee7(start){var time,V,included,curNode,i,edgesToCurNode,_iterator14,_step14,edge,neighbor,lastEdge;return _regeneratorRuntime().wrap(function _callee7$(_context7){while(1)switch(_context7.prev=_context7.next){case 0:time=0;V=graph.V;included=new Array(V).fill(false);included[startNode.index]=true;curNode=startNode;//adding all nodes\ni=0;case 6:if(!(i<graph.V-1)){_context7.next=32;break;}edgesToCurNode=graph.AdjList.get(curNode);_iterator14=_createForOfIteratorHelper(edgesToCurNode);_context7.prev=9;_iterator14.s();case 11:if((_step14=_iterator14.n()).done){_context7.next=21;break;}edge=_step14.value;neighbor=edge.other(curNode);if(included[neighbor.index]){_context7.next=19;break;}time+=edge.weight;included[neighbor.index]=true;curNode=neighbor;return _context7.abrupt(\"break\",21);case 19:_context7.next=11;break;case 21:_context7.next=26;break;case 23:_context7.prev=23;_context7.t0=_context7[\"catch\"](9);_iterator14.e(_context7.t0);case 26:_context7.prev=26;_iterator14.f();return _context7.finish(26);case 29:++i;_context7.next=6;break;case 32:lastEdge=graph.findEdge(curNode,startNode);time+=lastEdge.weight;return _context7.abrupt(\"return\",time);case 35:case\"end\":return _context7.stop();}},_callee7,null,[[9,23,26,29]]);}));return _calculateTravelTime.apply(this,arguments);}function getNonIncludedNodes(included){var out=[];var _iterator7=_createForOfIteratorHelper(graph.getNodes()),_step7;try{for(_iterator7.s();!(_step7=_iterator7.n()).done;){var v=_step7.value;if(!included[v.index])out.push(v);}}catch(err){_iterator7.e(err);}finally{_iterator7.f();}return out;}function getIncludedNodes(included){var out=[];var _iterator8=_createForOfIteratorHelper(graph.getNodes()),_step8;try{for(_iterator8.s();!(_step8=_iterator8.n()).done;){var v=_step8.value;if(included[v.index])out.push(v);}}catch(err){_iterator8.e(err);}finally{_iterator8.f();}return out;}/**\n     * \n     * @param {Node} curNode \n     * @param {boolean[]} included \n     * @param {double} time \n     * @returns \n     */function bruteForce(_x7,_x8,_x9){return _bruteForce.apply(this,arguments);}function _bruteForce(){_bruteForce=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee8(curNode,included,time){var neighbors,weight,minTime,bestNeighbor,_iterator15,_step15,neighbor,includedCopy,tempGraph,finishTime;return _regeneratorRuntime().wrap(function _callee8$(_context8){while(1)switch(_context8.prev=_context8.next){case 0:included[curNode.index]=true;neighbors=getNonIncludedNodes(included);if(!(neighbors.length==0)){_context8.next=6;break;}weight=euclidDistance(startNode,curNode);addEdge(startNode,curNode,weight);return _context8.abrupt(\"return\",time+weight);case 6:minTime=Number.MAX_VALUE;bestNeighbor=null;_iterator15=_createForOfIteratorHelper(neighbors);_context8.prev=9;_iterator15.s();case 11:if((_step15=_iterator15.n()).done){_context8.next=29;break;}neighbor=_step15.value;_context8.next=15;return waitForIsPlaying();case 15:includedCopy=JSON.parse(JSON.stringify(included));tempGraph=copyGraph(graph);addEdge(curNode,neighbor,euclidDistance(curNode,neighbor));_context8.next=20;return delay(300);case 20:_context8.next=22;return bruteForce(neighbor,includedCopy,time+euclidDistance(curNode,neighbor));case 22:finishTime=_context8.sent;if(finishTime<minTime){minTime=finishTime;bestNeighbor=neighbor;}graph=copyGraph(tempGraph);_context8.next=27;return delay(300);case 27:_context8.next=11;break;case 29:_context8.next=34;break;case 31:_context8.prev=31;_context8.t0=_context8[\"catch\"](9);_iterator15.e(_context8.t0);case 34:_context8.prev=34;_iterator15.f();return _context8.finish(34);case 37:addEdge(curNode,bestNeighbor,euclidDistance(curNode,bestNeighbor));_context8.next=40;return delay(400);case 40:return _context8.abrupt(\"return\",bruteForce(bestNeighbor,included,time+euclidDistance(curNode,bestNeighbor)));case 41:case\"end\":return _context8.stop();}},_callee8,null,[[9,31,34,37]]);}));return _bruteForce.apply(this,arguments);}function nearestNeighborImproved(){return _nearestNeighborImproved.apply(this,arguments);}function _nearestNeighborImproved(){_nearestNeighborImproved=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee9(){var curNode,included,i,min,potentialNextNode,nonIncludedNodes,_iterator16,_step16,v,tempGraph,includedCopy,time;return _regeneratorRuntime().wrap(function _callee9$(_context9){while(1)switch(_context9.prev=_context9.next){case 0:curNode=startNode;included=new Array(graph.V).fill(false);included[curNode.index]=true;//in every iteration add one node\ni=0;case 4:if(!(i<graph.V-1)){_context9.next=43;break;}min=Number.MAX_VALUE;potentialNextNode=null;nonIncludedNodes=getNonIncludedNodes(included);//iterate through all non-included nodes\n_iterator16=_createForOfIteratorHelper(nonIncludedNodes);_context9.prev=9;_iterator16.s();case 11:if((_step16=_iterator16.n()).done){_context9.next=27;break;}v=_step16.value;_context9.next=15;return waitForIsPlaying();case 15:tempGraph=copyGraph(graph);includedCopy=JSON.parse(JSON.stringify(included));addEdge(curNode,v,euclidDistance(curNode,v));_context9.next=20;return nearestNeighbor(v,includedCopy,true);case 20:time=_context9.sent;time+=euclidDistance(curNode,v);delay(300);if(time<min){potentialNextNode=v;min=time;}graph=copyGraph(tempGraph);case 25:_context9.next=11;break;case 27:_context9.next=32;break;case 29:_context9.prev=29;_context9.t0=_context9[\"catch\"](9);_iterator16.e(_context9.t0);case 32:_context9.prev=32;_iterator16.f();return _context9.finish(32);case 35:addEdge(curNode,potentialNextNode,euclidDistance(curNode,potentialNextNode));curNode=potentialNextNode;included[curNode.index]=true;_context9.next=40;return delay(300);case 40:++i;_context9.next=4;break;case 43:addEdge(curNode,startNode,euclidDistance(curNode,startNode));case 44:case\"end\":return _context9.stop();}},_callee9,null,[[9,29,32,35]]);}));return _nearestNeighborImproved.apply(this,arguments);}function copyGraph(g){var newGraph=new Graph(0);var _iterator9=_createForOfIteratorHelper(g.getNodes()),_step9;try{for(_iterator9.s();!(_step9=_iterator9.n()).done;){var node=_step9.value;newGraph.addVertex(node);}}catch(err){_iterator9.e(err);}finally{_iterator9.f();}var _iterator10=_createForOfIteratorHelper(g.getEdges()),_step10;try{for(_iterator10.s();!(_step10=_iterator10.n()).done;){var edge=_step10.value;newGraph.addEdgeFromEdge(edge);}}catch(err){_iterator10.e(err);}finally{_iterator10.f();}return newGraph;}/**\n     * This method finds the closest or farthets Node to curNode, \n     * that is not yet inclueded (true in the included array). The \n     * mode decides if we find closest or farthets and has to be\n     * \"closest\" or \"farthsest\".\n     * @param {*} curNode \n     * @param {*} included \n     * @param {string} mode\n     * @returns \n     */function findNode(curNode,included,mode){if(mode!==\"closest\"&&mode!==\"farthest\")throw'Invalid Input. Mode is: '+mode+' but has to be \"closest\" or \"farthest\"';var minOrMax=Number.MAX_VALUE;//min\nif(mode==\"farthest\")minOrMax=Number.MIN_VALUE;//max\nvar curClosestOrFarthest=null;var _iterator11=_createForOfIteratorHelper(graph.getNodes()),_step11;try{for(_iterator11.s();!(_step11=_iterator11.n()).done;){var node=_step11.value;if(included[node.index])continue;var dist=euclidDistance(curNode,node);//let dist = graph.findEdge(curNode, node).weight;\nif(mode==\"closest\"){if(dist<minOrMax){minOrMax=dist;curClosestOrFarthest=node;}}else{if(dist>minOrMax){minOrMax=dist;curClosestOrFarthest=node;}}}}catch(err){_iterator11.e(err);}finally{_iterator11.f();}return curClosestOrFarthest;}/**\n     * \n     * @param {Node} node1 \n     * @param {Node} node2 \n     * @returns \n     */function euclidDistance(node1,node2){if(!node1||!node2){throw'a node for dist does not exists';return;}var result=(node1.x-node2.x)*(node1.x-node2.x)+(node1.y-node2.y)*(node1.y-node2.y);return Math.sqrt(result);}function christofides(){return _christofides.apply(this,arguments);}function _christofides(){_christofides=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee10(){var nodesWithOddDegree,_iterator17,_step17,node,_iterator18,_step18,included,curNode,temp,first,_iterator19,_step19;return _regeneratorRuntime().wrap(function _callee10$(_context10){while(1)switch(_context10.prev=_context10.next){case 0:_context10.next=2;return computeMST();case 2:nodesWithOddDegree=getNodesWithOddDegree(graph);_iterator17=_createForOfIteratorHelper(nodesWithOddDegree);try{for(_iterator17.s();!(_step17=_iterator17.n()).done;){node=_step17.value;node.color=\"#ae2a0d\";}// await delay(15000);\n}catch(err){_iterator17.e(err);}finally{_iterator17.f();}_context10.next=7;return findPerfectMatchingMinWeight(nodesWithOddDegree);case 7:_iterator18=_createForOfIteratorHelper(nodesWithOddDegree);try{for(_iterator18.s();!(_step18=_iterator18.n()).done;){node=_step18.value;node.color=\"#fff\";}}catch(err){_iterator18.e(err);}finally{_iterator18.f();}_context10.next=11;return findEulerianCycle();case 11:// for (node of eulerCycle) {\n//   console.log(node.index+  \"-\");\n// }\nincluded=new Array(graph.V).fill(false);curNode=eulerCycle.pop();temp=curNode;// we have to go back to this one in the end\nfirst=curNode;included[curNode.index]=true;case 16:if(!(eulerCycle.length>0)){_context10.next=23;break;}_context10.next=19;return waitForIsPlaying();case 19:curNode=eulerCycle.pop();if(!included[curNode.index]){included[curNode.index]=true;addEdge(temp,curNode,euclidDistance(temp,curNode));temp=curNode;}_context10.next=16;break;case 23:addEdge(temp,first,euclidDistance(curNode,first));// let edge = new Edge(nodesWithOddDegree[0], nodesWithOddDegree[1], euclidDistance(nodesWithOddDegree[0], nodesWithOddDegree[1]));\n// //console.log('there are nodes with odd degree: ' + nodesWithOddDegree.length);\n// edge.color = 255;\n// graph.addEdgeFromEdge(edge);\n_iterator19=_createForOfIteratorHelper(nodesWithOddDegree);try{for(_iterator19.s();!(_step19=_iterator19.n()).done;){node=_step19.value;node.color=\"#fff\";}}catch(err){_iterator19.e(err);}finally{_iterator19.f();}case 26:case\"end\":return _context10.stop();}},_callee10);}));return _christofides.apply(this,arguments);}function findEulerianCycle(){return _findEulerianCycle.apply(this,arguments);}function _findEulerianCycle(){_findEulerianCycle=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee11(){var v,_iterator20,_step20,node;return _regeneratorRuntime().wrap(function _callee11$(_context11){while(1)switch(_context11.prev=_context11.next){case 0:_context11.next=2;return waitForIsPlaying();case 2:// Find a vertex with odd degree\nv=graph.getNodes()[0];_iterator20=_createForOfIteratorHelper(graph.getNodes());_context11.prev=4;_iterator20.s();case 6:if((_step20=_iterator20.n()).done){_context11.next=13;break;}node=_step20.value;if(!(graph.getNeighbors(node).length%2==1)){_context11.next=11;break;}v=node;return _context11.abrupt(\"break\",13);case 11:_context11.next=6;break;case 13:_context11.next=18;break;case 15:_context11.prev=15;_context11.t0=_context11[\"catch\"](4);_iterator20.e(_context11.t0);case 18:_context11.prev=18;_iterator20.f();return _context11.finish(18);case 21:_context11.next=23;return printEulerUtil(v);case 23:case\"end\":return _context11.stop();}},_callee11,null,[[4,15,18,21]]);}));return _findEulerianCycle.apply(this,arguments);}function printEulerUtil(_x10){return _printEulerUtil.apply(this,arguments);}// The function to check if edge u-v can be considered\n// as next edge in Euler Tout\nfunction _printEulerUtil(){_printEulerUtil=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee12(v){var _iterator21,_step21,node;return _regeneratorRuntime().wrap(function _callee12$(_context12){while(1)switch(_context12.prev=_context12.next){case 0:_context12.next=2;return waitForIsPlaying();case 2:eulerCycle.push(v);//Print Euler tour starting from vertex u\n// Recur for all the vertices adjacent to\n// this vertex\n_iterator21=_createForOfIteratorHelper(graph.getNeighbors(v));_context12.prev=4;_iterator21.s();case 6:if((_step21=_iterator21.n()).done){_context12.next=19;break;}node=_step21.value;_context12.next=10;return delay(500);case 10:_context12.next=12;return isValidNextEdge(v,node);case 12:if(!_context12.sent){_context12.next=17;break;}graph.removeEdge(v,node);_context12.next=16;return printEulerUtil(node);case 16:return _context12.abrupt(\"break\",19);case 17:_context12.next=6;break;case 19:_context12.next=24;break;case 21:_context12.prev=21;_context12.t0=_context12[\"catch\"](4);_iterator21.e(_context12.t0);case 24:_context12.prev=24;_iterator21.f();return _context12.finish(24);case 27:case\"end\":return _context12.stop();}},_callee12,null,[[4,21,24,27]]);}));return _printEulerUtil.apply(this,arguments);}function isValidNextEdge(_x11,_x12){return _isValidNextEdge.apply(this,arguments);}function _isValidNextEdge(){_isValidNextEdge=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee13(u,v){var count,visited,count1,count2;return _regeneratorRuntime().wrap(function _callee13$(_context13){while(1)switch(_context13.prev=_context13.next){case 0:// The edge u-v is valid in one of the following\n// two cases:\n// 1) If v is the only adjacent vertex of u\ncount=graph.getNeighbors(u).length;if(!(count==1)){_context13.next=3;break;}return _context13.abrupt(\"return\",true);case 3:// 2) If there are multiple adjacents, then u-v\n//    is not a bridge\n// Do following steps to check if u-v is a bridge\n// 2.a) count of vertices reachable from u\nvisited=new Array(graph.V);visited.fill(false);_context13.next=7;return DFSCount(u,visited);case 7:count1=_context13.sent;// 2.b) Remove edge (u, v) and after removing\n// the edge, count vertices reachable from u\ngraph.removeEdge(u,v);visited.fill(false);_context13.next=12;return DFSCount(u,visited);case 12:count2=_context13.sent;// 2.c) Add the edge back to the graph\ngraph.addEdge(u,v,euclidDistance(u,v));// 2.d) If count1 is greater, then edge (u, v)\n// is a bridge\nreturn _context13.abrupt(\"return\",count1>count2?false:true);case 15:case\"end\":return _context13.stop();}},_callee13);}));return _isValidNextEdge.apply(this,arguments);}function DFSCount(_x13,_x14){return _DFSCount.apply(this,arguments);}/**\n     * \n     * @param {Node} {even number of nodes} \n     */function _DFSCount(){_DFSCount=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee14(v,visited){var count,_iterator22,_step22,node,nodesWithOddDegree,edge;return _regeneratorRuntime().wrap(function _callee14$(_context14){while(1)switch(_context14.prev=_context14.next){case 0:// Mark the current node as visited\nvisited[v.index]=true;count=1;// Recur for all vertices adjacent to this vertex\n_iterator22=_createForOfIteratorHelper(graph.getNeighbors(v));_context14.prev=3;_iterator22.s();case 5:if((_step22=_iterator22.n()).done){_context14.next=14;break;}node=_step22.value;if(visited[node.index]){_context14.next=12;break;}_context14.t0=count;_context14.next=11;return DFSCount(node,visited);case 11:count=_context14.t0+=_context14.sent;case 12:_context14.next=5;break;case 14:_context14.next=19;break;case 16:_context14.prev=16;_context14.t1=_context14[\"catch\"](3);_iterator22.e(_context14.t1);case 19:_context14.prev=19;_iterator22.f();return _context14.finish(19);case 22:return _context14.abrupt(\"return\",count);case 26:edge=new Edge(nodesWithOddDegree[0],nodesWithOddDegree[1],euclidDistance(nodesWithOddDegree[0],nodesWithOddDegree[1]));//console.log('there are nodes with odd degree: ' + nodesWithOddDegree.length);\nedge.color=255;graph.addEdgeFromEdge(edge);//min-cost-max matching is harder than I thought...\ncase 29:case\"end\":return _context14.stop();}},_callee14,null,[[3,16,19,22]]);}));return _DFSCount.apply(this,arguments);}function findPerfectMatchingMinWeight(_x15){return _findPerfectMatchingMinWeight.apply(this,arguments);}function _findPerfectMatchingMinWeight(){_findPerfectMatchingMinWeight=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee15(nodes){var edmondsEdges,i,j,v,w,weight,edmonds,result,indexV,indexW;return _regeneratorRuntime().wrap(function _callee15$(_context15){while(1)switch(_context15.prev=_context15.next){case 0:edmondsEdges=[];i=0;case 2:if(!(i<nodes.length-1)){_context15.next=17;break;}j=i+1;case 4:if(!(j<nodes.length)){_context15.next=14;break;}_context15.next=7;return waitForIsPlaying();case 7:v=nodes[i];w=nodes[j];weight=euclidDistance(v,w);edmondsEdges.push([v.index,w.index,-weight]);case 11:++j;_context15.next=4;break;case 14:++i;_context15.next=2;break;case 17:edmonds=new Edmonds(edmondsEdges);result=edmonds.maxWeightMatching();for(i=0;i<result.length;++i){indexV=i;indexW=result[i];v=graph.getNodes().find(function(node){return node.index===indexV;});w=graph.getNodes().find(function(node){return node.index===indexW;});if(indexV<indexW){addEdge(v,w,euclidDistance(v,w));}}case 20:case\"end\":return _context15.stop();}},_callee15);}));return _findPerfectMatchingMinWeight.apply(this,arguments);}function getNodesWithOddDegree(g){var out=[];var _iterator12=_createForOfIteratorHelper(g.getNodes()),_step12;try{for(_iterator12.s();!(_step12=_iterator12.n()).done;){var node=_step12.value;if(g.getNeighbors(node).length%2==1){out.push(node);}}}catch(err){_iterator12.e(err);}finally{_iterator12.f();}return out;}/**\n     * Computes MST from the global variable totalGraph, that we also initialize here\n     */function computeMST(){return _computeMST.apply(this,arguments);}function _computeMST(){_computeMST=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee16(){var distTo,included,i,node,_findClosestNode3,_findClosestNode4,weight,root;return _regeneratorRuntime().wrap(function _callee16$(_context16){while(1)switch(_context16.prev=_context16.next){case 0://first fill total graph if not already done\nfillTotalGraph();distTo=new Array(graph.V).fill(Number.MAX_VALUE);included=new Array(graph.V).fill(false);distTo[startNode.index]=0;included[startNode.index]=true;updateDistances(startNode,distTo);//adding V nodes to MST\ni=0;case 7:if(!(i<graph.V-1)){_context16.next=21;break;}_context16.next=10;return waitForIsPlaying();case 10:node=shortestAddableNodeToIncluded(distTo,included);_findClosestNode3=findClosestNode(node,getIncludedNodes(included)),_findClosestNode4=_slicedToArray(_findClosestNode3,2),weight=_findClosestNode4[0],root=_findClosestNode4[1];addEdge(root,node,weight);included[node.index]=true;updateDistances(node,distTo);graph.printGraph();_context16.next=18;return delay(300);case 18:++i;_context16.next=7;break;case 21:case\"end\":return _context16.stop();}},_callee16);}));return _computeMST.apply(this,arguments);}function updateDistances(node,distTo){var neighbors=totalGraph.getNeighbors(node);neighbors.forEach(function(v){distTo[v.index]=totalGraph.findEdge(v,node).weight;});}/**\n     * This function returns a node and the edge connecting this node\n     * with one that is included such that the weight is minimal.\n     * @param {double[]} distTo \n     * @param {boolean[]} included \n     */function shortestAddableNodeToIncluded(distTo,included){var nonIncludedNodes=getNonIncludedNodes(included);var closestDist=Number.MAX_VALUE;var closestNode=null;var _iterator13=_createForOfIteratorHelper(nonIncludedNodes),_step13;try{for(_iterator13.s();!(_step13=_iterator13.n()).done;){var node=_step13.value;if(distTo[node.index]<closestDist){closestDist=distTo[node.index];closestNode=node;}}}catch(err){_iterator13.e(err);}finally{_iterator13.f();}return closestNode;}/**\n     * Creates a total graph (edges between all nodes)\n     */function fillTotalGraph(){if(totalGraph.V==0){var nodes=graph.getNodes();var allNodesAdded=false;for(var i=0;i<nodes.length;++i){if(!allNodesAdded)totalGraph.addVertex(nodes[i]);for(var j=i+1;j<nodes.length;++j){if(!allNodesAdded)totalGraph.addVertex(nodes[j]);var weight=euclidDistance(nodes[i],nodes[j]);var edge=new Edge(nodes[i],nodes[j],weight);totalGraph.addEdgeFromEdge(edge);}if(!allNodesAdded)allNodesAdded=true;}}}function getPath(){var path=[];var visited=new Array(graph.V).fill(false);var cur=startNode;for(var i=0;i<graph.V;++i){path.push(cur);visited[cur.index]=true;// get both neighbors\nvar neighbors=graph.getNeighbors(cur);cur=visited[neighbors[0].index]?neighbors[1]:neighbors[0];}path.push(startNode);// for (let node of path) {\n//   console.log(node.index + \"-\");\n// }\nreturn path;}function getLength(path){var length=0;var n=path.length;for(var i=0;i<n-1;++i){length+=euclidDistance(path[i],path[i+1]);}return length;}function do2Opt(_x16,_x17,_x18){return _do2Opt.apply(this,arguments);}function _do2Opt(){_do2Opt=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee17(path,i,j){var oldEdge1,oldEdge2,newEdge1,newEdge2;return _regeneratorRuntime().wrap(function _callee17$(_context17){while(1)switch(_context17.prev=_context17.next){case 0:path[i].color=\"#0f61e8\";path[i+1].color=\"#0f61e8\";path[j].color=\"#0f61e8\";path[j+1].color=\"#0f61e8\";// find out why not defined sometimes!\noldEdge1=graph.findEdge(path[i],path[i+1]);oldEdge2=graph.findEdge(path[j],path[j+1]);oldEdge1.color=\"#0f61e8\";oldEdge2.color=\"#0f61e8\";_context17.next=10;return waitForIsPlaying();case 10:_context17.next=12;return delay(2000);case 12:newEdge1=new Edge(path[i],path[j],euclidDistance(path[i],path[j]));newEdge1.color=\"#ae2a0d\";newEdge2=new Edge(path[i+1],path[j+1],euclidDistance(path[i+1],path[j+1]));newEdge2.color=\"#ae2a0d\";_context17.next=18;return waitForIsPlaying();case 18:_context17.next=20;return delay(2000);case 20:graph.addEdgeFromEdge(newEdge1);graph.addEdgeFromEdge(newEdge2);_context17.next=24;return waitForIsPlaying();case 24:_context17.next=26;return delay(2000);case 26:removeEdge(path[i],path[i+1]);removeEdge(path[j],path[j+1]);_context17.next=30;return waitForIsPlaying();case 30:_context17.next=32;return delay(2000);case 32:newEdge1.color=\"#000000\";newEdge2.color=\"#000000\";path[i].color=\"#fff\";path[i+1].color=\"#fff\";path[j].color=\"#fff\";path[j+1].color=\"#fff\";path[i].color=\"#fff\";path[j+1].color=\"#fff\";path[j].color=\"#fff\";path[i+1].color=\"#fff\";case 42:case\"end\":return _context17.stop();}},_callee17);}));return _do2Opt.apply(this,arguments);}function twoOpt(){return _twoOpt.apply(this,arguments);}function _twoOpt(){_twoOpt=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee18(){var foundImprovement,path,n,i,j,gain;return _regeneratorRuntime().wrap(function _callee18$(_context18){while(1)switch(_context18.prev=_context18.next){case 0:foundImprovement=true;path=getPath();n=path.length;case 3:if(!foundImprovement){_context18.next=29;break;}foundImprovement=false;i=0;case 6:if(!(i<n-2)){_context18.next=27;break;}j=i+1;case 8:if(!(j<n-1)){_context18.next=24;break;}_context18.next=11;return waitForIsPlaying();case 11:// first subtract new lengths\ngain=-euclidDistance(path[i],path[j]);gain-=euclidDistance(path[i+1],path[j+1]);// then add old lengths\ngain+=euclidDistance(path[i],path[i+1]);gain+=euclidDistance(path[j],path[j+1]);// If old length is greater than new length\nif(!(gain>1e-4)){_context18.next=20;break;}_context18.next=18;return do2Opt(path,i,j);case 18:// curLength -= gain;\nfoundImprovement=true;path=getPath();case 20:gain=0;case 21:j++;_context18.next=8;break;case 24:i++;_context18.next=6;break;case 27:_context18.next=3;break;case 29:case\"end\":return _context18.stop();}},_callee18);}));return _twoOpt.apply(this,arguments);}function threeOpt(){return _threeOpt.apply(this,arguments);}function _threeOpt(){_threeOpt=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee19(){var foundImprovement,path,n,i,j,k,gain;return _regeneratorRuntime().wrap(function _callee19$(_context19){while(1)switch(_context19.prev=_context19.next){case 0:foundImprovement=true;path=getPath();n=path.length;case 3:if(!foundImprovement){_context19.next=29;break;}foundImprovement=false;i=0;case 6:if(!(i<n-3)){_context19.next=27;break;}j=i+1;case 8:if(!(j<n-2)){_context19.next=24;break;}k=j+1;case 10:if(!(k<n-1)){_context19.next=21;break;}_context19.next=13;return waitForIsPlaying();case 13:_context19.next=15;return gainOfBest3OptWiring(path,i,j,k);case 15:gain=_context19.sent;// If old length is greater than new length\nif(gain>1e-4){// curLength -= gain;\nfoundImprovement=true;path=getPath();}gain=0;case 18:++k;_context19.next=10;break;case 21:++j;_context19.next=8;break;case 24:++i;_context19.next=6;break;case 27:_context19.next=3;break;case 29:case\"end\":return _context19.stop();}},_callee19);}));return _threeOpt.apply(this,arguments);}function gainOfBest3OptWiring(_x19,_x20,_x21,_x22){return _gainOfBest3OptWiring.apply(this,arguments);}function _gainOfBest3OptWiring(){_gainOfBest3OptWiring=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee20(path,i,j,k){var a,b,c,d,e,f,w0,w1,w2,w3,w4,w5,w6,w7,alternativeOptions,shortestWiring,originalLength,shortestLength,_i,_alternativeOptions,option,length,oldEdge1,oldEdge2,oldEdge3,newEdge1,newEdge2,newEdge3;return _regeneratorRuntime().wrap(function _callee20$(_context20){while(1)switch(_context20.prev=_context20.next){case 0:// (a,b) are one edge, (c,d) and (e,f)\na=path[i];b=path[i+1];c=path[j];d=path[j+1];e=path[k];f=path[k+1];// this has good picture for all permutations: http://tsp-basics.blogspot.com/2017/03/3-opt-move.html \n// a going to b\nw0=[a,b,c,d,e,f];//that is original wiring\nw1=[a,b,c,e,d,f];// a going to c\nw2=[a,c,b,d,e,f];w3=[a,c,b,e,d,f];// a going to d\nw4=[a,d,e,b,c,f];w5=[a,d,e,c,b,f];// a going to e\nw6=[a,e,d,b,c,f];w7=[a,e,d,c,b,f];alternativeOptions=[w1,w2,w3,w4,w5,w6,w7];shortestWiring=w0;originalLength=length3OptWiring(w0);shortestLength=originalLength;_i=0,_alternativeOptions=alternativeOptions;case 19:if(!(_i<_alternativeOptions.length)){_context20.next=28;break;}option=_alternativeOptions[_i];_context20.next=23;return waitForIsPlaying();case 23:length=length3OptWiring(option);if(shortestLength>length){shortestLength=length;shortestWiring=option;}case 25:_i++;_context20.next=19;break;case 28:if(!(originalLength>shortestLength)){_context20.next=68;break;}a.color=\"#0f61e8\";b.color=\"#0f61e8\";c.color=\"#0f61e8\";d.color=\"#0f61e8\";e.color=\"#0f61e8\";f.color=\"#0f61e8\";oldEdge1=graph.findEdge(a,b);oldEdge1.color=\"#0f61e8\";oldEdge2=graph.findEdge(c,d);oldEdge2.color=\"#0f61e8\";oldEdge3=graph.findEdge(e,f);oldEdge3.color=\"#0f61e8\";_context20.next=43;return delay(2000);case 43://color new edges and add them\nnewEdge1=new Edge(shortestWiring[0],shortestWiring[1],euclidDistance(shortestWiring[0],shortestWiring[1]));newEdge2=new Edge(shortestWiring[2],shortestWiring[3],euclidDistance(shortestWiring[2],shortestWiring[3]));newEdge3=new Edge(shortestWiring[4],shortestWiring[5],euclidDistance(shortestWiring[4],shortestWiring[5]));newEdge1.color=\"#ae2a0d\";newEdge2.color=\"#ae2a0d\";newEdge3.color=\"#ae2a0d\";graph.addEdgeFromEdge(newEdge1);graph.addEdgeFromEdge(newEdge2);graph.addEdgeFromEdge(newEdge3);_context20.next=54;return delay(2000);case 54:removeEdge(a,b);removeEdge(c,d);removeEdge(e,f);_context20.next=59;return delay(1000);case 59:newEdge1.color=\"#000000\";newEdge2.color=\"#000000\";newEdge3.color=\"#000000\";a.color=\"#fff\";b.color=\"#fff\";c.color=\"#fff\";d.color=\"#fff\";e.color=\"#fff\";f.color=\"#fff\";case 68:return _context20.abrupt(\"return\",originalLength-shortestLength);case 69:case\"end\":return _context20.stop();}},_callee20);}));return _gainOfBest3OptWiring.apply(this,arguments);}function length3OptWiring(wiring){var length=0;for(var i=0;i<6;i+=2){length+=euclidDistance(wiring[i],wiring[i+1]);}return length;}/**\n     * \n     * @param {number of clusters} k \n     */function clusterNaively(_x23){return _clusterNaively.apply(this,arguments);}function _clusterNaively(){_clusterNaively=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee21(k){var nodesPerCluster,edges,_iterator23,_step23,e,v1,v2,temp;return _regeneratorRuntime().wrap(function _callee21$(_context21){while(1)switch(_context21.prev=_context21.next){case 0:fillTotalGraph();nodesPerCluster=totalGraph.V/k;edges=totalGraph.getEdges();edges.sort(function(e1,e2){return e1.weight>=e2.weight?1:-1;});//add small edges to cluster, if it doesn't exceed its size (size is naively n/k)\n_iterator23=_createForOfIteratorHelper(edges);_context21.prev=5;_iterator23.s();case 7:if((_step23=_iterator23.n()).done){_context21.next=31;break;}e=_step23.value;_context21.next=11;return delay(1000);case 11:v1=e.either();v2=e.other(v1);//case 1, both nodes not included\nif(!(!v1.root&&!v2.root)){_context21.next=19;break;}v2.root=v1;v1.isRoot=true;v1.children=1;addEdge(v1,v2,e.weight);return _context21.abrupt(\"continue\",29);case 19:if(!(v1.isRoot&&!v2.root||v1.root&&!v2.root)){_context21.next=23;break;}if(v1.isRoot){if(v1.children+1<nodesPerCluster){v2.root=v1;v1.children++;}}else{v2.root=v1.root;v1.root.children++;}addEdge(v1,v2,e.weight);return _context21.abrupt(\"continue\",29);case 23:if(!(v2.isRoot&&!v1.root||v2.root&&!v1.root)){_context21.next=26;break;}if(v2.root.children+1<nodesPerCluster){v1.root=v2.root;v2.root.children++;addEdge(v1,v2,e.weight);}return _context21.abrupt(\"continue\",29);case 26:if(!(v1.root&&v2.root)){_context21.next=29;break;}if(v1.root.children+1+v2.root+1<nodesPerCluster){temp=v1.root.children+1;v1.root=v2.root;v2.root.children+=temp;addEdge(v1,v2,e.weight);}return _context21.abrupt(\"continue\",29);case 29:_context21.next=7;break;case 31:_context21.next=36;break;case 33:_context21.prev=33;_context21.t0=_context21[\"catch\"](5);_iterator23.e(_context21.t0);case 36:_context21.prev=36;_iterator23.f();return _context21.finish(36);case 39:case\"end\":return _context21.stop();}},_callee21,null,[[5,33,36,39]]);}));return _clusterNaively.apply(this,arguments);}};export default sketch;","map":{"version":3,"names":["Graph","Node","Edge","Edmonds","WIDTH","window","innerWidth","HEIGHT","innerHeight","speed","startNode","count","graph","totalGraph","startDefined","algo","localSearch","isPlaying","state","eulerCycle","sketch","p","addingNodes","isRunning","clearingBoard","setIsPlaying","setup","createCanvas","windowResized","resizeCanvas","draw","_asyncToGenerator","_regeneratorRuntime","mark","_callee","nodes","_iterator","_step","node","wrap","_callee$","_context","prev","next","background","fill","circle","mouseX","mouseY","getNodes","_createForOfIteratorHelper","s","n","done","value","color","x","y","err","e","f","drawEdges","console","log","t0","insertion","abrupt","nearestNeighbor","Array","V","nearestNeighborImproved","bruteForce","clusterNaively","christofides","t1","twoOpt","threeOpt","stop","anyNodeHasNeighbors","E","edges","getEdges","_iterator2","_step2","stroke","v1","either","v2","other","x1","y1","x2","y2","line","waitForIsPlaying","_waitForIsPlaying","apply","arguments","_callee3","_callee3$","_context3","Promise","resolve","checkIsPlaying","setTimeout","removeAllEdges","tempGraph","_iterator3","_step3","addVertex","mouseClicked","_callee2","_callee2$","_context2","addNodes","loop","updateWithProps","newProps","removeEdges","_iterator4","_step4","clearinBoard","delay","_x","_delay","_callee4","time","_callee4$","_context4","displayNodes","printGraph","_x2","_insertion","_callee5","mode","toAdd","included","arr","root","followUp","i","_arr","_root","_toAdd","_followUp","_callee5$","_context5","index","findNode","addEdge","euclidDistance","findClosestOrFarthestToIncluded","t2","removeEdge","curMinOrMax","Number","MAX_VALUE","MIN_VALUE","closestToRoot","nonIncludedNodes","getNonIncludedNodes","_iterator5","_step5","_findClosestNode","findClosestNode","getIncludedNodes","_findClosestNode2","_slicedToArray","closestDist","potentialRoot","rootEdges","AdjList","get","firstRootNeighbor","length","secondRootNeighbor","newDist1","newDist2","oldDist1","oldDist2","closestNode","_iterator6","_step6","v","dist","node1","node2","weight","_x3","_x4","_x5","_nearestNeighbor","_callee6","curNode","timeOnlyFromCurNode","_weight","_callee6$","_context6","undefined","calculateTravelTime","sent","_x6","_calculateTravelTime","_callee7","start","edgesToCurNode","_iterator14","_step14","edge","neighbor","lastEdge","_callee7$","_context7","finish","findEdge","out","_iterator7","_step7","push","_iterator8","_step8","_x7","_x8","_x9","_bruteForce","_callee8","neighbors","minTime","bestNeighbor","_iterator15","_step15","includedCopy","finishTime","_callee8$","_context8","JSON","parse","stringify","copyGraph","_nearestNeighborImproved","_callee9","min","potentialNextNode","_iterator16","_step16","_callee9$","_context9","g","newGraph","_iterator9","_step9","_iterator10","_step10","addEdgeFromEdge","minOrMax","curClosestOrFarthest","_iterator11","_step11","result","Math","sqrt","_christofides","_callee10","nodesWithOddDegree","_iterator17","_step17","_iterator18","_step18","temp","first","_iterator19","_step19","_callee10$","_context10","computeMST","getNodesWithOddDegree","findPerfectMatchingMinWeight","findEulerianCycle","pop","_findEulerianCycle","_callee11","_iterator20","_step20","_callee11$","_context11","getNeighbors","printEulerUtil","_x10","_printEulerUtil","_callee12","_iterator21","_step21","_callee12$","_context12","isValidNextEdge","_x11","_x12","_isValidNextEdge","_callee13","u","visited","count1","count2","_callee13$","_context13","DFSCount","_x13","_x14","_DFSCount","_callee14","_iterator22","_step22","_callee14$","_context14","_x15","_findPerfectMatchingMinWeight","_callee15","edmondsEdges","j","w","edmonds","indexV","indexW","_callee15$","_context15","maxWeightMatching","find","_iterator12","_step12","_computeMST","_callee16","distTo","_findClosestNode3","_findClosestNode4","_callee16$","_context16","fillTotalGraph","updateDistances","shortestAddableNodeToIncluded","forEach","_iterator13","_step13","allNodesAdded","getPath","path","cur","getLength","do2Opt","_x16","_x17","_x18","_do2Opt","_callee17","oldEdge1","oldEdge2","newEdge1","newEdge2","_callee17$","_context17","_twoOpt","_callee18","foundImprovement","gain","_callee18$","_context18","_threeOpt","_callee19","k","_callee19$","_context19","gainOfBest3OptWiring","_x19","_x20","_x21","_x22","_gainOfBest3OptWiring","_callee20","a","b","c","d","w0","w1","w2","w3","w4","w5","w6","w7","alternativeOptions","shortestWiring","originalLength","shortestLength","_i","_alternativeOptions","option","oldEdge3","newEdge3","_callee20$","_context20","length3OptWiring","wiring","_x23","_clusterNaively","_callee21","nodesPerCluster","_iterator23","_step23","_callee21$","_context21","sort","e1","e2","isRoot","children"],"sources":["/home/thomas/Dev/RouteOptimizationVisualizer/src/sketch.js"],"sourcesContent":["import {Graph} from './Graph.js';\nimport {Node} from './Node.js';\nimport {Edge} from './Edge.js';\nimport {Edmonds} from './Blossom.js'; \n\nlet WIDTH = window.innerWidth; //\"static variables\" like in java\nlet HEIGHT = window.innerHeight *3/ 5;\nlet speed = 5; \n\nlet startNode = new Node(WIDTH / 2, HEIGHT / 2, 0);\nlet count = 1; //count the nodes\nlet graph = new Graph(0);\nlet totalGraph = new Graph(0);\nlet startDefined = false;\nlet algo = \"Not Defined\";\nlet localSearch = \"Not defined\";\nlet isPlaying = true;\n// state is 0 if no path found yet\n// 1 if we already have a solution (that we might want to improve)\nlet state = 0;\nlet eulerCycle = [];\n\nconst sketch = (p) => {\n\n  let addingNodes = false;\n  let isRunning = false;\n  let clearingBoard = false;\n  //let algoFinished = false;\n  let setIsPlaying = p.setIsPlaying;\n\n  p.setup = () => {\n    p.createCanvas(WIDTH, HEIGHT);\n  };\n\n  p.windowResized = () => {\n    WIDTH = window.innerWidth;\n    HEIGHT = window.innerHeight *3/5;\n    p.resizeCanvas(WIDTH, HEIGHT);\n  }\n\n  p.draw = async () => {\n    p.background(220);\n    //draw the nodes\n    //mouse position and already added nodes white\n    p.fill(\"#fff\");\n    p.circle(p.mouseX, p.mouseY, 10);\n    if (startDefined) {\n      let nodes = graph.getNodes();\n      for (let node of nodes) {\n        if (node.color)\n          p.fill(node.color);\n        else \n          p.fill(\"#fff\");\n        p.circle(node.x, node.y, 10);\n      }\n      //draw edges \n      drawEdges(p);\n    }\n     //start node pink\n     p.fill(255, 0, 200);\n     p.circle(startNode.x, startNode.y, 10);\n\n    //if we did not find any solution yet, we will run a algorithm to find inital solution\n    if (state == 0) {\n      if (isRunning) {\n        console.log(\"Starting here\");\n\n        isRunning = false;\n        setIsPlaying(true);\n        isPlaying = true;\n        isRunning = false;\n        switch(algo) {\n          case 'Nearest Insertion':\n            await insertion(\"nearest\");\n            break;\n            case 'Farthest Insertion':\n              await insertion(\"farthest\");\n              break;\n            case 'Nearest Neighbor':\n              await nearestNeighbor(startNode, new Array(graph.V).fill(false), false);\n              break;\n            case 'Nearest Neighbor Look Ahead (made up)':\n              await nearestNeighborImproved();\n              break;\n            case 'Brute Force':\n              await bruteForce(startNode, new Array(graph.V).fill(false), 0);\n              break;\n            case 'Cluster naively':\n              await clusterNaively();\n              break;\n            case 'Christofides':\n              await christofides();\n              break;\n            default:\n              isRunning = false;\n        }\n        setIsPlaying(false);\n        isPlaying = false;\n        isRunning = false;\n        state = 1;\n      }\n    }\n    if (state == 1) {\n      if (isRunning) {\n        console.log(\"Starting here\");\n        isRunning = false;\n        setIsPlaying(true);\n        isPlaying = true;\n        isRunning = false;\n        switch (localSearch) {\n          case '2-opt':\n            await twoOpt();\n            break;\n          default:\n          case '3-opt':\n            await threeOpt();\n            break;\n          \n        }\n        setIsPlaying(false);\n        isPlaying = false;\n        isRunning = false;\n\n      }\n    }\n\n  };\n\n\n  function anyNodeHasNeighbors() {\n    return graph.E > 0;\n  }\n\n\n  function drawEdges(p) {\n    //displayNeihbors(startNode);\n    if (anyNodeHasNeighbors()) {\n      let edges = graph.getEdges();\n      for (let e of edges) {\n        if (e.color) {\n          p.stroke(e.color);\n        }\n        else \n          p.stroke('black');\n        let v1 = e.either();\n        let v2 = e.other(v1);\n        let x1 = v1.x;\n        let y1 = v1.y;\n        let x2 = v2.x;\n        let y2 = v2.y;\n        p.line(x1, y1, x2, y2);\n      }\n    }\n  }\n\n  // async function waitForIsPlaying() {\n  //   if (isPlaying)\n  //     return;\n  //   delay(1000);\n  //   await waitForIsPlaying();\n  // }\n\n  async function waitForIsPlaying() {\n    return new Promise(resolve => {\n      function checkIsPlaying() {\n        if (isPlaying) {\n          resolve();\n        } else {\n          setTimeout(checkIsPlaying, 300);\n        }\n      }\n      checkIsPlaying();\n    });\n  }\n  \n\n  function removeAllEdges() {\n    let tempGraph = new Graph(0);\n    for (let node of graph.getNodes())\n      tempGraph.addVertex(node);\n    graph = tempGraph;\n    totalGraph = new Graph(0);\n  }\n\n\n  \n  p.mouseClicked = async () => {\n    if (addingNodes) \n      addNodes(p);\n    //the algorithm updates the paths that p.draw() displays\n  };\n\n  /**\n   * Adding nodes to canvas\n   * @param {}\n   */\n  function addNodes(p) {\n    if (!startDefined) {\n      graph.addVertex(startNode);\n      startDefined = true;\n    }\n    p.loop();\n    //if Y is smaller than HEIGHT, the click was outside of canvas (probably on button) and the don't add\n    if (p.mouseY < HEIGHT && p.mouseY > 0) {\n      let node = new Node(p.mouseX, p.mouseY, count++);\n      graph.addVertex(node);\n    }\n  }\n\n    //this function \"sends\" data/additional parameters to our function. When ever the props change, the change is passed here\n    p.updateWithProps = function (newProps) {\n      if (newProps.removeEdges) {\n        removeAllEdges();\n        let nodes = graph.getNodes();\n        for (let node of nodes) {\n          node.color = '#fff';\n        }\n        state = 0;\n      }\n      setIsPlaying = newProps.setIsPlaying;\n      addingNodes = newProps.addingNodes;\n      isRunning = newProps.isRunning;\n      clearingBoard = newProps.clearinBoard;\n      isPlaying = newProps.isPlaying;\n      if (clearingBoard) {\n        startNode = new Node(WIDTH / 2, HEIGHT / 2, 0, []);\n        count = 1; //count the nodes\n        graph = new Graph(0);\n        startDefined = false;\n        totalGraph = new Graph(0);\n        state = 0;\n      }\n      if (!newProps.algo !== algo)\n        algo = newProps.algo;\n      if (!newProps.localSearch !== localSearch)\n        localSearch = newProps.localSearch;\n      if (!newProps.speed !== speed) \n        speed = newProps.speed;\n      if (speed == 0)\n        speed = 1;\n      //whenever a prop changes we start the loop again (it's only stopped after the path got displayed)\n      p.loop();\n    }\n/*\n    async function runAlgorithm() {\n      for (let i = 0; i < nodes.length; ++i) {\n        adj[i] = nodes[i];\n      }\n      adj[nodes.length] = nodes[0];\n    }\n*/\n\nasync function delay(time) {\n  await waitForIsPlaying();\n  return new Promise(resolve => setTimeout(resolve, time/speed));\n}\n    \n    \n    function displayNodes() {\n      graph.printGraph();\n    }\n\n    /**\n     * Mode has to be \"nearest\" or \"farthest\" and decides\n     * whether we run nearestInsertion or farthestInsertion.\n     * @param {string} mode \n     */\n    async function insertion(mode) {\n      //add the startNode\n      let toAdd = startNode;\n      var included = new Array(graph.V).fill(false);\n      included[toAdd.index] = true;\n\n      //add the first node\n      let node = null;\n      switch(mode) {\n        case \"nearest\":\n          node = findNode(startNode, included, \"closest\");\n          break;\n        case \"farthest\":\n          node = findNode(startNode, included, \"farthest\");\n          break;\n        default:\n\n      }\n      addEdge(startNode, node, euclidDistance(startNode, node));\n      included[node.index] = true;\n      await delay(1000);\n\n      //the second node is inserted slightly different than the remaining ones\n      let arr = null;\n      switch(mode) {\n        case \"nearest\":\n          arr = findClosestOrFarthestToIncluded(included, \"closest\");\n          break;\n        case \"farthest\":\n          arr = findClosestOrFarthestToIncluded(included, \"farthest\");\n          break;\n        default:\n      }\n      let root = arr[0];\n      toAdd = arr[1];\n      let followUp = arr[2];\n      addEdge(root, toAdd, euclidDistance(root, toAdd));\n      addEdge(followUp, toAdd, euclidDistance(followUp, toAdd));\n      included[toAdd.index] = true;\n      await delay(1000);\n\n      //we know how many nodes well have to add, so for loop\n      for (let i = 0; i< graph.V-3; ++i) {\n        await waitForIsPlaying();\n        let arr = null;\n        switch(mode) {\n          case \"nearest\":\n            arr = findClosestOrFarthestToIncluded(included, \"closest\");\n            break;\n          case \"farthest\":\n            arr = findClosestOrFarthestToIncluded(included, \"farthest\");\n            break;\n          default:\n\n        }\n        let root = arr[0];\n        let toAdd = arr[1];\n        let followUp = arr[2];\n        //remove edge between root and followUp\n        removeEdge(root, followUp);\n        //mark the three nodes\n        toAdd.color = \"#ae2a0d\";\n        root.color = \"#0f61e8\";\n        followUp.color = \"#0f61e8\";\n        await delay(1000);\n        //add edges\n        addEdge(root, toAdd, euclidDistance(root, toAdd));\n        await delay(400);\n        addEdge(toAdd, followUp, euclidDistance(toAdd, followUp)); \n        included[toAdd.index] = true;\n        await delay(1000);\n        toAdd.color = \"#fff\";\n        root.color = \"#fff\";\n        followUp.color = \"#fff\";\n      }\n      //algoFinished = true;\n    }\n\n    /**\n     * \n     * @param {boolean[]} included \n     * @param {string} mode \n     * @returns \n     */\n    function findClosestOrFarthestToIncluded(included, mode) {\n      if (mode !== \"closest\" && mode !== \"farthest\")\n        throw('Invalid Input. Mode is: ' + mode + ' but has to be \"closest\" or \"farthest\"');\n\n      let curMinOrMax = Number.MAX_VALUE; //min\n      if (mode == \"farthest\") {\n        curMinOrMax = Number.MIN_VALUE; //max\n      }\n      let root = null;\n      let closestToRoot = null;\n      \n      //iterating through all non - included nodes\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      for (let node of nonIncludedNodes) {\n        //and find closest distance to included \n        let [closestDist, potentialRoot] = findClosestNode(node, getIncludedNodes(included));\n        //if that cloeset dist is greate than curMax, than the node is considered to be farther from included\n        if (mode == \"closest\") {\n          if (closestDist < curMinOrMax) {\n            curMinOrMax = closestDist;\n            root = potentialRoot;\n            closestToRoot = node;\n          }\n        }\n        if (mode == \"farthest\") {\n          if (closestDist > curMinOrMax) {\n            curMinOrMax = closestDist;\n            root = potentialRoot;\n            closestToRoot = node;\n          }\n        }\n      }\n      let rootEdges = graph.AdjList.get(root);\n\n      let firstRootNeighbor = rootEdges[0].other(root);\n      if (rootEdges.length == 1)\n        return [root, closestToRoot, firstRootNeighbor];\n      let secondRootNeighbor =  rootEdges[1].other(root);\n      let newDist1 = euclidDistance(closestToRoot, firstRootNeighbor);\n      let newDist2 = euclidDistance(closestToRoot, secondRootNeighbor);\n      let oldDist1 = euclidDistance(root, firstRootNeighbor);\n      let oldDist2 = euclidDistance(root, secondRootNeighbor);\n\n      if (newDist1 - oldDist1 < newDist2 -oldDist2)\n        return [root, closestToRoot, firstRootNeighbor];\n      return [root, closestToRoot, secondRootNeighbor];\n    }\n\n    /**\n     * \n     * @param {Node} node \n     * @param {Node} nodes \n     * @returns [closestDist, closestNode]\n     */\n    function findClosestNode(node, nodes) {\n      let closestNode = null;\n      let closestDist = Number.MAX_VALUE;\n      for (let v of nodes) {\n        let dist = euclidDistance(node, v);\n        if (dist < closestDist) {\n          closestDist = dist;\n          closestNode = v;\n        }\n      }\n      return [closestDist, closestNode];\n    }\n\n    function removeEdge(node1, node2) {\n      graph.removeEdge(node1, node2);\n    }\n\n    /**\n     * Adds an edge between the node node1 and node2 that have to exist in the graph\n     * @param {Node} node1 \n     * @param {Node} node2\n     */\n    function addEdge (node1, node2, weight) {\n      if (node1.index == node2.index)\n        throw('nodes cannot be the same');\n      graph.addEdge(node1, node2, weight);\n    }\n    \n    /**\n     * This function runs nearestNeigbor on the global graph, starting from\n     * curNode, only visiting non-included nodes (as given by the included array).\n     * The boolean value timeOnlyFromCurNode specifies whether the function returns the\n     * total travel time from startNode to startNode, or only from curNode to startNode.\n     * @param {Node} curNode \n     * @param {boolean[]} included \n     * @param {boolean} timeOnlyFromCurNode \n     * @returns \n     */\n    async function nearestNeighbor(curNode, included, timeOnlyFromCurNode) {\n      if (timeOnlyFromCurNode == undefined)\n        timeOnlyFromCurNode = false;\n      let time = 0;\n      //algoFinished = false;\n      included[curNode.index] = true;\n      //adj.push(curNode);\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      for (let i = 0; i < nonIncludedNodes.length; ++i) {\n        await waitForIsPlaying();\n        let node = findNode(curNode, included, \"closest\");\n        //add an edge between node and curNode\n        let weight = euclidDistance(node, curNode);\n        time += weight;\n        addEdge(node, curNode, weight);\n\n        curNode = node;\n        included[curNode.index] = true;\n\n        //adj.push(curNode);\n        await delay(300);\n      }\n      let weight = euclidDistance(curNode, startNode);\n      time += weight;\n      addEdge(curNode, startNode, weight);\n      await delay(300);\n      if (timeOnlyFromCurNode)\n        return time;\n      return await calculateTravelTime();\n      //algoFinished = true;\n    }\n\n    \n    async function calculateTravelTime(start) {\n      let time = 0;\n      let V = graph.V;\n      let included = new Array(V).fill(false);\n      included[startNode.index] = true;\n      let curNode = startNode;\n      //adding all nodes\n      for (let i = 0; i<graph.V-1; ++i) {\n        let edgesToCurNode = graph.AdjList.get(curNode);\n        for (let edge of edgesToCurNode) {\n          let neighbor = edge.other(curNode);\n          if (!included[neighbor.index]) {\n            time += edge.weight;\n            included[neighbor.index] = true;\n            curNode = neighbor;\n            break;\n          }\n        }\n      }\n      let lastEdge = graph.findEdge(curNode, startNode);\n      time += lastEdge.weight;\n      return time;\n    }\n\n    function getNonIncludedNodes(included) {\n      let out = [];\n      for (let v of graph.getNodes()) {\n        if (!included[v.index])\n          out.push(v);\n      }\n      return out;\n    }\n\n    function getIncludedNodes(included) {\n      let out = [];\n      for (let v of graph.getNodes()) {\n        if (included[v.index])\n          out.push(v);\n      }\n      return out;\n    }\n\n    /**\n     * \n     * @param {Node} curNode \n     * @param {boolean[]} included \n     * @param {double} time \n     * @returns \n     */\n    async function bruteForce(curNode, included, time) {\n      included[curNode.index] = true;\n      let neighbors = getNonIncludedNodes(included);\n      if (neighbors.length == 0) {\n        let weight = euclidDistance(startNode, curNode);\n        addEdge(startNode, curNode, weight);\n        return time + weight;\n      }\n      let minTime = Number.MAX_VALUE;\n      let bestNeighbor = null;\n      for (let neighbor of neighbors) {\n        await waitForIsPlaying();\n        let includedCopy = JSON.parse(JSON.stringify(included));\n        let tempGraph = copyGraph(graph);\n        addEdge(curNode, neighbor, euclidDistance(curNode, neighbor));\n        await delay(300);\n        let finishTime = await bruteForce(neighbor, includedCopy, time + euclidDistance(curNode, neighbor));\n        if (finishTime < minTime) {\n          minTime = finishTime;\n          bestNeighbor = neighbor;\n        }\n        graph = copyGraph(tempGraph);\n        await delay(300);\n      }\n      addEdge(curNode, bestNeighbor, euclidDistance(curNode, bestNeighbor));\n      await delay(400);\n      return bruteForce(bestNeighbor, included, time + euclidDistance(curNode, bestNeighbor));\n    }\n\n    async function nearestNeighborImproved() {\n      let curNode = startNode;\n      let included = new Array(graph.V).fill(false);\n      included[curNode.index] = true;\n      //in every iteration add one node\n      for (let i = 0; i<graph.V -1; ++i) {\n        let min = Number.MAX_VALUE;\n        let potentialNextNode = null;\n        let nonIncludedNodes = getNonIncludedNodes(included);\n        //iterate through all non-included nodes\n        for (let v of nonIncludedNodes) {\n          await waitForIsPlaying();\n\n          let tempGraph = copyGraph(graph);\n          let includedCopy = JSON.parse(JSON.stringify(included));\n          addEdge(curNode, v, euclidDistance(curNode, v));\n          let time = await nearestNeighbor(v, includedCopy, true);\n          time += euclidDistance(curNode, v);\n          delay(300);\n          if (time < min) {\n            potentialNextNode = v;\n            min = time;\n          }      \n          graph = copyGraph(tempGraph);\n        }\n        \n        addEdge(curNode, potentialNextNode, euclidDistance(curNode, potentialNextNode));\n        curNode = potentialNextNode;\n        included[curNode.index] = true;\n        await delay(300);\n      }\n      addEdge(curNode, startNode, euclidDistance(curNode, startNode));\n    }\n\n    function copyGraph(g) {\n      let newGraph = new Graph(0);\n      for (let node of g.getNodes()){\n        newGraph.addVertex(node);\n      }\n      for (let edge of g.getEdges()) {\n        newGraph.addEdgeFromEdge(edge);\n      }\n      return newGraph;\n    }\n\n    /**\n     * This method finds the closest or farthets Node to curNode, \n     * that is not yet inclueded (true in the included array). The \n     * mode decides if we find closest or farthets and has to be\n     * \"closest\" or \"farthsest\".\n     * @param {*} curNode \n     * @param {*} included \n     * @param {string} mode\n     * @returns \n     */\n    function findNode(curNode, included, mode) {\n      if (mode !== \"closest\" && mode !== \"farthest\")\n        throw('Invalid Input. Mode is: ' + mode + ' but has to be \"closest\" or \"farthest\"');\n      let minOrMax = Number.MAX_VALUE; //min\n      if (mode == \"farthest\")\n        minOrMax = Number.MIN_VALUE; //max\n      let curClosestOrFarthest = null;\n      for (let node of graph.getNodes()) {\n        if (included[node.index])\n          continue;\n        let dist = euclidDistance(curNode, node);\n        //let dist = graph.findEdge(curNode, node).weight;\n        if (mode == \"closest\") {\n          if (dist < minOrMax) {\n            minOrMax = dist;\n            curClosestOrFarthest = node;\n          }\n        }\n        else {\n          if (dist > minOrMax) {\n            minOrMax = dist;\n            curClosestOrFarthest = node;\n          }\n        }\n      }\n      return curClosestOrFarthest;\n    }\n\n    /**\n     * \n     * @param {Node} node1 \n     * @param {Node} node2 \n     * @returns \n     */\n    function euclidDistance(node1, node2) {\n      if (!node1 || !node2) {\n        throw('a node for dist does not exists');\n        return\n      }\n      let result = (node1.x - node2.x) * (node1.x - node2.x) + (node1.y - node2.y) * (node1.y - node2.y);\n      return Math.sqrt(result);\n    }\n\n    async function christofides() {\n      await computeMST();\n\n\n      let nodesWithOddDegree = getNodesWithOddDegree(graph);  \n\n      for (var node of nodesWithOddDegree) {\n        node.color = \"#ae2a0d\";\n      }\n      // await delay(15000);\n      await findPerfectMatchingMinWeight(nodesWithOddDegree);\n      for (var node of nodesWithOddDegree) {\n        node.color = \"#fff\";\n      }\n      await findEulerianCycle();\n    \n      // for (node of eulerCycle) {\n      //   console.log(node.index+  \"-\");\n      // }\n      let included = new Array(graph.V).fill(false);\n      var curNode = eulerCycle.pop();\n      var temp = curNode;\n      // we have to go back to this one in the end\n      var first = curNode;\n      included[curNode.index] = true;\n      while (eulerCycle.length > 0) {\n        await waitForIsPlaying();\n        curNode = eulerCycle.pop();\n        if (!included[curNode.index]) {\n          included[curNode.index] = true;\n          addEdge(temp, curNode, euclidDistance(temp, curNode));\n          temp = curNode;\n        }\n      }\n\n      addEdge(temp, first, euclidDistance(curNode, first));\n      // let edge = new Edge(nodesWithOddDegree[0], nodesWithOddDegree[1], euclidDistance(nodesWithOddDegree[0], nodesWithOddDegree[1]));\n      // //console.log('there are nodes with odd degree: ' + nodesWithOddDegree.length);\n      // edge.color = 255;\n      // graph.addEdgeFromEdge(edge);\n\n      for (var node of nodesWithOddDegree) {\n        node.color = \"#fff\";\n      }\n      \n    }\n\n    async function findEulerianCycle() {\n      await waitForIsPlaying();\n      // Find a vertex with odd degree\n      let v = graph.getNodes()[0];\n      for (var node of graph.getNodes()) {\n        if (graph.getNeighbors(node).length % 2== 1) {\n          v = node;\n          break;\n        }\n      }\n      // Print tour starting from oddv\n      await printEulerUtil(v);\n    \n    }\n\n    async function printEulerUtil(v) {\n      await waitForIsPlaying();\n      eulerCycle.push(v);\n\n      //Print Euler tour starting from vertex u\n    \n      // Recur for all the vertices adjacent to\n      // this vertex\n      for (let node of graph.getNeighbors(v)) {\n        await delay(500);\n        // If edge u-v is not removed and it's a\n        // valid next edge\n        if (await isValidNextEdge(v, node)) {\n          graph.removeEdge(v, node);\n          await printEulerUtil(node);\n          break;\n        }\n      }\n    }\n\n\n    // The function to check if edge u-v can be considered\n    // as next edge in Euler Tout\n    async function isValidNextEdge(u, v) {\n      // The edge u-v is valid in one of the following\n      // two cases:\n      // 1) If v is the only adjacent vertex of u\n      let count = graph.getNeighbors(u).length; \n      if (count == 1) \n        return true;\n\n      // 2) If there are multiple adjacents, then u-v\n      //    is not a bridge\n      // Do following steps to check if u-v is a bridge\n      \n      // 2.a) count of vertices reachable from u\n      let visited = new Array(graph.V);\n      visited.fill(false);\n      let count1 = await DFSCount(u, visited);\n      \n      // 2.b) Remove edge (u, v) and after removing\n      // the edge, count vertices reachable from u\n      graph.removeEdge(u, v);\n      visited.fill(false);\n      let count2 = await DFSCount(u, visited);\n\n      // 2.c) Add the edge back to the graph\n      graph.addEdge(u, v, euclidDistance(u, v));\n      // 2.d) If count1 is greater, then edge (u, v)\n      // is a bridge\n      return count1 > count2 ? false : true;\n    }\n\n\n    async function DFSCount(v, visited) {\n      // Mark the current node as visited\n      visited[v.index] = true;\n      let count = 1;\n      \n      // Recur for all vertices adjacent to this vertex\n      \n      for (let node of graph.getNeighbors(v)) {\n        if (!visited[node.index]) \n          count += await DFSCount(node, visited);\n      }\n      return count;\n      let nodesWithOddDegree = getNodesWithOddDegree(graph);  \n      await findPerfectMatchingMinWeight();\n      let edge = new Edge(nodesWithOddDegree[0], nodesWithOddDegree[1], euclidDistance(nodesWithOddDegree[0], nodesWithOddDegree[1]));\n      //console.log('there are nodes with odd degree: ' + nodesWithOddDegree.length);\n      edge.color = 255;\n      graph.addEdgeFromEdge(edge);\n      //min-cost-max matching is harder than I thought...\n      \n    }\n\n    /**\n     * \n     * @param {Node} {even number of nodes} \n     */\n    async function findPerfectMatchingMinWeight(nodes) {\n      var edmondsEdges = [];\n      for (var i = 0; i< nodes.length-1; ++i) {\n        for (var j = i+1; j < nodes.length; ++j) {\n          await waitForIsPlaying();\n          var v = nodes[i];\n          var w = nodes[j];\n          var weight = euclidDistance(v, w);\n          edmondsEdges.push([v.index, w.index, - weight])\n        }\n      }\n      var edmonds = new Edmonds(edmondsEdges);\n\n      var result = edmonds.maxWeightMatching();\n      \n\n      for (var i = 0; i < result.length; ++i) {\n        var indexV = i;\n        var indexW = result[i];\n        var v = graph.getNodes().find(node => node.index === indexV);\n        var w = graph.getNodes().find(node => node.index === indexW);\n        if (indexV < indexW) {\n          addEdge(v, w, euclidDistance(v, w));\n        }\n      }\n    } \n\n\n    function getNodesWithOddDegree(g) {\n      let out = [];\n      for (let node of g.getNodes()) {\n        if (g.getNeighbors(node).length % 2 == 1){\n          out.push(node);\n        }\n      }\n      return out;\n    }\n\n    /**\n     * Computes MST from the global variable totalGraph, that we also initialize here\n     */\n    async function computeMST() {\n      //first fill total graph if not already done\n      fillTotalGraph();\n      let distTo = new Array(graph.V).fill(Number.MAX_VALUE);\n      let included = new Array(graph.V).fill(false);\n      distTo[startNode.index] = 0;\n      included[startNode.index] = true;\n      updateDistances(startNode, distTo);\n      //adding V nodes to MST\n      for (let i = 0; i< graph.V-1; ++i) {\n        await waitForIsPlaying();\n        let node = shortestAddableNodeToIncluded(distTo, included);\n        let [weight, root] = findClosestNode(node, getIncludedNodes(included));\n        addEdge(root, node, weight);\n        included[node.index] = true;\n        updateDistances(node, distTo);\n        graph.printGraph();\n        await delay(300);\n      }\n    }\n\n    function updateDistances(node, distTo) {\n      let neighbors = totalGraph.getNeighbors(node);\n      neighbors.forEach(v => {\n        distTo[v.index] = totalGraph.findEdge(v, node).weight;\n      });\n    }\n\n    /**\n     * This function returns a node and the edge connecting this node\n     * with one that is included such that the weight is minimal.\n     * @param {double[]} distTo \n     * @param {boolean[]} included \n     */\n    function shortestAddableNodeToIncluded(distTo, included) {\n      let nonIncludedNodes = getNonIncludedNodes(included);\n      let closestDist = Number.MAX_VALUE;\n      let closestNode = null;\n      for (let node of nonIncludedNodes) {\n        if (distTo[node.index] < closestDist) {\n          closestDist = distTo[node.index];\n          closestNode = node;\n        }\n      }\n      return closestNode;\n    }\n\n    /**\n     * Creates a total graph (edges between all nodes)\n     */\n    function fillTotalGraph() {\n      if (totalGraph.V == 0) {\n        let nodes = graph.getNodes();\n        let allNodesAdded = false;\n        for (let i = 0; i < nodes.length; ++i) {\n          if (!allNodesAdded)\n            totalGraph.addVertex(nodes[i]);\n          for (let j = i+1; j< nodes.length; ++j) {\n            if (!allNodesAdded) \n              totalGraph.addVertex(nodes[j]);\n            let weight = euclidDistance(nodes[i], nodes[j]);\n            let edge = new Edge(nodes[i], nodes[j], weight);\n            totalGraph.addEdgeFromEdge(edge);\n          }\n          if (!allNodesAdded) \n            allNodesAdded = true;\n        }\n      }\n    }\n\n    function getPath() {\n      let path = [];\n      let visited = new Array(graph.V).fill(false);\n      let cur = startNode;\n      for (var i = 0; i < graph.V; ++i) {\n        path.push(cur);\n        visited[cur.index] = true;\n        // get both neighbors\n        var neighbors = graph.getNeighbors(cur);\n        cur = visited[neighbors[0].index] ? neighbors[1] : neighbors[0]; \n      }\n      path.push(startNode);\n      // for (let node of path) {\n      //   console.log(node.index + \"-\");\n      // }\n      return path;\n    }\n\n    function getLength(path) {\n      let length = 0;\n      let n = path.length;\n      for (let i = 0; i < n-1; ++i) {\n        length += euclidDistance(path[i], path[i+1]);\n      }\n      return length;\n    }\n\n    async function do2Opt(path, i, j) {\n      path[i].color = \"#0f61e8\";\n      path[i+1].color = \"#0f61e8\";\n      path[j].color = \"#0f61e8\";\n      path[j+1].color = \"#0f61e8\";\n\n\n      // find out why not defined sometimes!\n      let oldEdge1 = graph.findEdge(path[i], path[i+1]);\n      let oldEdge2 = graph.findEdge(path[j], path[j+1]);\n      oldEdge1.color = \"#0f61e8\";\n      oldEdge2.color = \"#0f61e8\";\n      await waitForIsPlaying();\n\n      await delay(2000);\n      let newEdge1 = new Edge(path[i], path[j], euclidDistance(path[i], path[j]));\n      newEdge1.color = \"#ae2a0d\";\n      let newEdge2 = new Edge(path[i+1], path[j+1], euclidDistance(path[i+1], path[j+1]));\n      newEdge2.color = \"#ae2a0d\";\n      await waitForIsPlaying();\n\n      await delay(2000);\n      graph.addEdgeFromEdge(newEdge1);\n      graph.addEdgeFromEdge(newEdge2);\n      await waitForIsPlaying();\n\n      await delay(2000);\n      removeEdge(path[i], path[i+1]);\n      removeEdge(path[j], path[j+1]);\n      await waitForIsPlaying();\n\n      await delay(2000);\n      newEdge1.color = \"#000000\";\n      newEdge2.color = \"#000000\";\n\n\n      path[i].color = \"#fff\";\n      path[i+1].color = \"#fff\";\n      path[j].color = \"#fff\";\n      path[j+1].color = \"#fff\";\n\n      path[i].color = \"#fff\";\n      path[j+1].color = \"#fff\";\n      path[j].color = \"#fff\";\n      path[i+1].color = \"#fff\";\n\n\n    }\n\n\n    async function twoOpt() {\n      let foundImprovement = true;\n      let path = getPath();\n      let n = path.length;\n      while (foundImprovement) {\n        foundImprovement = false;\n        for (let i = 0; i < n - 2; i++) {\n          for (let j = i + 1; j < n-1; j++) {\n            await waitForIsPlaying();\n            // first subtract new lengths\n            var gain = -euclidDistance(path[i], path[j]);\n            gain -= euclidDistance(path[i+1], path[j+1]);\n            // then add old lengths\n            gain += euclidDistance(path[i], path[i+1]);\n            gain += euclidDistance(path[j], path[j+1]);\n            // If old length is greater than new length\n            if (gain > 1e-4) {\n              await do2Opt(path, i, j);\n              // curLength -= gain;\n              foundImprovement = true;\n              path = getPath();\n            }\n            gain = 0;\n          }\n        }\n      }\n    }\n\n    async function threeOpt() {\n      let foundImprovement = true;\n      let path = getPath();\n      let n = path.length;\n      while (foundImprovement) {\n        foundImprovement = false;\n        for (let i = 0; i < n - 3; ++i) {\n          for (let j = i + 1; j < n-2; ++j) {\n            for (let k = j+1; k < n-1; ++k) {\n              await waitForIsPlaying();\n\n              // first subtract new lengths\n              var gain = await gainOfBest3OptWiring(path, i, j, k);\n              // If old length is greater than new length\n              if (gain > 1e-4) {\n                // curLength -= gain;\n                foundImprovement = true;\n                path = getPath();\n              }\n              gain = 0;\n            }\n          }\n        }\n      }\n    }\n\n    async function gainOfBest3OptWiring(path, i, j, k) {\n      // (a,b) are one edge, (c,d) and (e,f)\n      let a = path[i];\n      let b = path[i+1];\n      let c  = path[j];\n      let d = path[j+1];\n      let e = path[k];\n      let f = path[k+1];\n\n      // this has good picture for all permutations: http://tsp-basics.blogspot.com/2017/03/3-opt-move.html \n      // a going to b\n      let w0 = [a, b, c, d, e, f]; //that is original wiring\n      let w1 = [a, b, c, e, d, f];\n      // a going to c\n      let w2 = [a, c, b, d, e, f];\n      let w3 = [a, c, b, e, d, f];\n      // a going to d\n      let w4 = [a, d, e, b, c, f];\n      let w5 = [a, d, e, c, b, f];\n      // a going to e\n      let w6 = [a, e, d, b, c, f];\n      let w7 = [a, e, d, c, b, f];\n      let alternativeOptions = [w1, w2, w3, w4, w5, w6, w7];\n      let shortestWiring = w0;\n      let originalLength = length3OptWiring(w0);\n      let shortestLength = originalLength;\n      for (let option of alternativeOptions) {\n        await waitForIsPlaying();\n        let length = length3OptWiring(option);\n        if (shortestLength > length) {\n          shortestLength = length;\n          shortestWiring = option;\n        }\n      }\n\n      if (originalLength > shortestLength) { \n        a.color = \"#0f61e8\";\n        b.color = \"#0f61e8\";\n        c.color = \"#0f61e8\";\n        d.color = \"#0f61e8\";\n        e.color = \"#0f61e8\";\n        f.color = \"#0f61e8\";\n        let oldEdge1 = graph.findEdge(a, b);\n        oldEdge1.color = \"#0f61e8\";\n        let oldEdge2 = graph.findEdge(c, d);\n        oldEdge2.color = \"#0f61e8\";\n        let oldEdge3 = graph.findEdge(e, f);\n        oldEdge3.color = \"#0f61e8\";\n        await delay(2000);\n        //color new edges and add them\n        let newEdge1 =new Edge(shortestWiring[0], shortestWiring[1], euclidDistance(shortestWiring[0], shortestWiring[1]));\n        let newEdge2 = new Edge(shortestWiring[2], shortestWiring[3], euclidDistance(shortestWiring[2], shortestWiring[3]));\n        let newEdge3 = new Edge(shortestWiring[4], shortestWiring[5], euclidDistance(shortestWiring[4], shortestWiring[5]));\n        newEdge1.color = \"#ae2a0d\";\n        newEdge2.color = \"#ae2a0d\";\n        newEdge3.color = \"#ae2a0d\";\n        graph.addEdgeFromEdge(newEdge1);\n        graph.addEdgeFromEdge(newEdge2);\n        graph.addEdgeFromEdge(newEdge3);\n        await delay(2000);\n        removeEdge(a, b);\n        removeEdge(c, d);\n        removeEdge(e, f);\n        await delay(1000);\n        newEdge1.color = \"#000000\";\n        newEdge2.color = \"#000000\";\n        newEdge3.color = \"#000000\";\n        a.color = \"#fff\";\n        b.color = \"#fff\";\n        c.color = \"#fff\";\n        d.color = \"#fff\";\n        e.color = \"#fff\";\n        f.color = \"#fff\";\n\n      }\n      \n      return originalLength - shortestLength;\n\n    }\n\n    function length3OptWiring(wiring) {\n      let length = 0;\n      for (let i = 0; i < 6; i+=2) {\n        length += euclidDistance(wiring[i], wiring[i+1]);\n      }\n      return length;\n    }\n\n    /**\n     * \n     * @param {number of clusters} k \n     */\n    async function clusterNaively(k) {\n      fillTotalGraph();\n      let nodesPerCluster = totalGraph.V/k;\n      let edges = totalGraph.getEdges();\n      edges.sort((e1, e2) => (e1.weight >= e2.weight) ? 1 : -1);\n      //add small edges to cluster, if it doesn't exceed its size (size is naively n/k)\n      for (let e of edges) {\n        await delay(1000);    \n        let v1 = e.either();\n        let v2 = e.other(v1);  \n        //case 1, both nodes not included\n        if (!v1.root && !v2.root) {\n          v2.root = v1;\n          v1.isRoot = true;\n          v1.children = 1;\n          addEdge(v1, v2, e.weight);\n          continue;\n        }\n        if (v1.isRoot && !v2.root || v1.root && !v2.root) {\n            if (v1.isRoot) {\n              if (v1.children + 1 < nodesPerCluster) {\n                v2.root = v1;\n                v1.children++;\n              }\n            }\n            else {\n              v2.root = v1.root; \n              v1.root.children++;\n            }\n            addEdge(v1, v2, e.weight);\n            continue;\n          }\n        if (v2.isRoot && !v1.root || v2.root && !v1.root) {\n          if (v2.root.children + 1 < nodesPerCluster) {\n            v1.root = v2.root;\n            v2.root.children++;\n            addEdge(v1, v2, e.weight);\n          }\n          continue;\n        }\n        if (v1.root && v2.root) {\n          if (v1.root.children + 1 + v2.root + 1 < nodesPerCluster) {\n            let temp = v1.root.children + 1;\n            v1.root = v2.root;\n            v2.root.children += temp;\n            addEdge(v1, v2, e.weight);\n          }\n          continue;\n        }\n      }\n\n    }\n\n    \n\n}\n\nexport default sketch;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}